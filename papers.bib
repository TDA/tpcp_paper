
@Article{	  abadi2005,
  author	= {Abadi, Martin and Budiu, Mihai and Erlingsson, Ulfar and
		  Ligatti, Jay},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Abadi et al. - Control-Flow Integrity.pdf:pdf},
  isbn		= {1595932267},
  journal	= {ACM Conference on Computer and Communications Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Control-Flow Integrity}},
  url		= {papers3://publication/uuid/A96D503C-9776-4CC8-99A7-9D13A020DF5C}
		  ,
  year		= {2005}
}

@Article{	  abadi2009,
  abstract	= {Current software attacks often build on exploits that
		  subvert machine-code execution. The enforcement of a basic
		  safety property, control-flow integrity (CFI), can prevent
		  such attacks from arbitrarily controlling program behavior.
		  CFI enforcement is simple and its guarantees can be
		  established formally, even with respect to powerful
		  adversaries. Moreover, CFI enforcement is practical: It is
		  compatible with existing software and can be done
		  efficiently using software rewriting in commodity systems.
		  Finally, CFI provides a useful foundation for enforcing
		  further security policies, as we demonstrate with efficient
		  software implementations of a protected shadow call stack
		  and of access control for memory regions.},
  author	= {Abadi, Mart{\'{\i}}n and Budiu, Mihai and Erlingsson,
		  {\'{U}}lfar and Ligatti, Jay},
  doi		= {10.1145/1609956.1609960},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Abadi et al. - Control-flow integrity principles,
		  implementations, and applications.pdf:pdf},
  isbn		= {1595932267},
  issn		= {10949224},
  journal	= {ACM Transactions on Information and System Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  number	= {1},
  pages		= {1--40},
  title		= {{Control-flow integrity principles, implementations, and
		  applications}},
  volume	= {13},
  year		= {2009}
}

@Article{	  adelstein2002,
  abstract	= {Malicious boot firmware is a largely unrecognized but
		  significant security risk to our global information
		  infrastructure. Since boot firmware executes before the
		  operating system is loaded, it can easily circumvent any
		  operating system-based security mechanism. Boot firmware
		  programs are typically written by third-party device
		  manufacturers and may come from various suppliers of
		  unknown origin. We describe an approach to this problem
		  based on load-time verification of onboard device drivers
		  against a standard security policy designed to limit access
		  to system resources. We also describe our ongoing effort to
		  construct a prototype of this technique for open firmware
		  boot platforms.},
  author	= {Adelstein, F. and Stillerman, M. and Kozen, D.},
  doi		= {10.1109/CSAC.2002.1176312},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2002 -
		  Adelstein, Stillerman, Kozen - Malicious code detection for
		  open firmware.pdf:pdf},
  isbn		= {0-7695-1828-1},
  issn		= {1063-9527},
  journal	= {Proceedings of the Annual Computer Security Applications
		  Conference},
  title		= {{Malicious code detection for open firmware}},
  year		= {2002}
}

@Article{	  afonso2016,
  abstract	= {—Current static analysis techniques for Android
		  ap-plications operate at the Java level—that is, they
		  analyze either the Java source code or the Dalvik bytecode.
		  However, Android allows developers to write code in C or
		  C++ that is cross-compiled to multiple binary
		  architectures. Furthermore, the Java-written components and
		  the native code components (C or C++) can interact. Native
		  code can access all of the Android APIs that the Java code
		  can access, as well as alter the Dalvik Virtual Machine,
		  thus rendering static analysis techniques for Java unsound
		  or misleading. In addition, malicious apps frequently hide
		  their malicious functionality in native code or use native
		  code to launch kernel exploits. It is because of these
		  security concerns that previous research has proposed
		  native code sandboxing, as well as mechanisms to enforce
		  security policies in the sandbox. However, it is not clear
		  whether the large-scale adoption of these mechanisms is
		  practical: is it possible to define a meaningful security
		  policy that can be imposed by a native code sandbox without
		  breaking app functionality? In this paper, we perform an
		  extensive analysis of the native code usage in 1.2 million
		  Android apps. We first used static analysis to identify a
		  set of 446k apps potentially using native code, and we then
		  analyzed this set using dynamic analysis. This analysis
		  demonstrates that sandboxing native code with no
		  permissions is not ideal, as apps' native code components
		  perform activities that require Android permissions.
		  However, our analysis provided very encouraging insights
		  that make us believe that sandboxing native code can be
		  feasible and useful in practice. In fact, it was possible
		  to automatically generate a native code sandboxing policy,
		  which is derived from our analysis, that limits many
		  malicious behaviors while still allowing the correct
		  execution of the behavior witnessed during dynamic analysis
		  for 99.77{\%} of the benign apps in our dataset. The usage
		  of our system to generate policies would reduce the attack
		  surface available to native code and, as a further benefit,
		  it would also enable more reliable static analysis of Java
		  code.},
  author	= {Afonso, Vitor and Bianchi, Antonio and Fratantonio, Yanick
		  and Doup{\'{e}}, Adam and Polino, Mario and de Geus, Paulo
		  and Kruegel, Christopher and Vigna, Giovanni and {Santa
		  Barbara}, Uc},
  doi		= {10.14722/ndss.2016.23384},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/going-native-ndss2016.pdf:pdf}
		  ,
  isbn		= {189156241X},
  journal	= {Proceedings of the ISOC Network and Distributed System
		  Security Symposium (NDSS)},
  pages		= {1--15},
  title		= {{Going Native: Using a Large-Scale Analysis of Android
		  Apps to Create a Practical Native-Code Sandboxing Policy}},
  year		= {2016}
}

@Article{	  agrawal2007,
  author	= {Agrawal, Dakshi and Baktir, Selcuk and Karakoyunlu, Deniz
		  and Rohatgi, Pankaj and Sunar, Berk},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Agrawal et al. - Trojan Detection Using IC
		  Fingerprinting.pdf:pdf},
  journal	= {Proceedings of the IEEE Symposium on Security and
		  Privacy},
  title		= {{Trojan Detection Using IC Fingerprinting}},
  year		= {2007}
}

@Article{	  alfaro2007,
  author	= {Alfaro, J. G. and Boulahia-Cuppens, N. and Cuppens, F.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Alfaro, Boulahia-Cuppens, Cuppens - Complete analysis of
		  configuration rules to guarantee reliable network security
		  policies.pdf:pdf},
  journal	= {International Journal of Information Security},
  keywords	= {detection systems,firewalls,intrusion,network
		  security,policy anomalies},
  title		= {{Complete analysis of configuration rules to guarantee
		  reliable network security policies}},
  year		= {2007}
}

@InProceedings{	  anand2012automated,
  title		= {Automated concolic testing of smartphone apps},
  author	= {Anand, Saswat and Naik, Mayur and Harrold, Mary Jean and
		  Yang, Hongseok},
  booktitle	= {Proceedings of the ACM SIGSOFT 20th International
		  Symposium on the Foundations of Software Engineering},
  pages		= {59},
  year		= {2012},
  organization	= {ACM}
}

@Article{	  ansel,
  author	= {Ansel, Jason and Marchenko, Petr and Taylor, Elijah and
		  Chen, Brad and Schuff, Derek L and Sehr, David and Biffle,
		  Cliff L and Yee, Bennet},
  file		= {:home/osboxes/.local/share/data/Mendeley Ltd./Mendeley
		  Desktop/Downloaded/Ansel et al. - Unknown -
		  Language-Independent Sandboxing of Just-In-Time Compilation
		  and Self-Modifying Code.pdf:pdf},
  isbn		= {9781450306638},
  keywords	= {just-in-time compilation,modifying
		  code,sandboxing,security,self-,software fault isolation},
  title		= {{Language-Independent Sandboxing of Just-In-Time
		  Compilation and Self-Modifying Code}}
}

@Article{	  ansel,
  author	= {Ansel, Jason and Marchenko, Petr and Taylor, Elijah and
		  Chen, Brad and Schuff, Derek L and Sehr, David and Biffle,
		  Cliff L and Yee, Bennet},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/Language-Independent
		  Sandboxing of Just-In-Time Comilation and Self-Modifying
		  Code.pdf:pdf},
  isbn		= {9781450306638},
  keywords	= {just-in-time compilation,modifying
		  code,sandboxing,security,self-,software fault isolation},
  title		= {{Language-Independent Sandboxing of Just-In-Time
		  Compilation and Self-Modifying Code}}
}

@Article{	  arbaugh1997,
  abstract	= {In a computer system, the integrity of lower layers is
		  typically treated as axiomatic by higher layers. Under the
		  presumption that the hardware comprising the machine (the
		  lowest layer) is valid, the integrity of a layer can be
		  guaranteed if and only if: (1) the integrity of the lower
		  layers is checked and (2) transitions to higher layers
		  occur only after integrity checks on them are complete. The
		  resulting integrity {\&}amp;ldquo;chain{\&}amp;rdquo;
		  inductively guarantees system integrity. When these
		  conditions are not met, as they typically are not in the
		  bootstrapping (initialization) of a computer system, no
		  integrity guarantees can be made, yet these guarantees are
		  increasingly important to diverse applications such as
		  Internet commerce, security systems and
		  {\&}amp;ldquo;active networks{\&}amp;rdquo;. In this paper,
		  we describe the AEGIS architecture for initializing a
		  computer system. It validates integrity at each layer
		  transition in the bootstrap process. AEGIS also includes a
		  recovery process for integrity check failures, and we show
		  how this results in robust systems},
  annote	= {1. How to trust the lower layers of the software stack.
		  
		  2. Have each layer trust and verify the execution of the
		  next layer before it is executed.
		  
		  3. TPM.
		  
		  4. Hard to say where to put this, as the TPM works to
		  secure all layers.},
  author	= {Arbaugh, W.a. and Farber, D.J. and Smith, J.M.},
  doi		= {10.1109/SECPRI.1997.601317},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1997 -
		  Arbaugh, Farber, Smith - A secure and reliable bootstrap
		  architecture.pdf:pdf},
  isbn		= {0-8186-7828-3},
  issn		= {1081-6011},
  journal	= {Proceedings. 1997 IEEE Symposium on Security and Privacy
		  (Cat. No.97CB36097)},
  title		= {{A secure and reliable bootstrap architecture}},
  year		= {1997}
}

@Article{	  arnold2009,
  abstract	= {Ksplice allows system administrators to apply patches to
		  their operating system kernels without rebooting. Unlike
		  previous hot update systems, Ksplice operates at the object
		  code layer, which allows Ksplice to transform many
		  traditional source code patches into hot updates with
		  little or no programmer involvement. In the common case
		  that a patch does not change the semantics of persistent
		  data structures, Ksplice can create a hot update without a
		  programmer writing any new code.},
  annote	= {1. How to apply kernel patches without downtime.
		  
		  2. Prepare updates at the object code level, rather than at
		  the source cod level.
		  
		  3. Rebootless updates in many cases with no programmer
		  intervention, however some cases require developer
		  annotation.
		  
		  4. Applying patches is an important problem.},
  author	= {Arnold, Jeff and Kaashoek, Frans},
  doi		= {10.1145/1519065.1519085},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Arnold, Kaashoek - Ksplice Automatic Rebootless Kernel
		  Updates.pdf:pdf},
  isbn		= {978-1-60558-482-9},
  journal	= {Proceedings of the 4th ACM European Conference on Computer
		  Systems},
  keywords	= {dynamic software updates,hot updates},
  pages		= {187--198},
  title		= {{Ksplice: Automatic Rebootless Kernel Updates}},
  year		= {2009}
}

@Article{	  attanasio1973,
  author	= {Attanasio, C R and Markstein, P W and Phillips, R J},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1973 -
		  Attanasio, Markstein, Phillips - Penetrating an operating
		  system a study of VM 370 integrity.pdf:pdf},
  journal	= {IBM Systems Journal},
  pages		= {102--116},
  title		= {{Penetrating an operating system : a study of VM / 370
		  integrity}},
  volume	= {1},
  year		= {1973}
}

@Article{	  azab2010,
  abstract	= {This paper presents HyperSentry, a novel framework to
		  enable integrity measurement of a running hypervisor (or
		  any other highest privileged software layer on a system).
		  Unlike existing solutions for protecting privileged
		  software, HyperSentry does not introduce a higher
		  privileged software layer below the integrity measurement
		  target, which could start another race with malicious
		  attackers in obtaining the highest privilege in the system.
		  Instead, HyperSentry introduces a software component that
		  is properly isolated from the hypervisor to enable stealthy
		  and in-context measurement of the runtime integrity of the
		  hypervisor. While stealthiness is necessary to ensure that
		  a compromised hypervisor does not have a chance to hide the
		  attack traces upon detecting an up-coming measurement,
		  in-context measurement is necessary to retrieve all the
		  needed inputs for a successful integrity measurement.
		  HyperSentry uses an out-of-band channel (e.g., Intelligent
		  Platform Management Interface (IPMI), which is commonly
		  available on server platforms) to trigger the stealthy
		  measurement, and adopts the System Management Mode (SMM) to
		  protect its base code and critical data. A key contribution
		  of HyperSentry is the set of novel techniques that overcome
		  SMM's limitation, providing an integrity measurement agent
		  with (1) the same contextual information available to the
		  hypervisor, (2) completely protected execution, and (3)
		  attestation to its output. To evaluate HyperSentry, we
		  implement a prototype of the framework along with an
		  integrity measurement agent for the Xen hypervisor. Our
		  experimental evaluation shows that HyperSentry is a
		  low-overhead practical solution for real world systems.},
  author	= {Azab, Ahmed M and Skalsky, Nathan C},
  doi		= {10.1145/1866307.1866313},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Azab, Skalsky - HyperSentry Enabling Stealthy In-context
		  Measurement of Hypervisor Integrity.pdf:pdf},
  isbn		= {9781450302449},
  issn		= {15437221},
  journal	= {Measurement},
  keywords	= {hypervisor integrity,integrity
		  measurement,virtualization},
  pages		= {38--49},
  title		= {{HyperSentry : Enabling Stealthy In-context Measurement of
		  Hypervisor Integrity}},
  url		= {http://portal.acm.org/citation.cfm?id=1866313},
  year		= {2010}
}

@Article{	  azab2011,
  abstract	= {SICE is a novel framework to provide hardware-level isola-
		  tion and protection for sensitive workloads running on x86
		  platforms in compute clouds. Unlike existing isolation
		  tech- niques, SICE does not rely on any software component
		  in the host environment (i.e., an OS or a hypervisor).
		  Instead, the security of the isolated environments is
		  guaranteed by a trusted computing base that only includes
		  the hardware, the BIOS, and the SystemManagementMode (SMM).
		  SICE provides fast context switching to and from an
		  isolated envi- ronment, allowing isolated workloads to
		  time-share the phys- ical platform with untrusted
		  workloads. Moreover, SICE supports a large range (up to
		  4GB) of isolated memory. Fi- nally, the most unique feature
		  of SICE is the use of multi- core processors to allow the
		  isolated environments to run concurrently and yet securely
		  beside the untrusted host. We have implemented a SICE
		  prototype using an AMD x86 hardware platform. Our
		  experiments show that SICE performs fast context switching
		  (67 µs) to and from the iso- lated environment and that it
		  imposes a reasonable overhead (3{\%} on all but one
		  benchmark) on the operation of an iso- lated Linux virtual
		  machine. Our prototype demonstrates that, subject to a
		  careful security review of the BIOS soft- ware and the SMM
		  hardware implementation, current hard- ware architecture
		  already provides abstractions that can sup- port building
		  strong isolation mechanisms using a very small SMM software
		  foundation of about 300 lines of code.},
  author	= {Azab, Ahmed M and Ning, Peng and Zhang, Xiaolan},
  doi		= {10.1145/2046707.2046752},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Azab - SICE A Hardware-Level Strongly Isolated Computing
		  Environment for x86 Multi-core Platforms.pdf:pdf},
  isbn		= {9781450309486},
  issn		= {15437221},
  journal	= {Environment},
  keywords	= {isolation,trusted computing,virtualization security},
  mendeley-groups={4 - Hypervisor},
  pages		= {375--388},
  title		= {{SICE : A Hardware-Level Strongly Isolated Computing
		  Environment for x86 Multi-core Platforms}},
  year		= {2011}
}

@InProceedings{	  ball1999concept,
  title		= {The concept of dynamic analysis},
  author	= {Ball, Thomas},
  booktitle	= {Software Engineering—ESEC/FSE’99},
  pages		= {216--234},
  year		= {1999},
  organization	= {Springer}
}

@InProceedings{	  balzarotti07:multi_module_va,
  author	= {Balzarotti, Davide and Cova, Marco and Felmetsger,
		  Viktoria V. and Vigna, Giovanni},
  booktitle	= {Proceedings of the ACM conference on Computer and
		  Communications Security (CCS)},
  pages		= {25--35},
  title		= {{Multi-module Vulnerability Analysis of Web-based
		  Applications}},
  year		= {2007}
}

@InProceedings{	  balzarotti2008,
  author	= {Balzarotti, Davide and Cova, Marco and Felmetsger, Vika
		  and Jovanovic, Nenad and Kirda, Engin and Kruegel,
		  Christopher and Vigna, Giovanni},
  booktitle	= {Proceedings of the 2008 IEEE Symposium on Security and
		  Privacy},
  title		= {{Saner: Composing static and dynamic analysis to validate
		  sanitization in web applications}},
  url		= {http://www.computer.org/portal/web/csdl/doi/10.1109/SP.2008.22}
		  ,
  year		= {2008}
}

@Article{	  banga2008,
  author	= {Banga, Mainak and Hsiao, Michael S.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Banga, Hsiao - A Region Based Approach for the
		  Identification of Hardware Trojans.pdf:pdf},
  journal	= {International Workshop on Hardware-Oriented Security and
		  Trust (HOST'08)},
  pages		= {40--47},
  title		= {{A Region Based Approach for the Identification of
		  Hardware Trojans}},
  year		= {2008}
}

@Article{	  banga2008a,
  author	= {Banga, Mainak and Chandrasekar, Maheshwar and Fang, Lei
		  and Hsiao, Michael S.},
  doi		= {10.1145/1366110.1366196},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Banga et al. - Guided test generation for isolation and
		  detection of embedded trojans in ics.pdf:pdf},
  isbn		= {9781595939999},
  journal	= {Proceedings of the 18th ACM Great Lakes symposium on VLSI
		  (GLSVLSI)},
  pages		= {363},
  title		= {{Guided test generation for isolation and detection of
		  embedded trojans in ics}},
  url		= {http://portal.acm.org/citation.cfm?doid=1366110.1366196},
  year		= {2008}
}

@Article{	  bao2015,
  author	= {Bao, Chongxi and Forte, Domenic and Srivastava, Ankur},
  doi		= {10.1109/TCAD.2015.2424929},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Bao, Forte, Srivastava - Temperature Tracking Towards
		  Robust Run-time Detection of Hardware Trojans.pdf:pdf},
  issn		= {0278-0070},
  journal	= {IEEE Transactions on Computer-Aided Design of Integrated
		  Circuits and Systems},
  number	= {c},
  pages		= {1--1},
  title		= {{Temperature Tracking: Towards Robust Run-time Detection
		  of Hardware Trojans}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=7090988}
		  ,
  volume	= {0070},
  year		= {2015}
}

@Article{	  barham2003,
  abstract	= {Numerous systems have been designed which use
		  virtualization to subdivide the ample resources of a modern
		  computer. Some require specialized hardware, or cannot
		  support commodity operating systems. Some target 100{\%}
		  binary compatibility at the expense of performance. Others
		  sacrifice security or functionality for speed. Few offer
		  resource isolation or performance guarantees; most provide
		  only best-effort provisioning, risking denial of
		  service.This paper presents Xen, an x86 virtual machine
		  monitor which allows multiple commodity operating systems
		  to share conventional hardware in a safe and resource
		  managed fashion, but without sacrificing either performance
		  or functionality. This is achieved by providing an
		  idealized virtual machine abstraction to which operating
		  systems such as Linux, BSD and Windows XP, can be ported
		  with minimal effort.Our design is targeted at hosting up to
		  100 virtual machine instances simultaneously on a modern
		  server. The virtualization approach taken by Xen is
		  extremely efficient: we allow operating systems such as
		  Linux and Windows XP to be hosted simultaneously for a
		  negligible performance overhead --- at most a few percent
		  compared with the unvirtualized case. We considerably
		  outperform competing commercial and freely available
		  solutions in a range of microbenchmarks and system-wide
		  tests.},
  author	= {Barham, Paul and Dragovic, Boris and Fraser, Keir and
		  Hand, Steven and Harris, Tim and Ho, Alex and Neugebauer,
		  Rolf and Pratt, Ian and Warfield, Andrew},
  doi		= {10.1145/1165389.945462},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Barham et al. - Xen and the art of virtualization.pdf:pdf},
  isbn		= {1-58113-757-5},
  issn		= {01635980},
  journal	= {ACM SIGOPS Operating Systems Review},
  keywords	= {hypervisors,paravirtualization,virtual machine monitors},
  number	= {5},
  pages		= {164},
  pmid		= {685953},
  title		= {{Xen and the art of virtualization}},
  volume	= {37},
  year		= {2003}
}

@Article{	  barth2010,
  abstract	= {Browser extensions are remarkably popular, with one in
		  three Firefox users running at least one extension.
		  Although well-intentioned, extension developers are often
		  not security experts and write buggy code that can be
		  exploited by ma- licious web site operators. In the Firefox
		  extension system, these exploits are dangerous because
		  extensions run with the users full privileges and can read
		  and write arbitrary files and launch new processes. In this
		  paper, we analyze 25 popular Firefox extensions and find
		  that 88{\%} of these extensions need less than the full set
		  of available privileges. Additionally, we find that 76{\%}
		  of these extensions use un- necessarily powerful APIs,
		  making it difficult to reduce their privileges. We propose
		  a new browser extension system that improves security by
		  using least privilege, privilege separa- tion, and strong
		  isolation. Our system limits the misdeeds an attacker can
		  perform through an extension vulnerabil- ity. Our design
		  has been adopted as the Google Chrome extension system.},
  author	= {Barth, Adam and Felt, Adrienne Porter and Saxena, Prateek
		  and Boodman, Aaron},
  doi		= {10.1111/j.1365-2486.2006.01169.x},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Barth et al. - Protecting Browsers from Extension
		  Vulnerabilities.pdf:pdf},
  issn		= {13541013},
  journal	= {Ndss},
  pages		= {1315--1329},
  pmid		= {22196736},
  title		= {{Protecting Browsers from Extension Vulnerabilities}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.5579{\&}amp;rep=rep1{\&}amp;type=pdf}
		  ,
  volume	= {147},
  year		= {2010}
}

@Article{	  barth2010,
  abstract	= {Browser extensions are remarkably popular, with one in
		  three Firefox users running at least one extension.
		  Although well-intentioned, extension developers are often
		  not security experts and write buggy code that can be
		  exploited by ma- licious web site operators. In the Firefox
		  extension system, these exploits are dangerous because
		  extensions run with the users full privileges and can read
		  and write arbitrary files and launch new processes. In this
		  paper, we analyze 25 popular Firefox extensions and find
		  that 88{\%} of these extensions need less than the full set
		  of available privileges. Additionally, we find that 76{\%}
		  of these extensions use un- necessarily powerful APIs,
		  making it difficult to reduce their privileges. We propose
		  a new browser extension system that improves security by
		  using least privilege, privilege separa- tion, and strong
		  isolation. Our system limits the misdeeds an attacker can
		  perform through an extension vulnerabil- ity. Our design
		  has been adopted as the Google Chrome extension system.},
  author	= {Barth, Adam and Felt, Adrienne Porter and Saxena, Prateek
		  and Boodman, Aaron},
  doi		= {10.1111/j.1365-2486.2006.01169.x},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Barth et al. - Protecting Browsers from Extension
		  Vulnerabilities.pdf:pdf},
  issn		= {13541013},
  journal	= {Ndss},
  mendeley-groups={6 - Application/Attack surface reduction},
  pages		= {1315--1329},
  pmid		= {22196736},
  title		= {{Protecting Browsers from Extension Vulnerabilities}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.5579{\&}amp;rep=rep1{\&}amp;type=pdf}
		  ,
  volume	= {147},
  year		= {2010}
}

@Article{	  basnight2013,
  abstract	= {Recent attacks on industrial control systems, such as the
		  highly publicized Stuxnet malware, have intensified a "race
		  to the bottom" where lower-level attacks have a tactical
		  advantage. Programmable logic controller (PLC) firmware,
		  which provides a software-driven interface between system
		  inputs and physical outputs, can be easily modified at the
		  user level. Efforts directed at protecting against firmware
		  modification are hindered by the lack of foundational
		  research about attack development and implementation. This
		  paper examines the vulnerability of PLCs to intentional
		  firmware modifications in order to obtain a better
		  understanding of the threats posed by PLC firmware
		  modification attacks and the feasibility of these attacks.
		  A general firmware analysis methodology is presented, and a
		  proof-of-concept experiment is used to demonstrate how
		  legitimate firmware can be updated and uploaded to an
		  Allen-Bradley ControlLogix L61 PLC. © 2013.},
  author	= {Basnight, Zachry and Butts, Jonathan and Lopez, Juan and
		  Dube, Thomas},
  doi		= {10.1016/j.ijcip.2013.04.004},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Basnight et al. - Firmware modification attacks on
		  programmable logic controllers.pdf:pdf},
  issn		= {18745482},
  journal	= {International Journal of Critical Infrastructure
		  Protection},
  keywords	= {Firmware,Industrial control systems,Modification
		  attacks,Programmable logic controllers,Reverse
		  engineering},
  number	= {2},
  pages		= {76--84},
  publisher	= {Elsevier},
  title		= {{Firmware modification attacks on programmable logic
		  controllers}},
  url		= {http://dx.doi.org/10.1016/j.ijcip.2013.04.004},
  volume	= {6},
  year		= {2013}
}

@InProceedings{	  bek,
  annote	= {This is an interesting paper that looks at the aspect of
		  creating provably secure sanitizers.
		  
		  They create a new language, BEK, that they translate into
		  functional tranducers. In this way, they can compare two
		  sanitizers to see if they produce the same output, they can
		  see if the sanitizier can produce any set of regular
		  expressions, and they can see if the sanitizer is
		  idempotent.
		  
		  They can then translate that sanitizer into C{\#} or
		  JavaScript.},
  author	= {Hooimeijer, Pieter and Livshits, Benjamin and Molnar,
		  David and Saxena, Prateek and Veanes, Margus},
  booktitle	= {Proceedings of the 20th USENIX conference on Security
		  (USENIX 2011)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Hooimeijer et al. - Fast and Precise Sanitizer Analysis
		  with BEK.pdf:pdf},
  title		= {{Fast and Precise Sanitizer Analysis with BEK}},
  year		= {2011}
}

@Article{	  belay2012,
  abstract	= {Dune is a system that provides applications with direct
		  but safe access to hardware features such as ring
		  protection, page tables, and tagged TLBs, while preserving
		  the exist- ing OS interfaces for processes. Dune uses the
		  virtualiza- tion hardware in modern processors to provide a
		  process, rather than a machine abstraction. It consists of
		  a small kernel module that initializes virtualization
		  hardware and mediates interactions with the kernel, and a
		  user-level li- brary that helps applications manage
		  privileged hardware features. We present the implementation
		  of Dune for 64- bit x86 Linux. We use Dune to implement
		  three user- level applications that can benefit from access
		  to privi- leged hardware: a sandbox for untrusted code, a
		  privilege separation facility, and a garbage collector. The
		  use of Dune greatly simplifies the implementation of these
		  appli- cations and provides significant performance
		  advantages.},
  author	= {Belay, Adam and Bittau, Andrea and Mashtizadeh, Ali},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Belay, Bittau, Mashtizadeh - Dune safe user-level access to
		  privileged cpu features.pdf:pdf},
  isbn		= {978-1-931971-96-6},
  journal	= {OSDI '12: Proceedings of the 10th USENIX conference on
		  Operating Systems Design and Implementation},
  pages		= {335--348},
  title		= {{Dune: safe user-level access to privileged cpu
		  features}},
  url		= {https://www.usenix.org/system/files/conference/osdi12/osdi12-final-117.pdf}
		  ,
  year		= {2012}
}

@InProceedings{	  bellovin1992,
  author	= {Bellovin, Steven M.},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  doi		= {10.1016/S1361-3723(01)01013-2},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1992 -
		  Bellovin - There Be Dragons.pdf:pdf},
  issn		= {13613723},
  title		= {{There Be Dragons}},
  year		= {1992}
}

@Article{	  bellovin1994,
  author	= {Bellovin, Steven M. and Cheswick, William R.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1994 -
		  Bellovin, Cheswick - Network Firewalls.pdf:pdf},
  isbn		= {0849330459 (alk. paper)},
  journal	= {IEEE Communications Magazine},
  number	= {September},
  pages		= {1--51},
  title		= {{Network Firewalls}},
  year		= {1994}
}

@Article{	  bertino2011,
  abstract	= {Data represent an extremely important asset for any
		  organization. Confidential data such as military secrets or
		  intellectual property must never be disclosed outside the
		  organization. Therefore, one of the most severe threats in
		  the case of cyber-insider attacks is the loss of
		  confidential data due to exfiltration. A malicious insider
		  who has the proper credentials to access the organization
		  databases may, over time, send data outside the
		  organization network through a variety of channels, such as
		  email, crafted HTTP requests that encapsulate data, etc.
		  Existing security tools for detection of cyber-attacks
		  focus on protecting the boundary between the organization
		  and the outside world. Numerous network-level intrusion
		  detection systems (IDS) exist, which monitor the traffic
		  pattern and attempt to infer anomalous behavior. While such
		  tools may be effective in protecting against external
		  attacks, they are less suitable when the data exfiltration
		  is performed by an insider who has the proper credentials
		  and authorization to access resources within the
		  organization. In this paper, we argue that DBMS-layer
		  detection and prevention systems are the best alternative
		  to defend against data exfiltration because: (1) DBMS
		  access is performed through a standard, unique language
		  (SQL) with well-understood semantics; (2) monitoring the
		  potential disclosure of confidential data is more effective
		  if done as close as possible to the data source; and (3)
		  the DBMS layer already has in place a thorough mechanism
		  for enforcing access control based on subject credentials.
		  By analyzing the pattern of interaction between subjects
		  and the DBMS, it is possible to detect anomalous activity
		  that is indicative of early signs of exfiltration. In the
		  paper, we outline a taxonomy of cyber-insider dimensions of
		  activities that are indicative of data exfiltration, and we
		  discuss a high-level architecture and mechanisms for early
		  detection of exfiltration by insiders. We also outline a
		  virtualization-based mechanism that prevents insiders from
		  exfiltrating data, even in the case when they manage to
		  gain control over the network. The protection mechanism
		  relies on explicit authorization of data transfers that
		  cross the organizational boundary. Copyright 2011 ACM.},
  author	= {Bertino, Elisa and Ghinita, Gabriel},
  doi		= {10.1145/1966913.1966916},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Bertino, Ghinita - Towards Mechanisms for Detection and
		  Prevention of Data Exfiltration by Insiders.pdf:pdf},
  isbn		= {9781450305648},
  journal	= {Information, Computer and Communications Security},
  keywords	= {data exfiltration,design,insider
		  threat,management,security},
  pages		= {10},
  title		= {{Towards Mechanisms for Detection and Prevention of Data
		  Exfiltration by Insiders}},
  url		= {http://portal.acm.org/citation.cfm?doid=1966913.1966916},
  year		= {2011}
}

@Article{	  bhunia2013,
  abstract	= {With the increasing disintegration of the design and
		  manufacturing chain of our microelectronic products, we
		  should not only worry about including unintentional,
		  unwanted hardware features
		  ({\&}{\#}x201C;bugs{\&}{\#}x201D;), but also about
		  including intentional malicious hardware features:
		  {\&}{\#}x201C;Trojan Horses,{\&}{\#}x201D;which act as
		  spies or terrorists. This article provides an overview of
		  hardware Trojans and countermeasures.},
  author	= {Bhunia, Swarup and Abramovici, Miron and Agrawal, Dakshi
		  and Hsiao, Michael S. and Plusquellic, Jim and Tehranipoor,
		  Mohammad and Bradley, Paul},
  doi		= {10.1109/MDT.2012.2196252},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Bhunia et al. - Protection against hardware trojan attacks
		  Towards a comprehensive solution.pdf:pdf},
  isbn		= {2168-2356 VO - 30},
  issn		= {21682356},
  journal	= {IEEE Design and Test},
  keywords	= {1,2,a ttacks,h ardware t rojan,hardware security,hardware
		  trojan,ic,in integrated circuit,is an emerging problem,it
		  has become,security,t he p roblem,the issue of trust},
  number	= {3},
  pages		= {6--17},
  title		= {{Protection against hardware trojan attacks: Towards a
		  comprehensive solution}},
  volume	= {30},
  year		= {2013}
}

@Article{	  bhunia2014,
  author	= {Bhunia, Swarup and Hsiao, Michael S. and Banga, Mainak and
		  Narasimhan, Seetharam},
  doi		= {10.1109/JPROC.2014.2334493},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Bhunia et al. - Hardware trojan attacks Threat analysis and
		  countermeasures.pdf:pdf},
  issn		= {00189219},
  journal	= {Proceedings of the IEEE},
  keywords	= {Hardware intellectual property (IP) trust,Trojan
		  detection,Trojan taxonomy,Trojan tolerance,hardware Trojan
		  attacks,hardware obfuscation,self-referencing,side-channel
		  analysis},
  number	= {8},
  pages		= {1229--1247},
  title		= {{Hardware trojan attacks: Threat analysis and
		  countermeasures}},
  volume	= {102},
  year		= {2014}
}

@Article{	  bianchi2012,
  abstract	= {The lucrative rewards of security penetrations into large
		  organi- zations have motivated the development and use of
		  many sophis- ticated rootkit techniques to maintain an
		  attacker’s presence on a compromised system. Due to the
		  evasive nature of such infections, detecting these rootkit
		  infestations is a problem facing modern or- ganizations.
		  While many approaches to this problem have been proposed,
		  various drawbacks that range from signature generation
		  issues, to coverage, to performance, prevent these
		  approaches from being ideal solutions. In this paper, we
		  present Blacksheep, a distributed system for detecting a
		  rootkit infestation among groups of similar machines. This
		  approach was motivated by the homogenous natures of many
		  corporate networks. Taking advantage of the similarity
		  amongst the machines that it analyses, Blacksheep is able
		  to efficiently and effectively detect both existing and new
		  infestations by comparing the memory dumps collected from
		  each host. We evaluate Blacksheep on two sets of memory
		  dumps. One set is taken from virtual machines using virtual
		  machine introspec- tion, mimicking the deployment of
		  Blacksheep on a cloud comput- ing provider’s network. The
		  other set is taken from Windows XP machines via a memory
		  acquisition driver, demonstrating Black- sheep’s usage
		  under more challenging image acquisition condi- tions. The
		  results of the evaluation show that by leveraging the
		  homogeneous nature of groups of computers, it is possible
		  to de- tect rootkit infestations.},
  author	= {Bianchi, Antonio and Shoshitaishvili, Yan and Kruegel,
		  Christopher and Vigna, Giovanni},
  doi		= {10.1145/2382196.2382234},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Bianchi et al. - Blacksheep Detecting Compromised Hosts in
		  Homogeneous Crowds.pdf:pdf},
  isbn		= {9781450316514},
  issn		= {15437221},
  journal	= {ACM conference on Computer and communications security
		  (CCS)},
  keywords	= {computer security,kernel-based rootkits,malicious
		  software,malware detection,rootkit detection},
  pages		= {341},
  title		= {{Blacksheep: Detecting Compromised Hosts in Homogeneous
		  Crowds}},
  url		= {http://dl.acm.org/citation.cfm?id=2382196.2382234},
  year		= {2012}
}

@Article{	  bird1983automatic,
  title		= {Automatic generation of random self-checking test cases},
  author	= {Bird, David L. and Munoz, Carlos Urias},
  journal	= {IBM systems journal},
  volume	= {22},
  number	= {3},
  pages		= {229--245},
  year		= {1983},
  publisher	= {IBM}
}

@InProceedings{	  bisht2008,
  annote	= {Good paper about preventing XSS injection in Java
		  applications.
		  
		  In essence, they run each application twice, once on the
		  real input and once on benign input.
		  
		  They then compare, using the firefox browser parser, the
		  javascript contexts created by each version, real and
		  shadow.
		  
		  If the real input creates additional or modifies javascipt
		  code in the HTML response, then a XSS attack is detected
		  and it's prevented.
		  
		  The one drawback is that they don't handle every browser's
		  quirks and that they won't catch 3rd order XSS.},
  author	= {Bisht, Prithvi and Venkatakrishnan, V.N.},
  booktitle	= {Proceedings of the 5th international conference on
		  Detection of Intrusions and Malware, and Vulnerability
		  Assessment},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Bisht, Venkatakrishnan - XSS-GUARD Precise Dynamic
		  Prevention of Cross-Site Scripting Attacks.pdf:pdf},
  keywords	= {attack prevention,cross-site
		  scripting,filtering,security,xss},
  pages		= {23--43},
  title		= {{XSS-GUARD : Precise Dynamic Prevention of Cross-Site
		  Scripting Attacks}},
  year		= {2008}
}

@InProceedings{	  bisht2010,
  annote	= {White-box analysis of JavaScript and HTML code to drive a
		  black-box analysis of parameter tampering
		  vulnerabilities.},
  author	= {Bisht, Prithvi and Hinrichs, Timothy and Skrupsky, Nazari
		  and Bobrowicz, Radoslaw and Venkatakrishnan, V.N.},
  booktitle	= {Proceedings of the 17th ACM conference on Computer and
		  communications security},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Bisht et al. - NoTamper Automatic Blackbox Detection of
		  Parameter Tampering Opportunities in Web
		  Applications.pdf:pdf},
  pages		= {607--618},
  publisher	= {ACM},
  title		= {{NoTamper: Automatic Blackbox Detection of Parameter
		  Tampering Opportunities in Web Applications}},
  url		= {http://portal.acm.org/citation.cfm?id=1866375},
  year		= {2010}
}

@InProceedings{	  bisht2010,
  annote	= {White-box analysis of JavaScript and HTML code to drive a
		  black-box analysis of parameter tampering
		  vulnerabilities.},
  author	= {Bisht, Prithvi and Hinrichs, Timothy and Skrupsky, Nazari
		  and Bobrowicz, Radoslaw and Venkatakrishnan, V.N.},
  booktitle	= {Proceedings of the 17th ACM conference on Computer and
		  communications security},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Bisht et al. - NoTamper Automatic Blackbox Detection of
		  Parameter Tampering Opportunities in Web
		  Applications.pdf:pdf},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {607--618},
  publisher	= {ACM},
  title		= {{NoTamper: Automatic Blackbox Detection of Parameter
		  Tampering Opportunities in Web Applications}},
  url		= {http://portal.acm.org/citation.cfm?id=1866375},
  year		= {2010}
}

@InProceedings{	  bisht2011,
  address	= {Chicago, IL},
  author	= {Bisht, Prithvi and Hinrichs, Timothy and Skrupsky, Nazari
		  and Venkatakrishnan, V.N.},
  booktitle	= {Proceedings of the 18th ACM Conference on Computer and
		  Communications Security (CCS 2011)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Bisht et al. - WAPTEC Whitebox Analysis of Web Applications
		  for Parameter Tampering Exploit Construction.pdf:pdf},
  isbn		= {9781450309486},
  keywords	= {con-,exploit construction,parameter tampering,program
		  analysis},
  title		= {{WAPTEC : Whitebox Analysis of Web Applications for
		  Parameter Tampering Exploit Construction}},
  year		= {2011}
}

@Article{	  bisht2011a,
  abstract	= {Parameter tampering attacks are dangerous to a web
		  application whose server fails to replicate the validation
		  of user-supplied data that is performed by the client.
		  Malicious users who circumvent the client can capitalize on
		  the missing server validation. In this pa- per, we
		  describeWAPTEC, a tool that is designed to automatically
		  identify parameter tampering vulnerabilities and generate
		  exploits by construction to demonstrate those
		  vulnerabilities. WAPTEC involves a new approach to whitebox
		  analysis of the server’s code. We tested WAPTEC on six
		  open source applications and found previously unknown
		  vulnerabilities in every single one of them. Categories},
  author	= {Bisht, Prithvi and Hinrichs, Timothy},
  doi		= {10.1145/2046707.2046774},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Bisht, Hinrichs - WAPTEC whitebox analysis of web
		  applications for parameter tampering exploit
		  construction.pdf:pdf},
  isbn		= {9781450309486},
  issn		= {15437221},
  journal	= {Proceedings of the 18th {\ldots}},
  keywords	= {con-,exploit construction,parameter tampering,program
		  analysis},
  pages		= {575--586},
  title		= {{WAPTEC: whitebox analysis of web applications for
		  parameter tampering exploit construction}},
  url		= {http://dl.acm.org/citation.cfm?id=2046774},
  year		= {2011}
}

@Article{	  bisht2011a,
  abstract	= {Parameter tampering attacks are dangerous to a web
		  application whose server fails to replicate the validation
		  of user-supplied data that is performed by the client.
		  Malicious users who circumvent the client can capitalize on
		  the missing server validation. In this pa- per, we
		  describeWAPTEC, a tool that is designed to automatically
		  identify parameter tampering vulnerabilities and generate
		  exploits by construction to demonstrate those
		  vulnerabilities. WAPTEC involves a new approach to whitebox
		  analysis of the server’s code. We tested WAPTEC on six
		  open source applications and found previously unknown
		  vulnerabilities in every single one of them. Categories},
  author	= {Bisht, Prithvi and Hinrichs, Timothy},
  doi		= {10.1145/2046707.2046774},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Bisht, Hinrichs - WAPTEC whitebox analysis of web
		  applications for parameter tampering exploit
		  construction.pdf:pdf},
  isbn		= {9781450309486},
  issn		= {15437221},
  journal	= {Proceedings of the 18th {\ldots}},
  keywords	= {con-,exploit construction,parameter tampering,program
		  analysis},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {575--586},
  title		= {{WAPTEC: whitebox analysis of web applications for
		  parameter tampering exploit construction}},
  url		= {http://dl.acm.org/citation.cfm?id=2046774},
  year		= {2011}
}

@Article{	  bletsch2010,
  abstract	= {Return-oriented programming is an effective code-reuse
		  attack in which short code sequences ending in a ret
		  instruction are found within existing binaries and executed
		  in arbitrary order by taking control of the stack. This
		  allows for Turing-complete behavior in the target program
		  without the need for injecting attack code, thus
		  significantly negating current code injection defense
		  efforts (e.g., W⊕X). On the other hand, its inherent
		  characteristics, such as the reliance on the stack and the
		  consecutive execution of return-oriented gadgets, have
		  prompted a variety of defenses to detect or prevent it from
		  happening. In this paper, we introduce a new class of
		  code-reuse attack, called jump-oriented programming. This
		  new attack eliminates the reliance on the stack and ret
		  instructions seen in return-oriented programming without
		  scarifying expressive power. This attack still builds and
		  chains normal functional gadgets, each performing certain
		  primitive operations, except these gadgets end in an
		  indirect branch rather than ret. Without the convenience of
		  using ret to unify them, the attack relies on a dispatcher
		  gadget to dispatch and execute the functional gadgets. We
		  have successfully identified the availability of these
		  jump-oriented gadgets in the GNU libc library. Our
		  experience with an example shellcode attack demonstrates
		  the practicality and effectiveness of this technique.},
  author	= {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Bletsch, Jiang, Freeh - Jump-Oriented Programming A New
		  Class of Code-Reuse Attack.pdf:pdf},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {1--20},
  title		= {{Jump-Oriented Programming: A New Class of Code-Reuse
		  Attack *}},
  year		= {2010}
}

@Article{	  bletsch2011,
  abstract	= {Code-reuse attacks are software exploits in which an
		  attacker directs control flow through existing code with a
		  malicious result. One such technique, return-oriented
		  programming, is based on "gadgets" (short pre-existing
		  sequences of code ending in a ret instruction) being
		  executed in arbitrary order as a result of a stack
		  corruption exploit. Many existing codereuse defenses have
		  relied upon a particular attribute of the attack in
		  question (e.g., the frequency of ret instructions in a
		  return-oriented attack), which leads to an incomplete
		  protection, while a smaller number of efforts in protecting
		  all exploitable control flow transfers suffer from limited
		  deploy-ability due to high performance overhead. In this
		  paper, we present a novel cost-effective defense technique
		  called control flow locking, which allows for effective
		  enforcement of control flow integrity with a small
		  performance overhead. Specifically, instead of immediately
		  determining whether a control flow violation happens before
		  the control flow transfer takes place, control flow locking
		  lazily detects the violation after the transfer. To still
		  restrict attackers' capability, our scheme guarantees that
		  the deviation of the normal control flow graph will only
		  occur at most once. Further, our scheme ensures that this
		  deviation cannot be used to craft a malicious system call,
		  which denies any potential gains an attacker might obtain
		  from what is permitted in the threat model. We have
		  developed a proof-of-concept prototype in Linux and our
		  evaluation demonstrates desirable effectiveness and
		  competitive performance overhead with existing techniques.
		  In several benchmarks, our scheme is able to achieve
		  significant gains.},
  author	= {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince},
  doi		= {10.1145/2076732.2076783},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Bletsch - Mitigating Code-Reuse Attacks with Control-Flow
		  Locking.pdf:pdf},
  isbn		= {9781450306720},
  journal	= {Acsac},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {353},
  title		= {{Mitigating code-reuse attacks with control-flow
		  locking}},
  url		= {http://dl.acm.org/citation.cfm?id=2076732.2076783},
  year		= {2011}
}

@Article{	  bonkoski2013,
  author	= {Bonkoski, Anthony and Bielawski, Russ and Halderman, J
		  Alex},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Bonkoski, Bielawski, Halderman - Illuminating the Security
		  Issues Surrounding Lights-Out Server Management.pdf:pdf},
  journal	= {Presented as part of the 7th USENIX Workshop on Offensive
		  Technologies},
  title		= {{Illuminating the Security Issues Surrounding Lights-Out
		  Server Management}},
  url		= {https://www.usenix.org/conference/woot13/workshop-program/presentation/Bonkoski}
		  ,
  year		= {2013}
}

@Article{	  born2010,
  abstract	= {Current best practices heavily control user permissions on
		  network systems. This effectively mitigates many insider
		  threats regarding the collection and exfiltration of data.
		  Many methods of covert communication involve crafting
		  custom packets, typically requiring both the necessary
		  software and elevated privileges on the system. By
		  exploiting the functionality of a browser, covert channels
		  for data exfiltration may be created without additional
		  software or user privileges. This paper explores novel
		  methods of using a browser's JavaScript engine to
		  exfiltrate documents over the Domain Name System (DNS)
		  protocol without sending less covert Hypertext Transfer
		  Protocol (HTTP) requests.},
  archiveprefix	= {arXiv},
  arxivid	= {1004.4357},
  author	= {Born, Kenton},
  eprint	= {1004.4357},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Born - Browser-Based Covert Data Exfiltration.pdf:pdf},
  title		= {{Browser-Based Covert Data Exfiltration}},
  url		= {http://arxiv.org/abs/1004.4357},
  year		= {2010}
}

@Article{	  boyd-wickizer2010,
  abstract	= {This paper presents SUD, a system for running existing
		  Linux device drivers as untrusted user-space processes.
		  Even if the device driver is controlled by a malicious
		  adversary, it cannot compromise the rest of the system. One
		  significant challenge of fully isolating a driver is to
		  confine the actions of its hardware device. SUD relies on
		  IOMMU hardware, PCI express bridges, and message-signaled
		  interrupts to confine hardware devices. SUD runs unmodified
		  Linux device drivers, by emulating a Linux kernel
		  environment in user-space. A prototype of SUD runs drivers
		  for Gigabit Ethernet, 802.11 wireless, sound cards, USB
		  host controllers, and USB devices, and it is easy to add a
		  new device class. SUD achieves the same performance as an
		  in-kernel driver on networking benchmarks, and can saturate
		  a Gigabit Ethernet link. SUD incurs a CPU overhead
		  comparable to existing run-time driver isolation
		  techniques, while providing much stronger isolation
		  guarantees for untrusted drivers. Finally, SUD requires
		  minimal changes to the kernel—just two kernel modules
		  comprising 4,000 lines of code—which may at last allow
		  the adoption of these ideas in practice.},
  annote	= {1. How to secure the kernel from malicious drivers?
		  
		  2. Isolate each kernel driver in a user-space process,
		  using a kernel emulation.
		  
		  3. Can be applied with minor modifications to Linux, with
		  some overhead.},
  author	= {Boyd-Wickizer, Silas and Zeldovich, Nickolai},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Boyd-Wickizer, Zeldovich - Tolerating malicious device
		  drivers in Linux.pdf:pdf},
  journal	= {Proceedings of the 2010 USENIX Annual Technical
		  Conference},
  title		= {{Tolerating malicious device drivers in Linux}},
  url		= {http://dspace.mit.edu/handle/1721.1/62238},
  year		= {2010}
}

@Article{	  buchanan2008,
  abstract	= {This paper reconsiders the threat posed by Shacham's
		  "return-oriented programming" -- a technique by which
		  W-xor-X-style hardware protections are evaded via carefully
		  crafted stack frames that divert control flow into the
		  middle of existing variable-length x86 instructions --
		  creating short new instructions streams that then return.
		  We believe this attack is both more general and a greater
		  threat than the author appreciated. In fact, the
		  vulnerability is not limited to the x86 architecture or any
		  particular operating system, is readily exploitable, and
		  bypasses an entire category of malware protections. In this
		  paper we demonstrate general return-oriented programming on
		  the SPARC, a fixed instruction length RISC architecture
		  with structured control flow. We construct a
		  Turing-complete library of code gadgets using snippets of
		  the Solaris libc, a general purpose programming language,
		  and a compiler for constructing return-oriented exploits.
		  Finally, we argue that the threat posed by return-oriented
		  programming, across all architectures and systems, has
		  negative implications for an entire class of security
		  mechanisms: those that seek to prevent malicious
		  computation by preventing the execution of malicious
		  code.},
  author	= {Buchanan, Erik and Roemer, Ryan and Shacham, Hovav and
		  Savage, Stefan},
  doi		= {10.1145/1455770.1455776},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Buchanan et al. - When Good Instructions Go Bad
		  Generalizing Return-Oriented Programming to RISC.pdf:pdf},
  isbn		= {9781595938107},
  issn		= {10949224},
  journal	= {CCS '08 Proceedings of the 15th ACM conference on Computer
		  and communications security},
  keywords	= {return-into-libc,return-oriented programming,risc,sparc},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {27--38},
  title		= {{When good instructions go bad: generalizing
		  return-oriented programming to RISC}},
  url		= {http://dl.acm.org/citation.cfm?id=1455776},
  year		= {2008}
}

@Article{	  buchanan2012,
  author	= {Buchanan, Erik and Roemer, Ryan and Savage, Stefan and
		  Shacham, Hovav},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Buchanan et al. - Return-oriented Programming Exploitation
		  without Code Injection Ordinary programming the machine
		  level.pdf:pdf},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Return-oriented Programming : Exploitation without Code
		  Injection Ordinary programming : the machine level}},
  year		= {2012}
}

@Article{	  cao2013,
  author	= {Cao, Yuan and Chang, Chip-Hong and Chen, Shoushun},
  doi		= {10.1109/ISCAS.2013.6572020},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Cao, Chang, Chen - Cluster-based distributed active current
		  timer for hardware Trojan detection.pdf:pdf},
  isbn		= {9781467357609},
  issn		= {02714310},
  journal	= {IEEE Transactions on Information Forensics and Security},
  pages		= {1010--1013},
  title		= {{Cluster-based distributed active current timer for
		  hardware Trojan detection}},
  year		= {2013}
}

@Article{	  capretta2007,
  abstract	= {We describe the formalization of a correctness proof for a
		  conflict detection algorithm for firewalls in the Coq Proof
		  Assistant. First, we give formal definitions in Coq of a
		  firewall access rule and of an access request to a
		  firewall. Formally, two rules are in conflict if there
		  exists a request on which one rule would allow access and
		  the other would deny it. We express our algorithm in Coq,
		  and prove that it finds all conflicts in a set of rules. We
		  obtain an OCaml version of the algorithm by direct program
		  extraction. The extracted program has successfully been
		  applied to firewall specifications with over 200,000
		  rules.},
  author	= {Capretta, Venanzio and Stepien, Bernard and Felty, Amy and
		  Matwin, Stan},
  doi		= {10.1145/1314436.1314440},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Capretta et al. - Formal correctness of conflict detection
		  for firewalls.pdf:pdf},
  isbn		= {9781595938879},
  journal	= {Proceedings of the 2007 ACM Workshop on Formal Methods in
		  Security Engineering},
  pages		= {22--30},
  title		= {{Formal correctness of conflict detection for firewalls}},
  url		= {http://dl.acm.org/citation.cfm?id=1314440$\backslash$nhttp://portal.acm.org/citation.cfm?doid=1314436.1314440}
		  ,
  year		= {2007}
}

@Article{	  carlini2014,
  author	= {Carlini, Nicholas and Wagner, David},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Carlini, Wagner, Carlini - ROP is Still Dangerous Breaking
		  Modern Defenses ROP is Still Dangerous Breaking Modern
		  Defenses.pdf:pdf},
  isbn		= {978-1-931971-15-7},
  journal	= {23rd USENIX Security Symposium (USENIX Security 14)},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {385--399},
  title		= {{ROP is Still Dangerous: Breaking Modern Defenses}},
  url		= {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/carlini}
		  ,
  year		= {2014}
}

@Article{	  carlini2015,
  author	= {Carlini, Nicolas and Barresi, Antonio and Z{\"{u}}rich, E
		  T H and Payer, Mathias and Wagner, David and Gross, Thomas
		  R and Z{\"{u}}rich, E T H and Carlini, Nicolas and Barresi,
		  Antonio and Wagner, David and Gross, Thomas R},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Carlini et al. - Control-Flow Bending On the Effectiveness
		  of Control-Flow Integrity This paper is included in the
		  Proceedings o.pdf:pdf},
  isbn		= {9781931971232},
  journal	= {USENIX Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Control-Flow Bending : On the Effectiveness of
		  Control-Flow Integrity}},
  year		= {2015}
}

@InProceedings{	  chakraborty2008,
  abstract	= {Malevolent Trojan circuits inserted by layout
		  modifications in an IC at untrustworthy fabrication
		  facilities are difficult to detect by traditional
		  post-manufacturing testing. In this paper, we develop a
		  novel low-overhead design methodology that facilitates the
		  detection of inserted Trojan hardware in an IC through
		  logic testing. As a byproduct, it also increases the
		  security of the design by design obfuscation. Application
		  of the proposed design methodology to an 8-bit RISC
		  processor and a JPEG encoder resulted in improvement in
		  Trojan detection probability significantly. It also
		  obfuscated the design with verification mismatch for 90{\%}
		  of the verification points, while incurring moderate area,
		  power and delay overheads.},
  author	= {Chakraborty, Rajat Subhra and Paul, Somnath and Bhunia,
		  Swarup},
  booktitle	= {2008 IEEE International Workshop on Hardware-Oriented
		  Security and Trust, HOST},
  doi		= {10.1109/HST.2008.4559048},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Chakraborty, Paul, Bhunia - On-demand transparency for
		  improving hardware Trojan detectability.pdf:pdf},
  isbn		= {9781424424016},
  keywords	= {Design obfuscation,Hardware Trojan detection,Trust in IC},
  pages		= {48--50},
  title		= {{On-demand transparency for improving hardware Trojan
		  detectability}},
  year		= {2008}
}

@Article{	  chang2008,
  abstract	= {Current taint tracking systems suffer fromhigh overhead
		  and a lack of generality. In this paper, we solve both of
		  these issues with an extensible system that is an order of
		  magnitude more efficient than previous software taint
		  tracking systems and is fully general to dy- namic data
		  flow tracking problems. Our system uses a compiler to
		  transform untrusted programs into policy-enforcing
		  programs, and our system can be easily reconfigured to
		  support new analyses and policies without modifying the
		  compiler or runtime system. Our system uses a sound and
		  sophisticated static analysis that can dramatically reduce
		  the amount of data that must be dynamically tracked. For
		  server programs, our system’s average overhead is
		  0.65{\%} for taint tracking, which is comparable to the
		  best hardware-based solutions. For a set of compute-bound
		  benchmarks, our systempro- duces no runtime overhead
		  because our compiler can prove the ab- sence of
		  vulnerabilities, eliminating the need to dynamically track
		  taint. After modifying these benchmarks to contain format
		  string vulnerabilities, our system’s overhead is less
		  than 13{\%}, which is over 6× lower than the previous best
		  solutions. We demonstrate the flexibility and power of our
		  system by applying it to file dis- closure vulnerabilities,
		  a problem that taint tracking cannot handle. To prevent
		  such vulnerabilities, our system introduces an average
		  runtime overhead of 0.25{\%} for three open source server
		  programs.},
  author	= {Chang, Walter and Streiff, Brandon and Lin, Calvin},
  doi		= {10.1145/1455770.1455778},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Chang, Streiff, Lin - Efficient and extensible security
		  enforcement using dynamic data flow analysis.pdf:pdf},
  isbn		= {9781595938107},
  issn		= {15437221},
  journal	= {Proceedings of the 15th ACM conference on Computer and
		  communications security - CCS '08},
  keywords	= {dynamic data flow analysis,security enforcement,static
		  anal-},
  pages		= {39},
  title		= {{Efficient and extensible security enforcement using
		  dynamic data flow analysis}},
  url		= {http://portal.acm.org/citation.cfm?doid=1455770.1455778},
  year		= {2008}
}

@InProceedings{	  chapman1992,
  author	= {Chapman, D. Brent},
  booktitle	= {Proceedings of the UNIX Security Symposium III},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1992 -
		  Chapman - Network (In)Security through IP Packet
		  Filtering.pdf:pdf},
  pages		= {63--76},
  title		= {{Network (In)Security through IP Packet Filtering}},
  year		= {1992}
}

@InProceedings{	  chaudhuri2010,
  address	= {Chicago, IL},
  author	= {Chaudhuri, Avik and Foster, Jeffrey S},
  booktitle	= {Proceedings of the 17th ACM conference on Computer and
		  communications security (CCS 2010)},
  pages		= {585----594},
  publisher	= {ACM},
  title		= {{Symbolic Security Analysis of Ruby-on-Rails Web
		  Applications}},
  url		= {http://portal.acm.org/citation.cfm?id=1866373},
  year		= {2010}
}

@Article{	  checkoway2010,
  abstract	= {We show that on both the x86 and ARM architectures it is
		  possible to mount return-oriented programming attacks
		  without using return instructions. Our attacks instead make
		  use of certain instruction sequences that behave like a
		  return, which occur with sufficient frequency in large
		  libraries on (x86) Linux and (ARM) Android to allow
		  creation of Turing-complete gadget sets. Because they do
		  not make use of return instructions, our new attacks have
		  negative implications for several recently proposed classes
		  of defense against return-oriented programming: those that
		  detect the too-frequent use of returns in the instruction
		  stream; those that detect violations of the last-in,
		  first-out invariant normally maintained for the
		  return-address stack; and those that modify compilers to
		  produce code that avoids the return instruction.},
  author	= {Checkoway, Stephen and Davi, Lucas and Dmitrienko,
		  Alexandra and a.R. Sadeghi and Shacham, Hovav and Winandy,
		  Marcel},
  doi		= {10.1145/1866307.1866370},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Checkoway et al. - Return-oriented programming without
		  returns.pdf:pdf},
  isbn		= {9781450302456},
  issn		= {15437221},
  journal	= {CCS'10 Proceedings of the 17th ACM conference on Computer
		  and communications security},
  pages		= {559--572},
  title		= {{Return-oriented programming without returns}},
  url		= {http://portal.acm.org/citation.cfm?doid=1866307.1866370$\backslash$nhttp://dl.acm.org/citation.cfm?id=1866370}
		  ,
  year		= {2010}
}

@InProceedings{	  checkoway2011,
  abstract	= {Modern automobiles are pervasively computerized, and hence
		  potentially vulnerable to attack. However, while previous
		  research has shown that the internal networks within some
		  modern cars are insecure, the associated threat model
		  requiring prior physical access has justifiably been viewed
		  as unrealistic. Thus, it remains an open question if
		  automobiles can also be susceptible to remote compromise.
		  Our work seeks to put this question to rest by
		  systematically analyzing the external attack surface of a
		  modern automobile. We discover that remote exploitation is
		  feasible via a broad range of attack vectors (including
		  mechanics tools, CD players, Bluetooth and cellular radio),
		  and further, that wireless communications channels allow
		  long distance vehicle control, location tracking, in-cabin
		  audio exfiltration and theft. Finally, we discuss the
		  structural characteristics of the automotive ecosystem that
		  give rise to such problems and highlight the practical
		  challenges in mitigating them.},
  author	= {Checkoway, Stephen and Mccoy, Damon and Kantor, Brian and
		  Anderson, Danny and Shacham, Hovav and Savage, Stefan and
		  Koscher, Karl and Czeskis, Alexei and Roesner, Franziska
		  and Kohno, Tadayoshi},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Checkoway et al. - Comprehensive Experimental Analyses of
		  Automotive Attack Surfaces.pdf:pdf},
  pages		= {6--6},
  title		= {{Comprehensive Experimental Analyses of Automotive Attack
		  Surfaces}},
  url		= {http://www.usenix.org/events/security/tech/full{\_}papers/Checkoway.pdf}
		  ,
  year		= {2011}
}

@Article{	  chen2008,
  author	= {Chen, Peter M. and Chen, Peter M. and Noble, Brian D. and
		  Noble, Brian D.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Chen et al. - When Virtual Is Better Than Real.pdf:pdf},
  journal	= {HotOS},
  title		= {{When Virtual Is Better Than Real}},
  year		= {2008}
}

@Article{	  chen2008a,
  abstract	= {Commodity operating systems entrusted with securing
		  sensitive data are remarkably large and complex, and
		  consequently, frequently prone to compromise. To address
		  this limitation, we introduce a virtual-machine-based
		  system called Overshadow that protects the privacy and
		  integrity of application data, even in the event of a total
		  OScompromise. Overshadow presents an application with a
		  normal view of its resources, but the OS with an encrypted
		  view. This allows the operating system to carry out the
		  complex task of managing an application's resources,
		  without allowing it to read or modify them. Thus,
		  Overshadow offers a last line of defense for application
		  data. Overshadow builds on multi-shadowing, a novel
		  mechanism that presents different views of "physical"
		  memory, depending on the context performing the access.
		  This primitive offers an additional dimension of protection
		  beyond the hierarchical protection domains implemented by
		  traditional operating systems and processor architectures.
		  We present the design and implementation of Overshadow and
		  show how its new protection semantics can be integrated
		  with existing systems. Our design has been fully
		  implemented and used to protect a wide range of unmodified
		  legacy applications running on an unmodified Linux
		  operating system. We evaluate the performance of our
		  implementation, demonstrating that this approach is
		  practical.},
  author	= {Chen, Xiaoxin and Garfinkel, Tal and Lewis, E Christopher
		  and Subrahmanyam, Pratap and Waldspurger, Carl a and Boneh,
		  Dan and Dwoskin, Jeffrey and Ports, Dan R.K.},
  doi		= {10.1145/1346281.1346284},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Chen et al. - Overshadow a virtualization-based approach to
		  retrofitting protection in commodity operating
		  systems.pdf:pdf},
  isbn		= {9781595939586},
  issn		= {0163-5964},
  journal	= {Proceedings of the 13th international conference on
		  Architectural support for programming languages and
		  operating systems - ASPLOS XIII},
  keywords	= {ating systems,cloaking,hypervisors,memory
		  protection,multi-shadowing,oper-,virtual machine
		  monitors,vmm},
  pages		= {2},
  title		= {{Overshadow: a virtualization-based approach to
		  retrofitting protection in commodity operating systems}},
  url		= {http://portal.acm.org/citation.cfm?id=1346281.1346284{\&}coll=DL{\&}dl=GUIDE{\&}CFID=123200633{\&}CFTOKEN=16581345$\backslash$nhttp://portal.acm.org/citation.cfm?doid=1346281.1346284}
		  ,
  year		= {2008}
}

@InProceedings{	  chen2011,
  annote	= {Overview of linux Kernel Vulnerabilities},
  author	= {Chen, Haogang and Mao, Yandong and Wang, Xi and Zhou, Dong
		  and Kaashoek, M Frans and Zeldovich, Nickolai},
  booktitle	= {Proceedings of the Second Asia-Pacific Workshop on
		  Systems},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Chen et al. - Linux Kernel Vulnerabilities State-of-the-Art
		  Defenses and Open Problems.pdf:pdf},
  title		= {{Linux Kernel Vulnerabilities : State-of-the-Art Defenses
		  and Open Problems}},
  year		= {2011}
}

@Article{	  chen2012,
  abstract	= {Many classic and emerging security attacks usually
		  introduce illegal control flow to victim programs. This
		  paper proposes an approach to detecting violation of
		  control flow integrity based on hardware support for
		  performance monitoring in modern processors. The key
		  observation is that the abnormal control flow in security
		  breaches can be precisely captured by performance
		  monitoring units. Based on this observation, we design and
		  implement a system called CFIMon, which is the first
		  non-intrusive system that can detect and reason about a
		  variety of attacks violating control flow integrity without
		  any changes to applications (either source or binary code)
		  or requiring special-purpose hardware. CFIMon combines
		  static analysis and runtime training to collect legal
		  control flow transfers, and leverages the branch tracing
		  store mechanism in commodity processors to collect and
		  analyze runtime traces on-the-fly to detect violation of
		  control flow integrity. Security evaluation shows that
		  CFIMon has low false positives or false negatives when
		  detecting several realistic security attacks. Performance
		  results show that CFIMon incurs only 6.1{\%} performance
		  overhead on average for a set of typical server
		  applications.},
  author	= {Chen, Haibo and Zang, Binyu},
  doi		= {10.1109/DSN.2012.6263958},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 - Xia
		  et al. - CFIMon Detecting Violation of Control Flow
		  Integrity using Performance Counters.pdf:pdf},
  isbn		= {978-1-4673-1625-5},
  issn		= {1530-0889},
  journal	= {IEEE/IFIP International Conference on Dependable Systems
		  and Networks (DSN 2012)},
  keywords	= {CFIMon,Law,Monitoring,Program processors,Radiation
		  detectors,Runtime,Security,abnormal control flow
		  capture,branch tracing store mechanism,commodity
		  processors,control flow integrity violation
		  detection,hardware support,illegal control flow,legal
		  control flow transfer collection,nonintrusive
		  system,performance counters,performance
		  evaluation,performance monitoring units,runtime traces
		  on-the-fly analysis,runtime traces on-the-fly
		  collection,runtime training,security attacks,security
		  breaches,security of data,server applications,static
		  analysis,victim programs},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {1--12},
  title		= {{CFIMon: Detecting violation of control flow integrity
		  using performance counters}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6263958}
		  ,
  year		= {2012}
}

@Article{	  cheng2013,
  author	= {Cheng, Yueqiang and Ding, Xuhua and Deng, Robert H},
  doi		= {10.1145/2505123},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Cheng, Ding, Deng - DriverGuard Virtualization-Based
		  Fine-Grained Protection on I O Flows.pdf:pdf},
  issn		= {1094-9224},
  journal	= {ACM Transactions on Information and System Security},
  number	= {2},
  title		= {{DriverGuard: Virtualization-Based Fine-Grained Protection
		  on I / O Flows}},
  volume	= {16},
  year		= {2013}
}

@Article{	  cheng2014,
  author	= {Cheng, Yueqiang and Zhou, Zongwei and Yu, Miao and Ding,
		  Xuhua and Deng, Robert H},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Cheng, Deng - ROPecker A Generic and Practical Approach For
		  Defending Against ROP Attack.pdf:pdf},
  isbn		= {1891562355},
  journal	= {Ndss},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  number	= {February},
  pages		= {23--26},
  title		= {{ROPecker : A Generic and Practical Approach for Defending
		  Against ROP Attacks}},
  year		= {2014}
}

@Article{	  cheswick1990,
  author	= {Cheswick, Bill},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1990 -
		  Cheswick - The Design of a Secure Internet
		  Gateway.pdf:pdf},
  journal	= {in Proc. Summer USENIX Conference},
  pages		= {233--237},
  title		= {{The Design of a Secure Internet Gateway}},
  year		= {1990}
}

@Article{	  cheswick1992,
  author	= {Cheswick, Bill},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1992 -
		  Cheswick - An Evening with Berferd in which a cracker is
		  Lured, Endured, and Studied.pdf:pdf},
  journal	= {In Proc. Winter USENIX Conference},
  pages		= {163--174},
  title		= {{An Evening with Berferd in which a cracker is Lured,
		  Endured, and Studied}},
  year		= {1992}
}

@Article{	  chou2001,
  abstract	= {We present a study of operating system errors found by
		  automatic, static, compiler analysis applied to the Linux
		  and OpenBSD kernels. Our approach differs from previous
		  studies that consider errors found by manual inspection of
		  logs, testing, and surveys because static analysis is
		  applied uniformly to the entire kernel source, though our
		  approach necessarily considers a less comprehensive variety
		  of errors than previous studies. In addition, automation
		  allows us to track errors over multiple versions of the
		  kernel source to estimate how long errors remain in the
		  system before they are fixed.We found that device drivers
		  have error rates up to three to seven times higher than the
		  rest of the kernel. We found that the largest quartile of
		  functions have error rates two to six times higher than the
		  smallest quartile. We found that the newest quartile of
		  files have error rates up to twice that of the oldest
		  quartile, which provides evidence that code "hardens" over
		  time. Finally, we found that bugs remain in the Linux
		  kernel an average of 1.8 years before being fixed.},
  author	= {Chou, Andy and Yang, Junfeng and Chelf, Benjamin and
		  Hallem, Seth and Engler, Dawson},
  doi		= {10.1145/502059.502042},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2001 -
		  Chou et al. - An empirical study of operating systems
		  errors.pdf:pdf},
  isbn		= {1581133898},
  issn		= {01635980},
  journal	= {ACM SIGOPS Operating Systems Review},
  number	= {5},
  pages		= {73},
  title		= {{An empirical study of operating systems errors}},
  volume	= {35},
  year		= {2001}
}

@Article{	  christodorescu2009,
  abstract	= {Cloud infrastructure commonly relies on virtualization.
		  Customers provide their own VMs, and the cloud provider
		  runs them often without knowledge of the guest OSes or
		  their configurations. How- ever, cloud customers also want
		  effective and efficient security for their VMs. Cloud
		  providers offering security-as-a-service based on
		  VMintrospection promise the best of bothworlds: efficient
		  central- ization and effective protection. Since customers
		  can move images from one cloud to another, an effective
		  solution requires learning what guest OS runs in eachVMand
		  securing the guest OS without relying on the guest OS
		  functionality or an initially secure guest VM state. We
		  present a solution that is highly scalable in that it (i)
		  central- izes guest protection into a security VM, (ii)
		  supports Linux and Windows operating systems and can be
		  easily extended to support new operating systems, (iii)
		  does not assume any a-priori semantic knowledge of the
		  guest, (iv) does not require any a-priori trust as-
		  sumptions into any state of the guest VM. While other
		  introspection monitoring solutions exist, to our knowledge
		  none of them moni- tor guests on the semantic level
		  required to effectively support both white- and
		  black-listing of kernel functions, or allows to start moni-
		  toring VMs at any state during run-time, resumed from saved
		  state, and cold-boot without the assumptions of a secure
		  start state for monitoring.},
  author	= {Christodorescu, Mihai and Sailer, Reiner and Schales,
		  Douglas Lee and Sgandurra, Daniele and Zamboni, Diego},
  doi		= {10.1145/1655008.1655022},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Christodorescu et al. - Cloud Security Is Not ( Just )
		  Virtualization Security A Short Paper.pdf:pdf},
  isbn		= {9781605587844},
  issn		= {15437221},
  journal	= {Security},
  keywords	= {cloud computing,integrity,outsourcing,virtualization},
  pages		= {97--102},
  title		= {{Cloud Security Is Not ( Just ) Virtualization Security A
		  Short Paper}},
  url		= {http://portal.acm.org/citation.cfm?id=1655022},
  year		= {2009}
}

@Article{	  colp2011,
  abstract	= {Cloud computing uses virtualization to lease small slices
		  of large-scale datacenter facilities to indi- vidual paying
		  customers. These multi-tenant environments, on which
		  numerous large and popular web-based applications run
		  today, are founded on the belief that the virtualization
		  platform is sufficiently secure to prevent breaches of
		  isolation between different userswho are co-located on the
		  same host. Hypervisors are believed to be trustworthy in
		  this role because of their small size and narrow
		  interfaces. We observe that despite the modest footprint of
		  the hypervisor itself, these platforms have a large
		  aggregate trusted computing base (TCB) that includes a
		  monolithic control VM with numerous interfaces exposed to
		  VMs. We present Xoar, a modified version of Xen that
		  retrofits the modularity and isolation principles used in
		  microkernels onto a mature virtualization platform. Xoar
		  breaks the control VM into single-purpose components called
		  service VMs. We show that this componentized abstraction
		  brings a number of benefits: sharing of service components
		  by guests is configurable and auditable, making exposure to
		  risk explicit, and access to the hypervisor is restricted
		  to the least privilege required for each component.
		  Microrebooting components at configurable frequencies
		  reduces the temporal attack surface of individual
		  components. Our approach incurs little performance
		  overhead, and does not require functionality to be
		  sacrificed or components to be rewritten from scratch.},
  author	= {Colp, Patrick and Nanavati, Mihir and Zhu, Jun and Aiello,
		  William and Coker, George and Deegan, Tim and Loscocco,
		  Peter and Warfield, Andrew},
  doi		= {10.1145/2043556.2043575},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Colp et al. - Breaking Up is Hard to Do Security and
		  Functionality in a Commodity Hypervisor.pdf:pdf},
  isbn		= {9781450309776},
  journal	= {SOSP},
  number	= {1},
  pages		= {189--202},
  title		= {{Breaking Up is Hard to Do: Security and Functionality in
		  a Commodity Hypervisor}},
  url		= {http://dl.acm.org/citation.cfm?id=2043575},
  volume	= {24},
  year		= {2011}
}

@Article{	  costa2005,
  author	= {Costa, Manuel and Crowcroft, Jon and Castro, Miguel and
		  Rowstron, Antony and Zhou, Lidong and Zhang, Lintao and
		  Barham, Paul},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Costa et al. - Vigilante End-to-End Containment of Internet
		  Worms.pdf:pdf},
  isbn		= {1595930795},
  keywords	= {all or part of,control flow analy-,data flow analysis,or
		  hard copies of,permission to make digital,self-certifying
		  alerts,sis,this work for,worm containment},
  title		= {{Vigilante : End-to-End Containment of Internet Worms}},
  year		= {2005}
}

@Article{	  costin2014,
  author	= {Costin, Andrei and Zaddach, Jonas and Francillon,
		  Aur{\'{e}}lien and Balzarotti, Davide},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Costin et al. - A Large-Scale Analysis of the Security of
		  Embedded Firmwares.pdf:pdf},
  isbn		= {9781931971157},
  journal	= {USENIX Security 2014},
  title		= {{A Large-Scale Analysis of the Security of Embedded
		  Firmwares}},
  year		= {2014}
}

@InProceedings{	  cousot1977abstract,
  title		= {Abstract interpretation: a unified lattice model for
		  static analysis of programs by construction or
		  approximation of fixpoints},
  author	= {Cousot, Patrick and Cousot, Radhia},
  booktitle	= {Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on
		  Principles of programming languages},
  pages		= {238--252},
  year		= {1977},
  organization	= {ACM}
}

@InProceedings{	  cova2007,
  abstract	= {Abstract. In recent years, web applications have become
		  tremendously popular, and nowadays they are routinely used
		  in security-critical envi- ronments, such as medical,
		  financial, and military systems. As the use of web
		  applications},
  annote	= {Used anomaly models to detect state-violation attacks.
		  They build a profile of the application by analyzing the
		  relationship of the state variables in each basic block, by
		  modifying the PHP interpreter.
		  
		  Then, after the profile is built, they use it as a guide to
		  detect anomalous behavor.
		  
		  The main problem is false positives due to the lack of
		  coverage of exercising the application. Which is typical of
		  a dynamic approach.
		  
		  They found an EAR!},
  author	= {Cova, Marco and Balzarotti, Davide and Felmetsger,
		  Viktoria and Vigna, Giovanni},
  booktitle	= {Proceedings of the 10th international conference on Recent
		  advances in intrusion detection},
  doi		= {10.1007/978-3-540-74320-0{\_}4},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop//2007 -
		  Cova et al. - Swaddler An Approach for the Anomaly-based
		  Detection of State Violations in Web Applications.pdf:pdf},
  pages		= {1--20},
  publisher	= {Springer},
  series	= {LNCS},
  title		= {{Swaddler: An Approach for the Anomaly-based Detection of
		  State Violations in Web Applications}},
  url		= {http://www.springerlink.com/index/81m572n620gu2j08.pdf},
  volume	= {4637},
  year		= {2007}
}

@InProceedings{	  cova2007,
  abstract	= {Abstract. In recent years, web applications have become
		  tremendously popular, and nowadays they are routinely used
		  in security-critical envi- ronments, such as medical,
		  financial, and military systems. As the use of web
		  applications},
  annote	= {Used anomaly models to detect state-violation attacks.
		  They build a profile of the application by analyzing the
		  relationship of the state variables in each basic block, by
		  modifying the PHP interpreter.
		  
		  Then, after the profile is built, they use it as a guide to
		  detect anomalous behavor.
		  
		  The main problem is false positives due to the lack of
		  coverage of exercising the application. Which is typical of
		  a dynamic approach.
		  
		  They found an EAR!},
  author	= {Cova, Marco and Balzarotti, Davide and Felmetsger,
		  Viktoria and Vigna, Giovanni},
  booktitle	= {Proceedings of the 10th international conference on Recent
		  advances in intrusion detection},
  doi		= {10.1007/978-3-540-74320-0{\_}4},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop//2007 -
		  Cova et al. - Swaddler An Approach for the Anomaly-based
		  Detection of State Violations in Web Applications.pdf:pdf},
  pages		= {1--20},
  publisher	= {Springer},
  series	= {LNCS},
  title		= {{Swaddler: An Approach for the Anomaly-based Detection of
		  State Violations in Web Applications}},
  url		= {http://www.springerlink.com/index/81m572n620gu2j08.pdf},
  volume	= {4637},
  year		= {2007}
}

@InProceedings{	  cova2007,
  abstract	= {Abstract. In recent years, web applications have become
		  tremendously popular, and nowadays they are routinely used
		  in security-critical envi- ronments, such as medical,
		  financial, and military systems. As the use of web
		  applications},
  annote	= {Used anomaly models to detect state-violation attacks.
		  They build a profile of the application by analyzing the
		  relationship of the state variables in each basic block, by
		  modifying the PHP interpreter.
		  
		  Then, after the profile is built, they use it as a guide to
		  detect anomalous behavor.
		  
		  The main problem is false positives due to the lack of
		  coverage of exercising the application. Which is typical of
		  a dynamic approach.
		  
		  They found an EAR!},
  author	= {Cova, Marco and Balzarotti, Davide and Felmetsger,
		  Viktoria and Vigna, Giovanni},
  booktitle	= {Proceedings of the 10th international conference on Recent
		  advances in intrusion detection},
  doi		= {10.1007/978-3-540-74320-0{\_}4},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop//2007 -
		  Cova et al. - Swaddler An Approach for the Anomaly-based
		  Detection of State Violations in Web Applications.pdf:pdf},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {1--20},
  publisher	= {Springer},
  series	= {LNCS},
  title		= {{Swaddler: An Approach for the Anomaly-based Detection of
		  State Violations in Web Applications}},
  url		= {http://www.springerlink.com/index/81m572n620gu2j08.pdf},
  volume	= {4637},
  year		= {2007}
}

@Article{	  cui2010,
  abstract	= {We present a quantitative lower bound on the number of
		  vulnerable embedded device on a global scale. Over the past
		  year, we have systematically scanned large portions of the
		  internet to monitor the presence of trivially vulnerable
		  embedded devices. At the time of writing, we have
		  identified over 540,000 publicly accessible embedded
		  devices configured with factory default root passwords.
		  This constitutes over 13{\%} of all discovered embedded
		  devices. These devices range from enterprise equipment such
		  as firewalls and routers to consumer appliances such as
		  VoIP adapters, cable and IPTV boxes to office equipment
		  such as network printers and video conferencing units.
		  Vulnerable devices were detected in 144 countries, across
		  17,427 unique private enterprise, ISP, government,
		  educational, satellite provider as well as residential
		  network environments. Preliminary results from our
		  longitudinal study tracking over 102,000 vulnerable devices
		  revealed that over 96{\%} of such accessible devices remain
		  vulnerable after a 4-month period. We believe the data
		  presented in this paper provides a conservative lower bound
		  on the actual population of vulnerable devices in the wild.
		  By combining the observed vulnerability distributions and
		  its potential root causes, we propose a set of mitigation
		  strategies and hypothesize about its quantitative impact on
		  reducing the global vulnerable embedded device population.
		  Employing our strategy, we have partnered with Team Cymru
		  to engage key organizations capable of significantly
		  reducing the number of trivially vulnerable embedded
		  devices currently on the internet. As an ongoing
		  longitudinal study, we plan to gather data continuously
		  over the next year in order to quantify the effectiveness
		  of community's cumulative effort to mitigate this pervasive
		  threat. © 2010 ACM.},
  author	= {Cui, A and Stolfo, S J},
  doi		= {http://doi.acm.org/10.1145/1920261.1920276},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Cui, Stolfo - A quantitative analysis of the insecurity of
		  embedded network devices Results of a wide-area
		  scan.pdf:pdf},
  isbn		= {9781450301336},
  issn		= {10639527},
  journal	= {Proceedings of the Annual Computer Security Applications
		  Conference (ACSAC)},
  pages		= {97--106},
  title		= {{A quantitative analysis of the insecurity of embedded
		  network devices: Results of a wide-area scan}},
  url		= {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751540482{\&}partnerID=40{\&}md5=759904ebe0eca35e4297072f7224cf55}
		  ,
  year		= {2010}
}

@InProceedings{	  cui2010a,
  author	= {Cui, Ang and Kataria, Jatin and Stofo, Salvatore J},
  booktitle	= {Proceedings of the Annual Computer Security Applications
		  Conference (ACSAC)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Cui, Kataria, Stofo - From Prey To Hunter Transforming
		  Legacy Embedded Devices Into Exploitation Sensor
		  Grids.pdf:pdf},
  isbn		= {9781450301336},
  title		= {{From Prey To Hunter: Transforming Legacy Embedded Devices
		  Into Exploitation Sensor Grids}},
  year		= {2010}
}

@Article{	  cui2011,
  abstract	= {A large number of embedded devices on the internet, such
		  as routers and VOIP phones, are typically ripe for
		  exploitation. Little to no defensive technology, such as AV
		  scanners or IDS’s, are available to protect these
		  devices.We propose a host-based defense mechanism, which we
		  call Symbiotic Embedded Machines (SEM), that is
		  specifically designed to inject intrusion detection
		  functionality into the firmware of the device. A SEM or
		  simply the Symbiote, may be injected into deployed legacy
		  embedded systems with no disruption to the operation of the
		  device. A Symbiote is a code structure embedded in situ
		  into the firmware of an embedded system. The Symbiote can
		  tightly co-exist with arbitrary host executables in a
		  mutually defensive arrangement, sharing computational
		  resources with its host while simultaneously protecting the
		  host against exploitation and unauthorized modification.
		  The Symbiote is stealthily embedded in a randomized fashion
		  within an arbitrary body of firmware to protect itself from
		  removal. We demonstrate the operation of a generic
		  whitelist-based rootkit detector Symbiote injected in situ
		  into Cisco IOS with negligible performance penalty and
		  without impacting the routers functionality. We present the
		  performance overhead of a Symbiote on physical Cisco router
		  hardware. A MIPS implementation of the Symbiote was ported
		  to ARM and injected into a Linux 2.4 kernel, allowing the
		  Symbiote to operate within Android and other mobile
		  computing devices. The use of Symbiotes represents a
		  practical and effective protection mechanism for a wide
		  range of devices, especially widely deployed, unprotected,
		  legacy embedded devices.},
  author	= {Cui, Ang and Stolfo, Salvatore J.},
  doi		= {10.1007/978-3-642-23644-0{\_}19},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Cui, Stolfo - Defending embedded systems with software
		  symbiotes.pdf:pdf},
  isbn		= {9783642236433},
  issn		= {03029743},
  journal	= {Proceedings of the Symposium on Recent Advances in
		  Intrusion Detection (RAID)},
  keywords	= {Cisco IOS Rootkit Detection,Embedded Device
		  Defense,Symbiotic EmbeddedMachines},
  pages		= {358--377},
  title		= {{Defending embedded systems with software symbiotes}},
  volume	= {6961 LNCS},
  year		= {2011}
}

@InProceedings{	  cui2013,
  abstract	= {The ability to update firmware is a feature that is found
		  in nearly all modern embedded systems. We demonstrate how
		  this feature can be exploited to allow attackers to inject
		  ma- licious firmware modifications into vulnerable embedded
		  devices. We discuss techniques for exploiting such
		  vulnerable functionality and the implementation of a proof
		  of concept printer malware capable of network
		  reconnaissance, data exfiltration and propa- gation to
		  general purpose computers and other embedded device
		  types.We present a case study of the HP-RFU (Remote
		  Firmware Update) LaserJet printer firmware modification
		  vulnerability, which allows arbitrary injection of malware
		  into the printers firmware via standard printed documents.
		  We show vulnerable population data gathered by continuously
		  tracking all publicly accessible printers discovered
		  through an exhaustive scan of IPv4 space. To show that
		  firmware update signing is not the panacea of embedded
		  defense, we present an analysis of known vulnerabilities
		  found in third-party libraries in 373 LaserJet firmware
		  images. Prior research has shown that the design flaws and
		  vulnerabilities presented in this paper are found in other
		  modern embedded systems. Thus, the exploitation techniques
		  presented in this paper can be generalized to compromise
		  other embedded systems.},
  author	= {Cui, Ang and Costello, Michael and Stolfo, Salvatore J},
  booktitle	= {20th Annual Network Distributed System Security
		  Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Cui, Costello, Stolfo - When Firmware Modifications Attack
		  A Case Study of Embedded Exploitation.pdf:pdf},
  keywords	= {embedded system exploitation,embedded system
		  rootkit,firmware modifica,hp rfu
		  vulnerability,networks,security our existing,tion attack,we
		  present following},
  title		= {{When Firmware Modifications Attack : A Case Study of
		  Embedded Exploitation}},
  url		= {http://ids.cs.columbia.edu/sites/default/files/ndss-2013.pdf}
		  ,
  year		= {2013}
}

@Article{	  cuppens2002,
  abstract	= { This paper presents the work we have done within the
		  MIRADOR project to design CRIM, a cooperative module for
		  intrusion detection systems (IDS). This module implements
		  functions to manage, cluster, merge and correlate alerts.
		  The clustering and merging functions recognize alerts that
		  correspond to the same occurrence of an attack and create a
		  new alert that merge data contained in these various
		  alerts. Experiments show that these functions significantly
		  reduce the number of alerts. However, we also observe that
		  alerts we obtain are still too elementary to be managed by
		  a security administrator. The purpose of the correlation
		  function is thus to generate global and synthetic alerts.
		  This paper focuses on the approach we suggest to design
		  this function.},
  author	= {Cuppens, F. and Miege, a.},
  doi		= {10.1109/SECPRI.2002.1004372},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2002 -
		  Cuppens, Miege - Alert correlation in a cooperative
		  intrusion detection framework.pdf:pdf},
  isbn		= {0-7695-1543-6},
  issn		= {1081-6011},
  journal	= {Proceedings 2002 IEEE Symposium on Security and Privacy},
  keywords	= {alert correlation,alert merging,cooperative intrusion
		  detection,idmef},
  pmid		= {19188930},
  title		= {{Alert correlation in a cooperative intrusion detection
		  framework}},
  year		= {2002}
}

@InProceedings{	  dalton09:nemesis,
  address	= {Berkeley, CA, USA},
  annote	= {This paper keeps track of which users are logged in and
		  authenticated, using a shadow cookie.
		  
		  They use this information to dynamically, at run-time,
		  protect php applications from authentication and access
		  control vulnerabilities.},
  author	= {Dalton, Michael and Kozyrakis, Christos and Zeldovich,
		  Nickolai},
  booktitle	= {Proceedings of the 18th conference on USENIX security
		  symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Dalton, Kozyrakis, Zeldovich - Nemesis Preventing
		  Authentication {\&} Access Control Vulnerabilities in Web
		  Applications.pdf:pdf},
  pages		= {267--282},
  publisher	= {USENIX Association},
  series	= {SSYM'09},
  title		= {{Nemesis: Preventing Authentication {\&} Access Control
		  Vulnerabilities in Web Applications}},
  url		= {http://dl.acm.org/citation.cfm?id=1855768.1855785},
  year		= {2009}
}

@InProceedings{	  dalton09:nemesis,
  address	= {Berkeley, CA, USA},
  annote	= {This paper keeps track of which users are logged in and
		  authenticated, using a shadow cookie.
		  
		  They use this information to dynamically, at run-time,
		  protect php applications from authentication and access
		  control vulnerabilities.},
  author	= {Dalton, Michael and Kozyrakis, Christos and Zeldovich,
		  Nickolai},
  booktitle	= {Proceedings of the 18th conference on USENIX security
		  symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Dalton, Kozyrakis, Zeldovich - Nemesis Preventing
		  Authentication {\&} Access Control Vulnerabilities in Web
		  Applications.pdf:pdf},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {267--282},
  publisher	= {USENIX Association},
  series	= {SSYM'09},
  title		= {{Nemesis: Preventing Authentication {\&} Access Control
		  Vulnerabilities in Web Applications}},
  url		= {http://dl.acm.org/citation.cfm?id=1855768.1855785},
  year		= {2009}
}

@Article{	  dalton2008,
  abstract	= {Despite having been around for more than 25 years, buffer
		  overflowattacks are still a major security threat for
		  deployed software. Existing techniques for buffer over-
		  flow detection provide partial protection at best as they
		  detect limited cases, suffer from many false positives, re-
		  quire source code access, or introduce large performance
		  overheads. Moreover, none of these techniques are easily
		  applicable to the operating system kernel. This paper
		  presents a practical security environment for buffer
		  overflow detection in userspace and kernelspace code. Our
		  techniques build upon dynamic information flow tracking
		  (DIFT) and prevent the attacker from overwriting pointers
		  in the application or operating system. Unlike previous
		  work, our technique does not have false positives on
		  unmodified binaries, protects both data and control
		  pointers, and allows for practical hardware support.
		  Moreover, it is applicable to the kernel and provides
		  robust detection of buffer overflows and user/kernel
		  pointer dereferences. Using a full system prototype of a
		  Linux workstation (hardware and software), we demonstrate
		  our security approach in practice and discuss the major
		  challenges for robust buffer overflow protection in
		  real-world software.},
  author	= {Dalton, Michael and Kannan, Hari and Kozyrakis, Christos},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Dalton, Kannan, Kozyrakis - Real-World Buffer Overflow
		  Protection for Userspace {\&} Kernelspace.pdf:pdf},
  journal	= {Proceedings of the USENIX Security Symposium},
  pages		= {395--410},
  title		= {{Real-World Buffer Overflow Protection for Userspace {\&}
		  Kernelspace}},
  year		= {2008}
}

@Article{	  davi2009,
  abstract	= {Despite the many efforts made in recent years to mitigate
		  runtime attacks such as stack and heap based buffer
		  overflows, these attacks are still a common security
		  concern in today's computing platforms. Attackers have even
		  found new ways to enforce runtime attacks including use of
		  a technique called return-oriented programming. Trusted
		  Computing provides mechanisms to verify the integrity of
		  all executable content in an operating system. But they
		  only provide integrity at load-time and are not able to
		  prevent or detect runtime attacks. To mitigate
		  return-oriented programming attacks, we propose new runtime
		  integrity monitoring techniques that use tracking
		  instrumentation of program binaries based on taint analysis
		  and dynamic tracing. We also describe how these techniques
		  can be employed in a dynamic integrity measurement
		  architecture (DynIMA). In this way we fill the gap between
		  static load-time and dynamic runtime attestation and, in
		  particular, extend trusted computing techniques to
		  effectively defend against return-oriented programming
		  attacks. Copyright 2009 ACM.},
  author	= {Davi, L and a.-R. Sadeghi and Winandy, M},
  doi		= {10.1145/1655108.1655117},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Davi, Sadeghi, Winandy - Dynamic Integrity Measurement and
		  Attestation Towards Defense Against Return-Oriented
		  Programming Attac.pdf:pdf},
  isbn		= {9781605587882},
  issn		= {15437221},
  journal	= {Proceedings of the ACM Conference on Computer and
		  Communications Security},
  keywords	= {attesta-,integrity monitoring,return-oriented
		  programming},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {49--54},
  title		= {{Dynamic integrity measurement and attestation: Towards
		  defense against return-oriented programming attacks}},
  url		= {http://www.scopus.com/inward/record.url?eid=2-s2.0-74049136385{\&}partnerID=40{\&}md5=5100af46d8e7565dfc8906e437dd2d2c}
		  ,
  year		= {2009}
}

@Article{	  davi2011,
  abstract	= {Modern runtime attacks increasingly make use of the
		  powerful return-oriented programming (ROP) attack
		  techniques and principles such as recent attacks on Apple
		  iPhone and Acrobat products to name some. These attacks
		  even work under the presence of modern memory protection
		  mechanisms such as data execution prevention (DEP). In this
		  paper, we present our tool, ROPdefender, that dynamically
		  detects conventional ROP attacks (that are based on return
		  instructions). In contrast to existing solutions,
		  ROPdefender can be immediately deployed by end-users, since
		  it does not rely on side information (e.g., source code or
		  debugging information) which are rarely provided in
		  practice. Currently, our tool adds a runtime overhead of 2x
		  which is comparable to similar instrumentation-based
		  tools.},
  author	= {Davi, Lucas and Sadeghi, Ar and Winandy, Marcel},
  doi		= {10.1145/1966913.1966920},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Davi, Sadeghi, Winandy - ROPdefender A Detection Tool to
		  Defend Against Return-Oriented Programming
		  Attacks.pdf:pdf},
  isbn		= {9781450305648},
  journal	= {Asiaccs},
  keywords	= {binary instrumen-,detection,return-oriented programming},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {1--22},
  title		= {{ROPdefender: A detection tool to defend against
		  return-oriented programming attacks}},
  url		= {http://dl.acm.org/citation.cfm?id=1966920},
  year		= {2011}
}

@Article{	  davi2012,
  abstract	= {Runtime and control-flow attacks (such as code injection
		  or return-oriented programming) constitute one of the most
		  severe threats to software programs. These attacks are
		  prevalent and have been recently applied to smartphone
		  applications as well, of which hundreds of thousands are
		  downloaded by users every day. While a framework for
		  control-flow integrity (CFI) enforcement, an approach to
		  prohibit this kind of attacks, exists for the Intel x86
		  platform, there is no such a solution for smartphones. In
		  this paper, we present a novel framework, MoCFI (Mobile
		  CFI), that provides a general countermeasure against
		  control-flow attacks on smartphone platforms by enforcing
		  CFI. We show that CFI on typical smartphone platforms
		  powered by an ARM processor is technically involved due to
		  architectural differences between ARMand Intel x86, as well
		  as the specifics of smartphone OSes. Our framework performs
		  CFI on-the-fly during runtime without requiring the
		  application’s source code. For our reference
		  implementation we chose Apple’s iOS, because it has been
		  an attractive target for control-flow attacks.
		  Nevertheless, our framework is also applicable to other
		  ARM-based devices such as Google’s Android. Our
		  performance evaluation demonstrates that MoCFI is efficient
		  and does not induce notable overhead when applied to
		  popular iOS applications.},
  author	= {Davi, Lucas and Dmitrienko, Alexandra and Egele, Manuel
		  and Thomas, Fischer and Holz, Thorsten and Hund, Ralf and
		  Nurnberger, Stefan and Sadeghi, Ahmad-Reza},
  doi		= {10.1.1.232.4165},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Davi et al. - MoCFI A Framework to Mitigate Control-Flow
		  Attacks on Smartphones.pdf:pdf},
  journal	= {NDSS 2012 (19th Network and Distributed System Security
		  Symposium)},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{MoCFI: A framework to mitigate control-flow attacks on
		  smartphones}},
  url		= {http://www.researchgate.net/publication/228517736{\_}MoCFI{\_}A{\_}Framework{\_}to{\_}Mitigate{\_}Control-Flow{\_}Attacks{\_}on{\_}Smartphones/file/79e4150814635b1821.pdf}
		  ,
  year		= {2012}
}

@Article{	  davi2014,
  author	= {Davi, Lucas and Sadeghi, Ahmad-Reza and Lehmann, Daniel
		  and Monrose, Fabian},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Davi et al. - Stitching the Gadgets On the Ineffectiveness
		  of Coarse-Grained Control-Flow Integrity Protection
		  Stitching the Gad.pdf:pdf},
  isbn		= {9781931971157},
  journal	= {USENIX Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Stitching the gadgets: On the ineffectiveness of
		  coarse-grained control-flow integrity protection}},
  url		= {https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-davi.pdf}
		  ,
  year		= {2014}
}

@Article{	  davidson2013,
  author	= {Davidson, Drew and Ristenpart, Thomas and Madison,
		  Wisconsin},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Davidson, Ristenpart, Madison - FIE on Firmware Finding
		  Vulnerabilities in Embedded Systems using Symbolic
		  Execution.pdf:pdf},
  isbn		= {978-1-931971-03-4},
  journal	= {USENIX Security 2013},
  title		= {{FIE on Firmware : Finding Vulnerabilities in Embedded
		  Systems using Symbolic Execution}},
  year		= {2013}
}

@Article{	  davoodi2013,
  author	= {Davoodi, Azadeh and Li, Min and Tehranipoor, Mohammad},
  doi		= {10.1109/MDAT.2013.2255913},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Davoodi, Li, Tehranipoor - A Sensor-Assisted
		  Self-Authentication Framework for Hardware Trojan
		  Detection.pdf:pdf},
  isbn		= {9783981080186},
  issn		= {2168-2356},
  journal	= {IEEE Design {\&} Test},
  number	= {5},
  pages		= {74--82},
  title		= {{A Sensor-Assisted Self-Authentication Framework for
		  Hardware Trojan Detection}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6490338}
		  ,
  volume	= {30},
  year		= {2013}
}

@Article{	  dhamija2006,
  abstract	= {To build systems shielding users from fraudulent (or
		  phishing) websites, designers need to know which attack
		  strategies work and why. This paper provides the first
		  empirical evidence about which malicious strategies are
		  successful at deceiving general users. We first analyzed a
		  large set of captured phishing attacks and developed a set
		  of hypotheses about why these strategies might work. We
		  then assessed these hypotheses with a usability study in
		  which 22 participants were shown 20 web sites and asked to
		  determine which ones were fraudulent. We found that 23{\%}
		  of the participants did not look at browser-based cues such
		  as the address bar, status bar and the security indicators,
		  leading to incorrect choices 40{\%} of the time. We also
		  found that some visual deception attacks can fool even the
		  most sophisticated users. These results illustrate that
		  standard security indicators are not effective for a
		  substantial fraction of users, and suggest that alternative
		  approaches are needed.},
  author	= {Dhamija, Rachna and Tygar, J D and Hearst, M.},
  doi		= {10.1145/1124772.1124861},
  file		= {::},
  isbn		= {1595931783},
  journal	= {CHI 2006 Proceedings},
  number	= {November 2005},
  pages		= {581--590},
  title		= {{Why Phishing Works}},
  year		= {2006}
}

@InProceedings{	  dharmapurikar2003,
  author	= {Dharmapurikar, Sarang and Krishnamurthy, Praveen and
		  Sproull, Todd and Lockwood, John and Drive, One Brookings
		  and Louis, Saint},
  booktitle	= {IEEE Symposium on High performance interconnects},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Dharmapurikar et al. - Deep Packet Inspection using
		  Parallel Bloom Filters.pdf:pdf},
  isbn		= {076952012X},
  title		= {{Deep Packet Inspection using Parallel Bloom Filters}},
  year		= {2003}
}

@Article{	  douceur2008,
  abstract	= {Xax is a browser plugin model that enables developers to
		  leverage existing tools, libraries, and entire programs to
		  deliver feature-rich applications on the web. Xax employs a
		  novel combination of mechanisms that collectively provide
		  security, OS-independence, performance, and support for
		  legacy code. These mechanisms include memory-isolated
		  native code execution behind a narrow syscall interface, an
		  abstraction layer that provides a consistent binary
		  interface across operating systems, system services via
		  hooks to existing browser mechanisms, and lightweight
		  modifications to existing tool chains and code bases. We
		  demonstrate a variety of applications and libraries from
		  existing code bases, in several languages, produced with
		  various tool chains, running in multiple browsers on
		  multiple operating systems. With roughly two person-weeks
		  of effort, we ported 3.3 million lines of code to Xax,
		  including a PDF viewer, a Python interpreter, a speech
		  synthesizer, and an OpenGL pipeline.},
  author	= {Douceur, J and Elson, Jeremy and Howell, Jon and Lorch,
		  Jacob R.},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/Leveraging
		  Legacy Code to Deploy Desktop Applications on the
		  Web.pdf:pdf},
  journal	= {OSDI'08 Proceedings of the 8th USENIX conference on
		  Operating systems design and implementation},
  pages		= {339--354},
  title		= {{Leveraging Legacy Code to Deploy Desktop Applications on
		  the Web}},
  url		= {http://research.microsoft.com/pubs/72878/xax-osdi08.pdf},
  year		= {2008}
}

@InProceedings{	  doupe2011,
  abstract	= {The complexity of modern web applications makes it
		  diffi-cult for developers to fully understand the security
		  implica-tions of their code. Attackers exploit the
		  resulting security vulnerabilities to gain unauthorized
		  access to the web appli-cation environment. Previous
		  research into web application vulnerabilities has mostly
		  focused on input validation flaws, such as cross-site
		  scripting and SQL injection, while logic flaws have
		  received comparably less attention. In this paper, we
		  present a comprehensive study of a rela-tively unknown
		  logic flaw in web applications, which we call Execution
		  After Redirect, or EAR. A web application de-veloper can
		  introduce an EAR by calling a redirect method under the
		  assumption that execution will halt. A vulnera-bility
		  occurs when server-side execution continues after the
		  developers intended halting point, which can lead to
		  bro-ken/insufficient access controls and information
		  leakage. We start with an analysis of howsusceptible
		  applications written in nine web frameworks are to EAR
		  vulnerabilities. We then discuss the results from the EAR
		  challenge contained within the 2010 International Capture
		  the Flag Competition. Fi-nally, we present an open-source,
		  white-box, static analysis tool to detect EARs in Ruby on
		  Rails web applications. This tool found 3,944 EAR instances
		  in 18,127 open-source appli-cations. Finally, we describe
		  an approach to prevent EARs in web frameworks.},
  author	= {Doup{\'{e}}, Adam and Boe, Bryce and Kruegel, Christopher
		  and Vigna, Giovanni},
  booktitle	= {Computer and Communications Security (CCS)},
  doi		= {10.1145/2046707.2046736},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop//2011 -
		  Doup{\'{e}} et al. - Fear the EAR Discovering and
		  Mitigating Execution After Redirect
		  Vulnerabilities.pdf:pdf},
  isbn		= {9781450309486},
  keywords	= {all part,execution after redirect,granted without fee,hard
		  copies,permission make digital,personal classroom
		  use,provided copies,static analysis,web applications,work},
  pages		= {251--261},
  publisher	= {ACM Press},
  series	= {CCS '11},
  title		= {{Fear the EAR : Discovering and Mitigating Execution After
		  Redirect Vulnerabilities}},
  url		= {http://dl.acm.org/citation.cfm?id=2046707.2046736},
  year		= {2011}
}

@InProceedings{	  doupe2011,
  abstract	= {The complexity of modern web applications makes it
		  diffi-cult for developers to fully understand the security
		  implica-tions of their code. Attackers exploit the
		  resulting security vulnerabilities to gain unauthorized
		  access to the web appli-cation environment. Previous
		  research into web application vulnerabilities has mostly
		  focused on input validation flaws, such as cross-site
		  scripting and SQL injection, while logic flaws have
		  received comparably less attention. In this paper, we
		  present a comprehensive study of a rela-tively unknown
		  logic flaw in web applications, which we call Execution
		  After Redirect, or EAR. A web application de-veloper can
		  introduce an EAR by calling a redirect method under the
		  assumption that execution will halt. A vulnera-bility
		  occurs when server-side execution continues after the
		  developers intended halting point, which can lead to
		  bro-ken/insufficient access controls and information
		  leakage. We start with an analysis of howsusceptible
		  applications written in nine web frameworks are to EAR
		  vulnerabilities. We then discuss the results from the EAR
		  challenge contained within the 2010 International Capture
		  the Flag Competition. Fi-nally, we present an open-source,
		  white-box, static analysis tool to detect EARs in Ruby on
		  Rails web applications. This tool found 3,944 EAR instances
		  in 18,127 open-source appli-cations. Finally, we describe
		  an approach to prevent EARs in web frameworks.},
  author	= {Doup{\'{e}}, Adam and Boe, Bryce and Kruegel, Christopher
		  and Vigna, Giovanni},
  booktitle	= {Computer and Communications Security (CCS)},
  doi		= {10.1145/2046707.2046736},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop//2011 -
		  Doup{\'{e}} et al. - Fear the EAR Discovering and
		  Mitigating Execution After Redirect
		  Vulnerabilities.pdf:pdf},
  isbn		= {9781450309486},
  keywords	= {all part,execution after redirect,granted without fee,hard
		  copies,permission make digital,personal classroom
		  use,provided copies,static analysis,web applications,work},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {251--261},
  publisher	= {ACM Press},
  series	= {CCS '11},
  title		= {{Fear the EAR : Discovering and Mitigating Execution After
		  Redirect Vulnerabilities}},
  url		= {http://dl.acm.org/citation.cfm?id=2046707.2046736},
  year		= {2011}
}

@Article{	  drolia2011,
  abstract	= {In 2010, over 20.3 million vehicles were recalled.
		  Software issues related to automotive controls such as
		  cruise control, anti-lock braking system, traction control
		  and stability control, account for an increasingly large
		  percentage of the overall vehicles recalled. There is a
		  need for new and scalable methods to evaluate automotive
		  controls in a realistic and open setting. We have developed
		  AutoPlug, an automotive Electronic Controller Unit (ECU)
		  test-bed to diagnose, test, update and verify controls
		  software. AutoPlug consists of multiple ECUs interconnected
		  by a CAN bus, a race car driving simulator which behaves as
		  the plant model and a vehicle controls monitor in Matlab.
		  As the ECUs drive the simulated vehicle, the physics-based
		  simulation provides feedback to the controllers in terms of
		  acceleration, yaw, friction and vehicle stability. This
		  closed-loop platform is then used to evaluate multiple
		  vehicle control software modules such as traction,
		  stability and cruise control. With this test-bed we
		  highlight approaches for runtime ECU software diagnosis and
		  testing of the stability and performance of the vehicle.
		  Code updates can be executed via a smart phone so drivers
		  may remotely {\&}{\#}x201C;patch{\&}{\#}x201D; their
		  vehicle. This closed-loop automotive control test-bed
		  allows the automotive research community to explore the
		  capabilities and challenges of safe and secure remote code
		  updates for vehicle recalls management.<sup>1</sup>},
  author	= {Drolia, Utsav and Wang, Zhenyan and Pant, Yash and
		  Mangharam, Rahul},
  doi		= {10.1109/ITSC.2011.6083139},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Drolia et al. - AutoPlug An automotive test-bed for
		  electronic controller unit testing and
		  verification.pdf:pdf},
  isbn		= {9781457721984},
  issn		= {2153-0009},
  journal	= {IEEE Conference on Intelligent Transportation Systems,
		  Proceedings, ITSC},
  pages		= {1187--1192},
  title		= {{AutoPlug: An automotive test-bed for electronic
		  controller unit testing and verification}},
  year		= {2011}
}

@Article{	  du2010,
  abstract	= {Malicious modification of integrated circuits (ICs) in
		  untrusted foundry, referred to as “Hardware Trojan”,
		  has emerged as a serious security threat. While
		  side-channel analysis has been reported as an effective
		  approach to detect hardware Trojans, increasing process
		  variations in nanoscale technologies pose a major
		  challenge, since process noise can easily mask the Trojan
		  effect on a measured side-channel parameter, such as supply
		  current. Besides, existing side-channel approaches suffer
		  from reduced Trojan detection sensitivity with increasing
		  design size. In this paper, we propose a novel scalable
		  side-channel approach, named self-referencing, along with
		  associated vector generation algorithm to improve the
		  Hardware Trojan detection sensitivity under large process
		  variations. It compares transient current signature of one
		  region of an IC with that of another, thereby nullifying
		  the effect of process noise by exploiting spatial
		  correlation across regions in terms of process variations.
		  To amplify the Trojan effect on supply current, we propose
		  a region-based vector generation approach, which divides a
		  circuit-under-test (CUT) into several regions and for each
		  region, finds the test vectors which induce maximum
		  activity in that region, while minimizing the activity in
		  other regions. We show that the proposed side-channel
		  approach is scalable with respect to both amount of process
		  variations and design size. The approach is validated with
		  both simulation and measurement results using an FPGA-based
		  test setup for large designs including a 32-bit DLX
		  processor core ({\~{}}105 transistors). Results shows that
		  our approach can find ultra-small (<0.01{\%} area) Trojans
		  under large process variations of up to ± 20{\%} shift in
		  transistor threshold voltage.},
  author	= {Du, Dongdong and Narasimhan, Seetharam and Chakraborty,
		  Rajat Subhra and Bhunia, Swarup},
  doi		= {10.1007/978-3-642-15031-9{\_}12},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 - Du
		  et al. - Self-referencing A scalable side-channel approach
		  for hardware trojan detection.pdf:pdf},
  isbn		= {3642150306},
  issn		= {03029743},
  journal	= {Cryptographic Hardware and Embedded Systems Workshop
		  (CHES)},
  keywords	= {Hardware Trojan,Self-referencing,Side-channel analysis},
  pages		= {173--187},
  title		= {{Self-referencing: A scalable side-channel approach for
		  hardware trojan detection}},
  volume	= {6225 LNCS},
  year		= {2010}
}

@Article{	  duflot2011,
  abstract	= {In the last few years, many different attacks against
		  computing platform targeting hardware or low level firmware
		  have been published. Such attacks are generally quite hard
		  to detect and to defend against as they target components
		  that are out of the scope of the operating system and may
		  not have been taken into account in the security policy
		  enforced on the platform. In this paper, we study the case
		  of remote attacks against network adapters. In our case
		  study, we assume that the target adapter is running a
		  flawed firmware that an attacker may subvert remotely by
		  sending packets on the network to the adapter. We study
		  possible detection techniques and their efficiency. We show
		  that, depending on the architecture of the adapter and the
		  interface provided by the NIC to the host operating system,
		  building an efficient detection framework is possible. We
		  explain the choices we made when designing such a framework
		  that we called NAVIS and give details on our proof of
		  concept implementation.},
  author	= {Duflot, Lo{\"{\i}}c and Perez, Yves Alexis and Morin,
		  Benjamin},
  doi		= {10.1007/978-3-642-23644-0{\_}20},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Duflot, Perez, Morin - What if you can't trust your network
		  card.pdf:pdf},
  isbn		= {9783642236433},
  issn		= {03029743},
  journal	= {Proceedings of the Symposium on Recent Advances in
		  Intrusion Detection (RAID)},
  keywords	= {NIC,firmware,network adapter,runtime verification},
  pages		= {378--397},
  title		= {{What if you can't trust your network card?}},
  volume	= {6961 LNCS},
  year		= {2011}
}

@Article{	  dunlap2002,
  abstract	= {Current system loggers have two problems: they depend on
		  the integrity of the operating system being logged, and
		  they do not save sufficient information to replay and
		  analyze attacks that include any non-deterministic events.
		  ReVirt removes the dependency on the target operating
		  system by moving it into a virtual machine and logging
		  below the virtual machine. This allows ReVirt to replay the
		  system's execution before, during, and after an intruder
		  compromises the system, even if the intruder replaces the
		  target operating system. ReVirt logs enough information to
		  replay a long-term execution of the virtual machine
		  instruction-by-instruction. This enables it to provide
		  arbitrarily detailed observations about what transpired on
		  the system, even in the presence of non-deterministic
		  attacks and executions. ReVirt adds reasonable time and
		  space overhead. Overheads due to virtualization are
		  imperceptible for interactive use and CPU-bound workloads,
		  and 13--58{\%} for kernel-intensive workloads. Logging adds
		  0--8{\%} overhead, and logging traffic for our workloads
		  can be stored on a single disk for several months.},
  author	= {Dunlap, Gw and King, St and Cinar, Sukru},
  doi		= {10.1145/844128.844148},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2002 -
		  Dunlap, King, Cinar - ReVirt Enabling intrusion analysis
		  through virtual-machine logging and replay.pdf:pdf},
  isbn		= {9781450301114},
  issn		= {0163-5980},
  journal	= {ACM SIGOPS Operating {\ldots}},
  number	= {SI},
  pages		= {211--224},
  title		= {{ReVirt: Enabling intrusion analysis through
		  virtual-machine logging and replay}},
  url		= {http://doi.acm.org/10.1145/844128.844148$\backslash$nhttp://dl.acm.org/ft{\_}gateway.cfm?id=844148{\&}type=pdf$\backslash$nhttp://dl.acm.org/citation.cfm?id=844148}
		  ,
  volume	= {36},
  year		= {2002}
}

@Article{	  dworak2013,
  author	= {Dworak, Jennifer and Crouch, Al and Potter, John and
		  Zygmontowicz, Adam and Thornton, Micah},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Dworak et al. - Don't Forget to Lock your SIB Hiding
		  Instruments using P1687 1.pdf:pdf},
  isbn		= {9781479908592},
  pages		= {1--10},
  title		= {{Don't Forget to Lock your SIB: Hiding Instruments using
		  P1687 1}},
  year		= {2013}
}

@InProceedings{	  felmetsger10:logic,
  address	= {Washington, DC},
  author	= {Felmetsger, Viktoria and Cavedon, Ludovico and Kruegel,
		  Christopher and Vigna, Giovanni},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Felmetsger et al. - Toward Automated Detection of Logic
		  Vulnerabilities in Web Applications.pdf:pdf},
  month		= {aug},
  title		= {{Toward Automated Detection of Logic Vulnerabilities in
		  Web Applications}},
  year		= {2010}
}

@InProceedings{	  felmetsger10:logic,
  address	= {Washington, DC},
  author	= {Felmetsger, Viktoria and Cavedon, Ludovico and Kruegel,
		  Christopher and Vigna, Giovanni},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Felmetsger et al. - Toward Automated Detection of Logic
		  Vulnerabilities in Web Applications.pdf:pdf},
  month		= {aug},
  title		= {{Toward Automated Detection of Logic Vulnerabilities in
		  Web Applications}},
  year		= {2010}
}

@InProceedings{	  felmetsger10:logic,
  address	= {Washington, DC},
  author	= {Felmetsger, Viktoria and Cavedon, Ludovico and Kruegel,
		  Christopher and Vigna, Giovanni},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Felmetsger et al. - Toward Automated Detection of Logic
		  Vulnerabilities in Web Applications.pdf:pdf},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  month		= {aug},
  title		= {{Toward Automated Detection of Logic Vulnerabilities in
		  Web Applications}},
  year		= {2010}
}

@Article{	  ford2008,
  abstract	= {Code sandboxing is useful for many purposes, but most
		  sandboxing techniques require kernel modifications, do not
		  completely isolate guest code, or incur substantial
		  performance costs. Vx32 is a multipurpose user-level
		  sandbox that enables any application to load and safely
		  execute one or more guest plug-ins, confining each guest to
		  a system call API controlled by the host application and to
		  a restricted memory region within the host's address space.
		  Vx32 runs guest code efficiently on several widespread
		  operating systems without kernel extensions or special
		  privileges; it protects the host program from both reads
		  and writes by its guests; and it allows the host to
		  restrict the instruction set available to guests. The key
		  to vx32's combination of portability, flexibility, and
		  efficiency is its use of x86 segmentation hardware to
		  sandbox the guest's data accesses, along with a lightweight
		  instruction translator to sandbox guest instructions.},
  author	= {Ford, Bryan and Cox, Russ},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/ford.pdf:pdf}
		  ,
  journal	= {Work},
  pages		= {293--306},
  title		= {{Vx32 : Lightweight User-level Sandboxing on the x86}},
  url		= {http://portal.acm.org/citation.cfm?id=1404039},
  year		= {2008}
}

@Article{	  forte2013,
  author	= {Forte, Domenic and Bao, Chongxi and Srivastava, Ankur},
  doi		= {10.1109/ICCAD.2013.6691167},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Forte, Bao, Srivastava - Temperature tracking An innovative
		  run-time approach for hardware Trojan detection.pdf:pdf},
  isbn		= {9781479910717},
  issn		= {10923152},
  journal	= {IEEE/ACM International Conference on Computer-Aided
		  Design, Digest of Technical Papers, ICCAD},
  pages		= {532--539},
  title		= {{Temperature tracking: An innovative run-time approach for
		  hardware Trojan detection}},
  year		= {2013}
}

@Article{	  frantzen2001,
  abstract	= {Vulnerabilities in vendor as well as freeware
		  implementations of firewalls continue to emerge at a rapid
		  pace. Each vulnerability superficially appears to be the
		  result of something such as a coding flaw in one case, or a
		  configuration weakness in another. Given the large number
		  of firewall vulnerabilities that have surfaced in recent
		  years, it is important to develop a comprehensive framework
		  for understanding both what firewalls actually do when they
		  receive incoming traffic and what can go wrong when they
		  process this traffic. An intuitive starting point is to
		  create a firewall dataflow model composed of discrete
		  processing stages that reflect the processing
		  characteristics of a given firewall. These stages do not
		  necessarily all occur in all firewalls, nor do they always
		  conform to the sequential order indicated in this paper.
		  This paper also provides a more complete view of what
		  happens inside a firewall, other than handling the
		  filtering and possibly other rules that the administrator
		  may have established. Complex interactions that influence
		  the security that a firewall delivers frequently occur.
		  Firewall administrators too often blindly believe that
		  filtering rules solely decide the fate of any given packet.
		  Distinguishing between the surface functionality (i.e.,
		  functionality related to packet filtering) and the deeper,
		  dataflow-related functionality of firewalls provides a
		  framework for understanding vulnerabilities that have
		  surfaced in firewalls.},
  author	= {Frantzen, Mike and Kerschbaum, Florian and Schultz,
		  E.Eugene and Fahmy, Sonia},
  doi		= {10.1016/S0167-4048(01)00314-5},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2001 -
		  Frantzen et al. - A Framework for Understanding
		  Vulnerabilities in Firewalls Using a Dataflow Model of
		  Firewall Internals.pdf:pdf},
  issn		= {01674048},
  journal	= {Computers {\&} Security},
  number	= {3},
  pages		= {263--270},
  title		= {{A Framework for Understanding Vulnerabilities in
		  Firewalls Using a Dataflow Model of Firewall Internals}},
  volume	= {20},
  year		= {2001}
}

@Article{	  fratantonio2016,
  author	= {Fratantonio, Yanick and Bianchi, Antonio and Robertson,
		  William and Kirda, Engin and Kruegel, Christopher and
		  Vigna, Giovanni},
  doi		= {10.1109/SP.2016.30},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/2016{\_}SP{\_}Triggerscope.pdf:pdf}
		  ,
  journal	= {Ieee S{\&}P},
  pages		= {1--33},
  title		= {{TriggerScope: Towards Detecting Logic Bombs in Android
		  Applications}},
  year		= {2016}
}

@Article{	  gadaleta2011,
  abstract	= {In monolithic operating systems, the kernel is the piece
		  of code that executes with the highest privileges and has
		  control over all the software running on a host. A
		  successful attack against an operating system's kernel
		  means a total and complete compromise of the running
		  system. These attacks usually end with the installation of
		  a rootkit, a stealthy piece of software running with kernel
		  privileges. When a rootkit is present, no guarantees can be
		  made about the correctness, privacy or isolation of the
		  operating system. In this paper we present Hello rootKitty,
		  an invariance-enforcing framework which takes advantage of
		  current virtualization technology to protect a guest
		  operating system against rootkits. Hello rootKitty uses the
		  idea of invariance to detect maliciously modified kernel
		  data structures and restore them to their original
		  legitimate values. Our prototype has negligible performance
		  and memory overhead while effectively protecting commodity
		  operating systems from modern rootkits.},
  archiveprefix	= {arXiv},
  arxivid	= {1405.5651},
  author	= {Gadaleta, Francesco and Nikiforakis, Nick and Younan, Yves
		  and Joosen, Wouter},
  doi		= {10.1007/978-3-642-24861-0{\_}15},
  eprint	= {1405.5651},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Gadaleta et al. - Hello rootKitty A lightweight
		  invariance-enforcing framework.pdf:pdf},
  isbn		= {9783642248603},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  keywords	= {detection,invariance,rootkits,virtualization},
  pages		= {213--228},
  title		= {{Hello rootKitty: A lightweight invariance-enforcing
		  framework}},
  volume	= {7001 LNCS},
  year		= {2011}
}

@Article{	  ganapathy2008,
  abstract	= {Device drivers commonly execute in the kernel to achieve
		  high performance and easy access to kernel services.
		  However, this comes at the price of decreased reliability
		  and increased programming difficulty. Driver programmers
		  are unable to use user-mode development tools and must
		  instead use cumbersome kernel tools. Faults in kernel
		  drivers can cause the entire operating system to crash.
		  User-mode drivers have long been seen as a solution to this
		  problem, but suffer from either poor performance or new
		  interfaces that require a rewrite of existing drivers. This
		  paper introduces the Microdrivers architecture that
		  achieves high performance and compatibility by leaving
		  critical path code in the kernel and moving the rest of the
		  driver code to a user-mode process. This allows
		  data-handling operations critical to I/O performance to run
		  at full speed, while management operations such as
		  initialization and configuration run at reduced speed in
		  user-level. To achieve compatibility, we present
		  DriverSlicer, a tool that splits existing kernel drivers
		  into a kernel-level component and a user-level component
		  using a small number of programmer annotations. Experiments
		  show that as much as 65{\%} of driver code can be removed
		  from the kernel without affecting common-case performance,
		  and that only 1-6 percent of the code requires
		  annotations.},
  author	= {Ganapathy, Vinod and Renzelmann, Matthew J. and
		  Balakrishnan, Arini and Swift, Michael M. and Jha, Somesh},
  doi		= {10.1145/1353536.1346303},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Ganapathy et al. - The design and implementation of
		  microdrivers.pdf:pdf},
  isbn		= {978-1-59593-958-6},
  issn		= {03621340},
  journal	= {ACM SIGPLAN Notices},
  keywords	= {device drivers,program partitioning,reliability},
  number	= {3},
  pages		= {168},
  title		= {{The design and implementation of microdrivers}},
  volume	= {43},
  year		= {2008}
}

@Article{	  garfinkel2003,
  abstract	= {We present a flexible architecture for trusted computing,
		  called Terra, that allows applications with a wide range of
		  security requirements to run simultaneously on commodity
		  hardware. Applications on Terra enjoy the semantics of
		  running on a separate, dedicated, tamper-resistant hardware
		  platform, while retaining the ability to run side-by-side
		  with normal applications on a general-purpose computing
		  platform. Terra achieves this synthesis by use of a trusted
		  virtual machine monitor (TVMM) that partitions a
		  tamper-resistant hardware platform into multiple, isolated
		  virtual machines (VM), providing the appearance of multiple
		  boxes on a single, general-purpose platform. To each VM,
		  the TVMM provides the semantics of either an "open box,"
		  i.e. a general-purpose hardware platform like today's PCs
		  and workstations, or a "closed box," an opaque
		  special-purpose platform that protects the privacy and
		  integrity of its contents like today's game consoles and
		  cellular phones. The software stack in each VM can be
		  tailored from the hardware interface up to meet the
		  security requirements of its application(s). The hardware
		  and TVMM can act as a trusted party to allow closed-box VMs
		  to cryptographically identify the software they run, i.e.
		  what is in the box, to remote parties. We explore the
		  strengths and limitations of this architecture by
		  describing our prototype implementation and several
		  applications that we developed for it. Copyright 2003
		  ACM.},
  author	= {Garfinkel, T and Pfaff, B and Chow, J and Rosenblum, M and
		  Boneh, D},
  doi		= {10.1145/945445.945464},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Garfinkel et al. - Terra A virtual machine-based platform
		  for trusted computing.pdf:pdf},
  isbn		= {1581137575},
  issn		= {0163-5980},
  journal	= {Operating Systems Review (ACM)},
  keywords	= {all or part of,attestation,authentication,ing,or hard
		  copies of,permission to make digital,this work for,trusted
		  comput-,virtual machine,virtual machine monitor,vmm},
  pages		= {193--206},
  pmid		= {10207907},
  title		= {{Terra: A virtual machine-based platform for trusted
		  computing}},
  url		= {http://www.scopus.com/inward/record.url?eid=2-s2.0-21644455412{\&}partnerID=40{\&}md5=1ebefb54946526a351d85d62681cc499}
		  ,
  volume	= {37},
  year		= {2003}
}

@Article{	  garfinkel2003a,
  abstract	= {Today's architectures for intrusion detection force the
		  IDS designer to make a difficult choice. If the IDS resides
		  on the host, it has an excellent view of what is happening
		  in that host's software, but is highly susceptible to
		  attack. On the other hand, if the IDS resides in the
		  network, it is more resistant to attack, but has a poor
		  view of what is happening inside the host, making it more
		  susceptible to evasion. In this paper we present an
		  architecture that retains the visibility of a host-based
		  IDS, but pulls the IDS outside of the host for greater
		  attack resistance. We achieve this through the use of a
		  virtual machine monitor. Using this approach allows us to
		  isolate the IDS from the monitored host but still retain
		  excellent visibility into the host's state. The VMM also
		  offers us the unique ability to completely mediate
		  interactions between the host software and the underlying
		  hardware. We present a detailed study of our architecture,
		  including Livewire, a prototype implementation. We
		  demonstrate Livewire by implementing a suite of simple
		  intrusion detection policies and using them to detect real
		  attacks.},
  author	= {Garfinkel, Tal and Rosenblum, Mendel},
  doi		= {10.1109/SP.2011.11},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Garfinkel, Rosenblum - A Virtual Machine Introspection
		  Based Architecture for Intrusion Detection.pdf:pdf},
  isbn		= {978-1-4577-0147-4},
  journal	= {Proc. Network and Distributed Systems Security {\ldots}},
  pages		= {253--285},
  title		= {{A Virtual Machine Introspection Based Architecture for
		  Intrusion Detection}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.11.8367{\&}amp;rep=rep1{\&}amp;type=pdf$\backslash$nhttp://www.isoc.org/isoc/conferences/ndss/03/proceedings/papers/13.pdf}
		  ,
  volume	= {1},
  year		= {2003}
}

@Article{	  garfinkel2003b,
  abstract	= {Today's architectures for intrusion detection force the
		  IDS designer to make a difficult choice. If the IDS resides
		  on the host, it has an excellent view of what is happening
		  in that host's software, but is highly susceptible to
		  attack. On the other hand, if the IDS resides in the
		  network, it is more resistant to attack, but has a poor
		  view of what is happening inside the host, making it more
		  susceptible to evasion. In this paper we present an
		  architecture that retains the visibility of a host-based
		  IDS, but pulls the IDS outside of the host for greater
		  attack resistance. We achieve this through the use of a
		  virtual machine monitor. Using this approach allows us to
		  isolate the IDS from the monitored host but still retain
		  excellent visibility into the host's state. The VMM also
		  offers us the unique ability to completely mediate
		  interactions between the host software and the underlying
		  hardware. We present a detailed study of our architecture,
		  including Livewire, a prototype implementation. We
		  demonstrate Livewire by implementing a suite of simple
		  intrusion detection policies and using them to detect real
		  attacks.},
  author	= {Garfinkel, Tal and Rosenblum, Mendel},
  doi		= {10.1109/SP.2011.11},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Garfinkel, Rosenblum - A Virtual Machine Introspection
		  Based Architecture for Intrusion Detection(2).pdf:pdf},
  isbn		= {978-1-4577-0147-4},
  journal	= {Proc. Network and Distributed Systems Security {\ldots}},
  pages		= {253--285},
  title		= {{A Virtual Machine Introspection Based Architecture for
		  Intrusion Detection}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.11.8367{\&}amp;rep=rep1{\&}amp;type=pdf$\backslash$nhttp://www.isoc.org/isoc/conferences/ndss/03/proceedings/papers/13.pdf}
		  ,
  volume	= {1},
  year		= {2003}
}

@Article{	  garg2013,
  abstract	= {In industry, software testing and coverage-based metrics
		  are the predominant techniques to check correctness of
		  software. This paper addresses automatic unit test
		  generation for programs written in C/C++. The main idea is
		  to improve the coverage obtained by feedback-directed
		  random test generation methods, by utilizing concolic
		  execution on the generated test drivers. Furthermore, for
		  programs with numeric computations, we employ non-linear
		  solvers in a lazy manner to generate new test inputs. These
		  techniques significantly improve the coverage provided by a
		  feedback-directed random unit testing framework, while
		  retaining the benefits of full automation. We have
		  implemented these techniques in a prototype platform, and
		  describe promising experimental results on a number of
		  C/C++ open source benchmarks.},
  author	= {Garg, Pranav and Ivancic, Franjo and Balakrishnan, Gogul
		  and Maeda, Naoto and Gupta, Aarti},
  doi		= {10.1109/ICSE.2013.6606559},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Garg et al. - Feedback-directed unit test generation for CC
		  using concolic execution.pdf:pdf},
  isbn		= {9781467330763},
  issn		= {02705257},
  journal	= {Proceedings - International Conference on Software
		  Engineering},
  pages		= {132--141},
  title		= {{Feedback-directed unit test generation for C/C++ using
		  concolic execution}},
  year		= {2013}
}

@Article{	  giani2006,
  author	= {Giani, Annarita and Berk, V.H. and Cybenko, G.V.},
  doi		= {10.1117/12.670123},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Giani, Berk, Cybenko - Data exfiltration and covert
		  channels.pdf:pdf},
  isbn		= {0819462578},
  issn		= {0277786X},
  journal	= {Sensors, and Command, Control, Communications, and
		  Intelligence (C3I) Technologies for Homeland Security and
		  Homeland Defense V},
  keywords	= {computer security,covert channels,data exfiltration},
  pages		= {620103--620103--11},
  title		= {{Data exfiltration and covert channels}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.89.5290{\&}amp;rep=rep1{\&}amp;type=pdf}
		  ,
  year		= {2006}
}

@Article{	  giuffrida2012,
  abstract	= {n recent years, the deployment of many application-level
		  countermeasures against memory errors and the increasing
		  number of vulnerabilities discovered in the kernel has
		  fostered a renewed interest in kernel-level exploitation.
		  Unfortunately, no comprehensive and well-established
		  mechanism exists to protect the operating system from
		  arbitrary attacks, due to the relatively new development of
		  the area and the challenges involved. In this paper, we
		  propose the first design for fine-grained address space
		  randomization (ASR) inside the operating system (OS),
		  providing an efficient and comprehensive countermeasure
		  against classic and emerging attacks, such as
		  return-oriented programming. To motivate our design, we
		  investigate the differences with application-level ASR and
		  find that some of the well-established assumptions in
		  existing solutions are no longer valid inside the OS; above
		  all, perhaps, that information leakage becomes a major
		  concern in the new context. We show that our ASR strategy
		  outperforms state-of-the-art solutions in terms of both
		  performance and security without affecting the software
		  distribution model. Finally, we present the first
		  comprehensive live rerandomization strategy, which we found
		  to be particularly important inside the OS. Experimental
		  results demonstrate that our techniques yield low run-time
		  performance overhead (less than 5{\%} on average on both
		  SPEC and syscall-intensive benchmarks) and limited run-time
		  memory footprint increase (around 15{\%} during the
		  execution of our benchmarks). We believe our techniques can
		  greatly enhance the level of OS security without
		  compromising the performance and reliability of the OS.},
  annote	= {1. How to protect the OS from attacks.
		  
		  2. Apply ASLR to the OS.
		  
		  3.
		  
		  56},
  author	= {Giuffrida, Cristiano and Kuijsten, Anton and Tanenbaum,
		  As},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Giuffrida, Kuijsten, Tanenbaum - Enhanced operating system
		  security through efficient and fine-grained address space
		  randomizatio.pdf:pdf},
  isbn		= {978-931971-95-9},
  journal	= {21th USENIX conference on Security},
  pages		= {16},
  title		= {{Enhanced operating system security through efficient and
		  fine-grained address space randomization}},
  url		= {https://www.usenix.org/sites/default/files/conference/protected-files/giuffrida{\_}usenixsecurity12{\_}slides.pdf}
		  ,
  year		= {2012}
}

@Article{	  gokta2014,
  author	= {G{\"{o}}kta$\backslash$c s, Enes and Athanasopoulos, Elias
		  and Polychronakis, Michalis and Bos, Herbert and
		  Portokalidis, Georgios},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  G{\"{o}}ktaş et al. - Size Does Matter Why Using
		  Gadget-Chain Length to Prevent Code-Reuse Attacks is
		  Hard.pdf:pdf},
  isbn		= {978-1-931971-15-7},
  journal	= {23rd USENIX Security Symposium (USENIX Security 14)},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {417--432},
  title		= {{Size Does Matter: Why Using Gadget-Chain Length to
		  Prevent Code-Reuse Attacks is Hard}},
  url		= {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/goktas}
		  ,
  year		= {2014}
}

@Article{	  goktas2014,
  author	= {G{\"{o}}ktas, E and Athanasopoulos, E and Bos, Herbert and
		  Portokalidis, G},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  G{\"{o}}kta, Bos - Out Of Control Overcoming Control-Flow
		  Integrity.pdf:pdf},
  journal	= {Ieee S{\&}P},
  keywords	= {code-reuse attack,control-flow integrity evaluation},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Out of control: Overcoming control-flow integrity}},
  url		= {http://www.cs.stevens.edu/{~}gportoka/files/outofcontrol{\_}oakland14.pdf}
		  ,
  year		= {2014}
}

@Article{	  grace2010,
  author	= {Grace, Michael and Wang, Zhi and Srinivasan, Deepa and Li,
		  Jinku and Jiang, Xuxian and Liang, Zhenkai and Liakh,
		  Siarhei},
  doi		= {10.1007/978-3-642-16161-2{\_}10},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Grace et al. - Transparent protection of commodity OS
		  kernels using hardware virtualization.pdf:pdf},
  isbn		= {364216160X},
  issn		= {18678211},
  journal	= {Lecture Notes of the Institute for Computer Sciences,
		  Social-Informatics and Telecommunications Engineering},
  keywords	= {Harvard architecture,Split memory,Virtualization},
  pages		= {162--180},
  title		= {{Transparent protection of commodity OS kernels using
		  hardware virtualization}},
  volume	= {50 LNICST},
  year		= {2010}
}

@Article{	  grace2010,
  author	= {Grace, Michael and Wang, Zhi and Srinivasan, Deepa and Li,
		  Jinku and Jiang, Xuxian and Liang, Zhenkai and Liakh,
		  Siarhei},
  doi		= {10.1007/978-3-642-16161-2{\_}10},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Grace et al. - Transparent protection of commodity OS
		  kernels using hardware virtualization(2).pdf:pdf},
  isbn		= {364216160X},
  issn		= {18678211},
  journal	= {Security and Privacy in Communication Networks},
  keywords	= {harvard architecture,split memory,virtualization},
  mendeley-groups={4 - Hypervisor},
  pages		= {162--180},
  title		= {{Transparent protection of commodity OS kernels using
		  hardware virtualization}},
  year		= {2010}
}

@Article{	  groza2012,
  author	= {Groza, Bogdan and Murvay, Stefan and {Van Herrewege},
		  Anthony and Verbauwhede, Ingrid},
  doi		= {10.1007/978-3-642-35404-5{\_}15},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Groza et al. - LiBrA-CAN A lightweight broadcast
		  authentication protocol for controller area
		  networks.pdf:pdf},
  isbn		= {9783642354038},
  issn		= {03029743},
  journal	= {Proceedings of the International Conference on Cryptology
		  and Network Security (CANS)},
  pages		= {185--200},
  title		= {{LiBrA-CAN: A lightweight broadcast authentication
		  protocol for controller area networks}},
  volume	= {7712 LNCS},
  year		= {2012}
}

@InProceedings{	  gu2007,
  annote	= {They monitor traffic on the perimeter of a network to find
		  malicious communication between hosts inside and outside
		  the network.
		  
		  They aim at recognizing successful bot infections through
		  the communication sequences that occur during the infection
		  process. A botnet infection is modeled as a set of loosely
		  ordered communication flows exchanged between the host and
		  external entities.
		  
		  They correlate the different phases of an infection trying
		  to detect bots. the correlator is driven by Snort with
		  customized rules and anomaly detection plugins. The
		  correlator associates intrusion alarms with outgoing
		  traffic which is indicative of an infection.
		  
		  Their infection model is oldfashioned: scan for victims,
		  exploit, open communication channel to the attacker,
		  download the egg, connect to IRC, get orders.
		  
		  They flag a host as a bot if: - They have evidence of local
		  infection and evidence of outward bot coordination activity
		  - they have two signs of outward malicious activity
		  
		  They use the snort alert as an input do do event
		  correlation and try to detect bots.
		  
		  Custom snort plugins: * Statistical Scan Anomaly Detection
		  Engine - they try to detect inbound scans and outbound
		  attack propagations once the system is infected. They
		  distinguish between ports typically targeted by malware and
		  ports that are not * Statistical Payload Anomaly Detection
		  Engine: they try to detect payload exploits. They look for
		  h-gram frequency that deviates from normal traffic. *
		  Signature engine - custom botnet related rules
		  
		  Correlation engine: network dialog correlation matrix: a
		  host is declared infected when a minimum combination of
		  dialog transactions is met. They have a timer to prune old
		  dialogs
		  
		  Evaluation:
		  
		  First, they run the system in a virtual network with a
		  C{\&}amp;C and 2 clients, and log all the traffic. They
		  build their model, and detect the bot as infected.
		  
		  As a second experiment, they run a honeynet. Bothunter
		  detected 95{\%} of the infections that happened. False
		  positives: one per day
		  
		  Limitations: stealthiness (both on the C{\&}amp;C side and
		  on the client side) could evade the system. In particular,
		  they do not detect encrypted stuff (signature would be
		  useless for that).},
  author	= {Gu, Guofei and Porras, Phillip and Yegneswaran, Vinod and
		  Fong, Martin and Lee, Wenke},
  booktitle	= {Proceedings of 16th USENIX Security Symposium on USENIX
		  Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 - Gu
		  et al. - Bothunter Detecting malware infection through
		  ids-driven dialog correlation.pdf:pdf},
  pages		= {12},
  publisher	= {USENIX Association},
  title		= {{Bothunter: Detecting malware infection through ids-driven
		  dialog correlation}},
  url		= {http://portal.acm.org/citation.cfm?id=1362915},
  year		= {2007}
}

@Article{	  gu2008,
  abstract	= {2014-08-26 584},
  author	= {Gu, Guofei and Perdisci, Roberto and Zhang, Junjie and
		  Lee, Wenke and Others},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 - Gu
		  et al. - BotMiner Clustering Analysis of Network Traffic
		  for Protocol-and Structure-Independent Botnet
		  Detection.pdf:pdf},
  journal	= {USENIX Security Symposium},
  pages		= {139--154},
  title		= {{BotMiner: Clustering Analysis of Network Traffic for
		  Protocol-and Structure-Independent Botnet Detection.}},
  year		= {2008}
}

@Article{	  gu2008a,
  abstract	= {The paper presents BotSniffer, a IDS that monitors the
		  command channel of bots to detect them inside a network.
		  This is based on the time and message correlation of
		  command communication.},
  author	= {Gu, Guofei and Zhang, Junjie and Lee, Wenke},
  doi		= {10.1.1.110.8092},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 - Gu,
		  Zhang, Lee - BotSniffer Detecting Botnet Command and
		  Control Channels in Network Traffic.pdf:pdf},
  issn		= {03601315},
  journal	= {Proceedings of the 15th Annual Network and Distributed
		  System Security Symposium.},
  number	= {1},
  pages		= {1--13},
  title		= {{BotSniffer : Detecting Botnet Command and Control
		  Channels in Network Traffic}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.8092{\&}amp;rep=rep1{\&}amp;type=pdf}
		  ,
  volume	= {53},
  year		= {2008}
}

@Article{	  gu2011,
  author	= {Gu, Liang and Vaynberg, Alexander and Ford, Bryan and
		  Shao, Zhong and Costanzo, David},
  doi		= {10.1145/2103799.2103803},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Gu
		  et al. - Certikos A certified kernel for secure cloud
		  computing.pdf:pdf},
  isbn		= {978-1-4503-1179-3},
  journal	= {Proceedings of the Second Asia-Pacific Workshop on
		  Systems},
  keywords	= {VMM,cloaking,hypervisors,memory
		  protection,multi-shadowing,operating systems,virtual
		  machine monitors},
  mendeley-groups={4 - Hypervisor},
  number	= {0362-1340},
  pages		= {3:1----3:5},
  title		= {{Certikos: A certified kernel for secure cloud
		  computing}},
  url		= {http://dl.acm.org/citation.cfm?id=2103803},
  year		= {2011}
}

@InProceedings{	  guha2009,
  address	= {New York, New York, USA},
  annote	= {Static control-flow analysis for JavaScript applications.
		  
		  They extract a model of the expected behavior of the
		  client, then use a proxy to block calls that
		  don{\&}{\#}039;t match this model.
		  
		  They add in randomized request to foil mimicry attacks.
		  
		  They also handle the Ajax calls (XHR).
		  
		  They can{\&}{\#}039;t really handle dynamic javascript
		  code. They require explict session identifiers.},
  author	= {Guha, Arjun and Krishnamurthi, Shriram and Jim, Trevor},
  booktitle	= {Proceedings of the 18th International Conference on World
		  Wide Web},
  doi		= {10.1145/1526709.1526785},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Guha, Krishnamurthi, Jim - Using Static Analysis for Ajax
		  Intrusion Detection.pdf:pdf},
  isbn		= {9781605584874},
  keywords	= {ajax,control-flow analysis,intrusion detec-,javascript},
  pages		= {561},
  publisher	= {ACM Press},
  title		= {{Using Static Analysis for Ajax Intrusion Detection}},
  url		= {http://portal.acm.org/citation.cfm?doid=1526709.1526785
		  http://dl.acm.org/citation.cfm?id=1526785},
  year		= {2009}
}

@Article{	  guin2014,
  author	= {Guin, Ujjwal and DiMase, Daniel and Tehranipoor,
		  Mohammad},
  doi		= {10.1007/s10836-013-5428-2},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Guin, DiMase, Tehranipoor - A Comprehensive Framework for
		  Counterfeit Defect Coverage Analysis and Detection
		  Assessment.pdf:pdf},
  issn		= {0923-8174},
  journal	= {Journal of Electronic Testing},
  keywords	= {assessment,counterfeit ic,defect coverage,detection
		  methods},
  title		= {{A Comprehensive Framework for Counterfeit Defect Coverage
		  Analysis and Detection Assessment}},
  url		= {http://link.springer.com/10.1007/s10836-013-5428-2},
  year		= {2014}
}

@Article{	  guin2014a,
  author	= {Guin, Ujjwal and Huang, Ke and Dimase, Daniel and Carulli,
		  John M. and Tehranipoor, Mohammad and Makris, Yiorgos},
  doi		= {10.1109/JPROC.2014.2332291},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Guin et al. - Counterfeit integrated circuits A rising
		  threat in the global semiconductor supply chain.pdf:pdf},
  issn		= {00189219},
  journal	= {Proceedings of the IEEE},
  keywords	= {AC/DC parametric tests,counterfeit integrated circuits
		  (ICs),electrical inspection,hardware security,machine
		  learning,path-delay test,yiorgos.makris@utdallas.edu},
  number	= {8},
  pages		= {1207--1228},
  title		= {{Counterfeit integrated circuits: A rising threat in the
		  global semiconductor supply chain}},
  volume	= {102},
  year		= {2014}
}

@Article{	  guin2014b,
  author	= {Guin, Ujjwal and Dimase, Daniel and Tehranipoor,
		  Mohammad},
  doi		= {10.1007/s10836-013-5430-8},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Guin, Dimase, Tehranipoor - Counterfeit integrated circuits
		  Detection, avoidance, and the challenges ahead.pdf:pdf},
  issn		= {15730727},
  journal	= {Journal of Electronic Testing: Theory and Applications
		  (JETTA)},
  keywords	= {Counterfeit ICs,Counterfeit detection and
		  avoidance,Electronic component supply chain},
  number	= {1},
  pages		= {9--23},
  title		= {{Counterfeit integrated circuits: Detection, avoidance,
		  and the challenges ahead}},
  volume	= {30},
  year		= {2014}
}

@InProceedings{	  guo2015,
  author	= {Guo, Xiaolong and Dutta, Raj Gautam and Jin, Yier and
		  Farahmandi, Farimah and Mishra, Prabhat},
  booktitle	= {EEE/ACM Design Automation Conference (DAC)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 - Guo
		  et al. - Pre-Silicon Security Verification and Validation A
		  Formal Perspective.pdf:pdf},
  isbn		= {9781450335201},
  title		= {{Pre-Silicon Security Verification and Validation: A
		  Formal Perspective}},
  year		= {2015}
}

@Article{	  gupta2013,
  author	= {Gupta, Aditi and Kerr, Sam and Kirkpatrick, Michael S. and
		  Bertino, Elisa},
  doi		= {10.1007/978-3-642-38631-2{\_}22},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Gupta et al. - Marlin A fine grained randomization approach
		  to defend against ROP attacks.pdf:pdf},
  isbn		= {9783642386305},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  keywords	= {Integrity,Malware,Return-oriented programming,Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {293--306},
  title		= {{Marlin: A fine grained randomization approach to defend
		  against ROP attacks}},
  volume	= {7873 LNCS},
  year		= {2013}
}

@TechReport{	  haider2015,
  author	= {Haider, Syed Kamran and Jin, Chenglu and Ahmad, Masab and
		  Shila, Devu Manikantan and Khan, Omer and van Dijk,
		  Marten},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Haider et al. - HaTCh A Formal Framework of Hardware Trojan
		  Design and Detection.pdf:pdf},
  keywords	= {hardware trojans,ip cores,security},
  pages		= {1--28},
  title		= {{HaTCh: A Formal Framework of Hardware Trojan Design and
		  Detection}},
  year		= {2015}
}

@Article{	  halfond2008,
  address	= {New York, New York, USA},
  author	= {Halfond, William G. J. and Orso, Alessandro},
  doi		= {10.1145/1453101.1453126},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Halfond, Orso - Automated identification of parameter
		  mismatches in web applications.pdf:pdf},
  isbn		= {9781595939951},
  journal	= {Proceedings of the 16th ACM SIGSOFT International
		  Symposium on Foundations of software engineering - SIGSOFT
		  '08/FSE-16},
  pages		= {181},
  publisher	= {ACM Press},
  title		= {{Automated identification of parameter mismatches in web
		  applications}},
  url		= {http://portal.acm.org/citation.cfm?doid=1453101.1453126},
  year		= {2008}
}

@InProceedings{	  halfond:amnesia,
  annote	= {This paper works by first computing a model (NDFA) of each
		  sql query in the program.
		  
		  Then, they insert a dynamic check before each database
		  query.
		  
		  In this check, they compare the string sent to the database
		  to the model. If it doesn't match the model (because user
		  input modified it), then the query is rejected.
		  
		  The experimented on 7 application, with between 7k and 17k
		  lines of code. Also this is for Java servlets and jsp
		  pages. They generated legit and attack traffic.
		  
		  Their approach caught all attacks and didn't lead to any
		  false positives.
		  
		  Very good paper.},
  author	= {Halfond, W and Orso, A},
  booktitle	= {Proceedings of the International Conference on Automated
		  Software Engineering (ASE)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Halfond, Orso - AMNESIA Analysis and Monitoring for
		  NEutralizing SQL-Injection Attacks.pdf:pdf},
  month		= {nov},
  pages		= {174--183},
  title		= {{AMNESIA: Analysis and Monitoring for NEutralizing
		  SQL-Injection Attacks}},
  year		= {2005}
}

@InProceedings{	  herrewege2011,
  abstract	= {The Controller-Area Network (CAN) bus protocol [1] is a
		  bus protocol invented in 1986 by Robert Bosch GmbH,
		  originally intended for automotive use. By now, the bus can
		  be found in devices ranging from cars and trucks, over
		  lightning setups to industrial looms. Due to its nature, it
		  is a system very much fo- cused on safety, i.e.,
		  reliability. Unfortunately, there is no build-in way to
		  enforce security, such as encryption or authentication. In
		  this paper, we investigate the problems associated with
		  implementing a backward compatible message authentication
		  protocol on the CAN bus. We show which constraints such a
		  protocol has to meet and why this eliminates, to the best
		  of our knowledge, all the authentication protocols
		  published so far. Furthermore, we present a message
		  authentication protocol, CANAuth, that meets all of the
		  requirements set forth and does not violate any constraint
		  of the CAN bus.},
  author	= {Herrewege, Anthony Van and Singelee, Dave and Verbauwhede,
		  Ingrid},
  booktitle	= {ECRYPT Workshop on Lightweight Cryptography},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Herrewege, Singelee, Verbauwhede - CANAuth - A Simple ,
		  Backward Compatible Broadcast Authentication Protocol for
		  CAN bus.pdf:pdf},
  keywords	= {authentication,broadcast,can bus,embedded
		  networks,symmetric cryptography},
  title		= {{CANAuth - A Simple , Backward Compatible Broadcast
		  Authentication Protocol for CAN bus}},
  year		= {2011}
}

@Article{	  hicks2010,
  abstract	= {The computer systems security arms race between attackers
		  and defenders has largely taken place in the domain of
		  software systems, but as hardware complexity and design
		  processes have evolved, novel and potent hardware-based
		  security threats are now possible. This paper presents a
		  hybrid hardware/software approach to defending against
		  malicious hardware. We propose BlueChip, a defensive
		  strategy that has both a design-time component and a
		  runtime component. During the design verification phase,
		  BlueChip invokes a new technique, unused circuit
		  identification (UCI), to identify suspicious
		  circuitry{\&}amp;{\#}x02014;those circuits not used or
		  otherwise activated by any of the design verification
		  tests. BlueChip removes the suspicious circuitry and
		  replaces it with exception generation hardware. The
		  exception handler software is responsible for providing
		  forward progress by emulating the effect of the exception
		  generating instruction in software, effectively providing a
		  detour around suspicious hardware. In our experiments,
		  BlueChip is able to prevent all hardware attacks we
		  evaluate while incurring a small runtime overhead.},
  author	= {Hicks, Matthew and Finnicum, Murph and King, Samuel T. and
		  Martin, M. M K and Smith, Jonathan M.},
  doi		= {10.1109/SP.2010.18},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Hicks et al. - Overcoming an untrusted computing base
		  Detecting and removing malicious hardware
		  automatically.pdf:pdf},
  isbn		= {9780769540351},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {159--172},
  title		= {{Overcoming an untrusted computing base: Detecting and
		  removing malicious hardware automatically}},
  year		= {2010}
}

@Article{	  hinrichs2009,
  abstract	= {We present FML, a declarative policy language for man-
		  aging the configuration of enterprise networks. FML was
		  designed to replace the many disparate configuration mech-
		  anisms traditionally used to enforce policies within the
		  enter- prise. These include ACLs, VLANs, NATs,
		  policy-routing, and proprietary admission control systems.
		  FML balances the desires to express policies naturally and
		  enforce policies efficiently. We have implemented FML and
		  have used it to manage multiple operational enterprise
		  networks for over a year.},
  author	= {Hinrichs, Timothy and Gude, Natasha and Casado, Martin and
		  Mitchell, John and Shenker, Scott},
  doi		= {10.1145/1592681.1592683},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Hinrichs et al. - Practical declarative network
		  management.pdf:pdf},
  isbn		= {9781605584430},
  issn		= {01464833},
  journal	= {Proceedings of the 1st ACM workshop on Research on
		  Enterprise Networking},
  keywords	= {network,performance,policy,security},
  pages		= {1--10},
  title		= {{Practical declarative network management}},
  url		= {http://dl.acm.org/citation.cfm?id=1592683},
  year		= {2009}
}

@Article{	  hiser2012,
  author	= {Hiser, Jason and Nguyen-Tuong, Anh and Co, Michele and
		  Hall, Matthew and Davidson, Jack W.},
  doi		= {10.1109/SP.2012.39},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Hiser et al. - ILR Where ’ d My Gadgets Go.pdf:pdf},
  isbn		= {978-1-4673-1244-8},
  journal	= {2012 IEEE Symposium on Security and Privacy},
  keywords	= {-randomization,Randomization, Exploit prevention,
		  Diversity, ASLR, Return-oriented-programming,
		  arc-injection,arc-injection,aslr,diversity,exploit
		  prevention,return-oriented-programming},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {571--585},
  title		= {{ILR: Where'd My Gadgets Go?}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6234437}
		  ,
  year		= {2012}
}

@Article{	  homescu2012,
  abstract	= {Return-oriented programming (ROP) has gained a lot of
		  popularity lately, as an attack against currently
		  imple-mented defenses in modern operating systems. Several
		  kinds of ROP-based attacks and anti-ROP defenses have been
		  proposed in recent years. The original attack tech-nique
		  depends on the existence of a hand-picked set of byte
		  sequences (called gadgets) in the program, while subsequent
		  approaches use complex scanners, which per-form semantic
		  analysis on the code to locate gadgets. The latter ones are
		  efficient at finding gadgets and build-ing an attack, but
		  incur a significant cost in time. We propose a ROP attack
		  technique, based on a hand-picked but flexible and
		  Turing-complete set of gadgets. One novelty in this
		  approach is the use of microgadgets, which are gadgets
		  restricted to 2 or 3 bytes in length. Our approach splits
		  gadgets into several classes of vary-ing sizes (from 1 to
		  more than 800). Only a single gadget from each class is
		  required for Turing-completeness. The short length of the
		  gadgets, as well as the large size of the classes, increase
		  the likelihood of finding all required gadgets. We also
		  describe an efficient scanner which locates these gadgets
		  in a given program. We then use this scanner on the
		  /usr/bin directories from several Linux distributions, to
		  show that many programs indeed contain a Turing-complete
		  set of microgadgets, which at-tackers can use to perform
		  arbitrary computations.},
  author	= {Homescu, Andrei and Stewart, Michael and Larsen, Per and
		  Brunthaler, Stefan and Franz, Michael},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Homescu et al. - Microgadgets Size Does Matter In
		  Turing-complete Return-oriented Programming.pdf:pdf},
  journal	= {USENIX Workshop on Offensive Technologies},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Microgadgets: Size Does Matter In Turing-complete
		  Return-oriented Programming}},
  year		= {2012}
}

@InProceedings{	  hoppe2008,
  abstract	= {The IT security of automotive systems is an evolving area
		  of research. To analyse the current situation and the
		  potentially growing tendency of arising threats we
		  performed several practical tests on recent automotive
		  technology. With a focus on automotive systems based on CAN
		  bus technology, this article summarises the results of four
		  selected tests performed on the control systems for the
		  window lift, warning light and airbag control system as
		  well as the central gateway. These results are supplemented
		  in this article by a classification of these four attack
		  scenarios using the established CERT taxonomy and an
		  analysis of underlying security vulnerabilities, and
		  especially, potential safety implications. With respect to
		  the results of these tests, in this article we further
		  discuss two selected countermeasures to address basic
		  weaknesses exploited in our tests. These are adaptations of
		  intrusion detection (discussing three exemplary detection
		  patterns) and IT-forensic measures (proposing proactive
		  measures based on a forensic model). This article discusses
		  both looking at the four attack scenarios introduced
		  before, covering their capabilities and restrictions. While
		  these reactive approaches are short-term measures, which
		  could already be added to today's automotive IT
		  architecture, long-term concepts also are shortly
		  introduced, which are mainly preventive but will require a
		  major redesign. Beneath a short overview on respective
		  research approaches, we discuss their individual
		  requirements, potential and restrictions. ?? 2010 Elsevier
		  Ltd.},
  author	= {Hoppe, Tobias and Kiltz, Stefan and Dittmann, Jana},
  booktitle	= {Proceedings of the International Conference on Computer
		  Safety, Reliability, and Security (SAFECOMP)},
  doi		= {10.1016/j.ress.2010.06.026},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Hoppe, Kiltz, Dittmann - Security threats to automotive CAN
		  networksPractical examples and selected short-term
		  countermeasures.pdf:pdf},
  isbn		= {3540876979},
  issn		= {09518320},
  keywords	= {Automotive IT,Automotive IT-forensics,Automotive intrusion
		  detection,Countermeasures,Interplay between security and
		  safety,Practical attack scenarios},
  number	= {1},
  pages		= {11--25},
  title		= {{Security threats to automotive CAN networksPractical
		  examples and selected short-term countermeasures}},
  volume	= {96},
  year		= {2008}
}

@Article{	  howard2003,
  author	= {Howard, Michael and Pincus, Jon and Wing, Jeanette M},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Howard, Pincus, Wing - Measuring Attack Surfaces.pdf:pdf},
  keywords	= {bugs at the code,for determining whether one,is
		  more,level,level or count vulnerability,rather than
		  count,reports at the system,respect to a fixed,secure than
		  another with,set of dimensions,version of a system,we
		  count,we propose a metric},
  mendeley-groups={6 - Application/Attack surface reduction},
  pages		= {24},
  title		= {{Measuring Attack Surfaces}},
  year		= {2003}
}

@Article{	  howell2013,
  abstract	= {We envision a future where Web, mobile, and desktop
		  applications are delivered as isolated, complete software
		  stacks to a minimal, secure client host. This shift imbues
		  app vendors with full autonomy to maintain their apps’
		  integrity. Achieving this goal requires shifting complex
		  behavior out of the client platform and into the vendors’
		  isolated apps. We ported rich, interactive POSIX apps, such
		  as Gimp and Inkscape, to a spartan host platform. We
		  describe this effort in sufficient detail to support
		  reproducibility.},
  author	= {Howell, Jon and Parno, Bryan and Douceur, John R},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Howell, Parno, Douceur - How to Run POSIX Apps in a Minimal
		  Picoprocess.pdf:pdf},
  isbn		= {978-1-931971-01-0},
  journal	= {2013 USENIX Annual Technical Conference},
  pages		= {321--332},
  title		= {{How to Run POSIX Apps in a Minimal Picoprocess}},
  url		= {https://www.usenix.org/conference/atc13/technical-sessions/papers/howell}
		  ,
  year		= {2013}
}

@Article{	  hruby2012,
  abstract	= {For many years, multiserver1 operating systems have been
		  demonstrating, by their design, high dependability and
		  reliability. However, the design has inherent performance
		  implications which were not easy to overcome. Until now the
		  context switching and kernel involvement in the message
		  passing was the performance bottleneck for such systems to
		  get broader acceptance beyond niche domains. In contrast to
		  other areas of software development where fitting the
		  software to the parallelism is difficult, the new multicore
		  hardware is a great match for the multiserver systems. We
		  can run individual servers on different cores. This opens
		  more room for further decomposition of the existing servers
		  and thus improving dependability and live-updatability. We
		  discuss in general the implications for the multiserver
		  systems design and cover in detail the implementation and
		  evaluation of a more dependable networking stack. We split
		  the single stack into multiple servers which run on
		  dedicated cores and communicate without kernel involvement.
		  We think that the performance problems that have dogged
		  multiserver operating systems since their inception should
		  be reconsidered: it is possible to make multiserver systems
		  fast on multicores.},
  author	= {Hruby, Tomas and Vogt, Dirk and Bos, Herbert and
		  Tanenbaum, Andrew S.},
  doi		= {10.1109/DSN.2012.6263933},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Hruby et al. - Keep net working - On a dependable and fast
		  networking stack.pdf:pdf},
  isbn		= {9781467316248},
  issn		= {1530-0889},
  journal	= {Proceedings of the International Conference on Dependable
		  Systems and Networks},
  keywords	= {Computer network reliability,Operating
		  systems,Reliability,System performance},
  title		= {{Keep net working - On a dependable and fast networking
		  stack}},
  year		= {2012}
}

@InProceedings{	  huang:webapp_stat_analysis,
  annote	= {PHP Static Analysis},
  author	= {Huang, Y.-W. and Yu, F and Hang, C and Tsai, C.-H. and
		  Lee, D and Kuo, S.-Y.},
  booktitle	= {Proceedings of the International World Wide Web Conference
		  (WWW)},
  month		= {may},
  pages		= {40--52},
  title		= {{Securing Web Application Code by Static Analysis and
		  Runtime Protection}},
  year		= {2004}
}

@Article{	  huffmire2007,
  abstract	= {Blurring the line between software and hardware,
		  reconfigurable devices strike a balance between the raw
		  high speed of custom silicon and the post-fabrication
		  flexibility of general-purpose processors. While this
		  flexibility is a boon for embedded system developers, who
		  can now rapidly prototype and deploy solutions with
		  performance approaching custom designs, this results in a
		  system development methodology where functionality is
		  stitched together from a variety of "soft IP cores," often
		  provided by multiple vendors with different levels of
		  trust. Unlike traditional software where resources are
		  managed by an operating system, soft IP cores necessarily
		  have very fine grain control over the underlying hardware.
		  To address this problem, the embedded systems community
		  requires novel security primitives which address the
		  realities of modern reconfigurable hardware. We propose an
		  isolation primitive, moats and drawbridges, that are built
		  around four design properties: logical isolation,
		  interconnect traceability, secure reconfigurable broadcast,
		  and configuration scrubbing. Each of these is a fundamental
		  operation with easily understood formal properties, yet
		  maps cleanly and efficiently to a wide variety of
		  reconfigurable devices. We carefully quantify the required
		  overheads on real FPGAs and demonstrate the utility of our
		  methods by applying them to the practical problem of memory
		  protection.},
  author	= {Huffmire, Ted and Brotherton, Brett and Wang, Gang and
		  Sherwood, Timothy and Kastner, Ryan and Levin, Timothy and
		  Nguyen, Thuy and Irvine, Cynthia},
  doi		= {10.1109/SP.2007.28},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Huffmire et al. - Moats and drawbridges An isolation
		  primitive for reconfigurable hardware based
		  systems.pdf:pdf},
  isbn		= {0769528481},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {281--295},
  title		= {{Moats and drawbridges: An isolation primitive for
		  reconfigurable hardware based systems}},
  year		= {2007}
}

@Article{	  huffmire2008,
  abstract	= {FPGAs combine the programmability of processors with the
		  performance of custom hardware. As they become more common
		  in critical embedded systems, new techniques are necessary
		  to manage security in FPGA designs. This article discusses
		  FPGA security problems and current research on
		  reconfigurable devices and security, and presents security
		  primitives and a component architecture for building highly
		  secure systems on FPGAs.},
  author	= {Huffmire, Ted and Brotherton, Brett and Sherwood, Timothy
		  and Kastner, Ryan and Levin, Timothy and Nguyen, Thuy D.
		  and Irvine, Cynthia},
  doi		= {10.1109/MDT.2008.166},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Huffmire et al. - Managing security in FPGA-based embedded
		  systems.pdf:pdf},
  issn		= {07407475},
  journal	= {IEEE Design and Test of Computers},
  keywords	= {Cryptography,Embedded system,Field programmable gate
		  arrays,Hardware,IP networks,Magnetic cores,Security},
  number	= {6},
  pages		= {590--598},
  title		= {{Managing security in FPGA-based embedded systems}},
  volume	= {25},
  year		= {2008}
}

@Article{	  hund2009,
  abstract	= {Protecting the kernel of an operating system against
		  attacks, especially injection of malicious code, is an
		  important factor for implementing secure operating systems.
		  Several kernel integrity protection mechanism were proposed
		  recently that all have a particular shortcoming: They
		  cannot protect against attacks in which the attacker
		  re-uses existing code within the kernel to perform
		  malicious computations. In this paper, we present the
		  design and implementation of a system that fully automates
		  the process of constructing instruction sequences that can
		  be used by an attacker for malicious computations. We
		  evaluate the system on different commodity operating
		  systems and show the portability and universality of our
		  approach. Finally, we describe the implementation of a
		  practical attack that can bypass existing kernel integrity
		  protection mechanisms.},
  author	= {Hund, Ralf and Freiling, Felix C},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Hund, Freiling - Return-Oriented Rootkits Bypassing Kernel
		  Code Integrity Protection Mechanisms.pdf:pdf},
  journal	= {Usenix Sec},
  pages		= {383--398},
  title		= {{Return-Oriented Rootkits : Bypassing Kernel Code
		  Integrity Protection Mechanisms}},
  url		= {http://dl.acm.org/citation.cfm?id=1855792},
  year		= {2009}
}

@Article{	  j2014,
  author	= {J, Gori Mohamed and Mohideen, M Mohammed and N, Shahira
		  Banu},
  file		= {::},
  number	= {2},
  pages		= {2--5},
  title		= {{E-Mail Phishing - An open threat to everyone}},
  volume	= {4},
  year		= {2014}
}

@Article{	  jana2011,
  abstract	= {TxBox is a new system for sand boxing untrusted
		  applications. It speculatively executes the application in
		  a system transaction, allowing security checks to be
		  parallelized and yielding significant performance gains for
		  techniques such as on-access anti-virus scanning. TxBox is
		  not vulnerable to TOCTTOU attacks and incorrect mirroring
		  of kernel state. Furthermore, TxBox supports automatic
		  recovery: if a violation is detected, the sand boxed
		  program is terminated and all of its effects on the host
		  are rolled back. This enables effective enforcement of
		  security policies that span multiple system calls.},
  author	= {Jana, Suman and Porter, Donald E. and Shmatikov, Vitaly},
  doi		= {10.1109/SP.2011.33},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/05958038.pdf:pdf}
		  ,
  isbn		= {9780769544021},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {329--344},
  title		= {{TxBox: Building secure, efficient sandboxes with system
		  transactions}},
  year		= {2011}
}

@Article{	  jayaraman2009,
  abstract	= {We present jFuzz, a automatic testing tool for Java
		  programs. jFuzz is a concolic whitebox fuzzer, built on the
		  NASA Java PathFinder, an explicit-state Java model-checker,
		  and a framework for developing reliability and analysis
		  tools for Java. Starting from a seed input, jFuzz
		  automatically and systematically generates inputs that
		  exercise new program paths. jFuzz uses a combination of
		  concrete and symbolic execution, and constraint solving.
		  Time spent on solving constraints can be significant. We
		  implemented a novel optimization, name-independent caching,
		  that aggressively normalizes the constraints to so reduced
		  the number of calls to the constraint solver. We present
		  preliminary results due to this optimization, and
		  demonstrate the effectiveness of jFuzz in creating good
		  test inputs. jFuzz is intended to be a research testbed for
		  investigating new testing and analysis techniques based on
		  concrete and symbolic execution. The source code of jFuzz
		  is available as part of theNASA Java PathFinder. 1},
  author	= {Jayaraman, Karthick and Harvison, David and Ganesh, Vijay
		  and Kiezun, Adam},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Jayaraman et al. - jFuzz A Concolic Whitebox Fuzzer for
		  Java.pdf:pdf},
  journal	= {NASA Formal Methods},
  pages		= {121--125},
  title		= {{jFuzz: A Concolic Whitebox Fuzzer for Java.}},
  year		= {2009}
}

@Article{	  jiang2012,
  abstract	= {In this paper we consider distributed real-time embedded
		  systems in which confidentiality of the internal
		  communication is critical. We present an approach to
		  efficiently implement cryptographic algorithms by using
		  hardware/software co-design techniques. The objective is to
		  find the minimal hardware overhead and corresponding
		  process mapping for encryption and decryption tasks of the
		  system, so that the confidentiality requirements for the
		  messages transmitted over the internal communication bus
		  are fulfilled, and time constraints are satisfied. Towards
		  this, we formulate the optimization problems using
		  Constraint Logic Programming (CLP), which returns optimal
		  solutions. However, CLP executions are computationally
		  expensive and, hence, efficient heuristics are proposed as
		  an alternative. Extensive experiments demonstrate the
		  efficiency of the proposed heuristic approaches.},
  author	= {Jiang, Ke and Eles, P and Peng, Zebo},
  doi		= {10.1109/DATE.2012.6176633},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Jiang, Eles, Peng - Co-design techniques for distributed
		  real-time embedded systems with communication security
		  constraints.pdf:pdf},
  isbn		= {9783981080186},
  issn		= {1530-1591},
  journal	= {Design, Automation Test in Europe Conference Exhibition
		  (DATE), 2012},
  keywords	= {constraint handling;cryptography;embedded systems;},
  pages		= {947--952},
  title		= {{Co-design techniques for distributed real-time embedded
		  systems with communication security constraints}},
  year		= {2012}
}

@Article{	  jin2008,
  abstract	= {Trusted IC design is a recently emerged topic since
		  fabrication factories are moving worldwide in order to
		  reduce cost. In order to get a low-cost but effective
		  hardware trojan detection method to complement traditional
		  testing methods, a new behavior-oriented category method is
		  proposed to divide trojans into two categories: explicit
		  payload trojan and implicit payload trojan. This
		  categorization method makes it possible to construct trojan
		  models and then lower the cost of testing. Path delays of
		  nominal chips are collected to construct a series of
		  fingerprints, each one representing one aspect of the total
		  characteristics of a genuine design. Chips are validated by
		  comparing their delay parameters to the fingerprints. The
		  comparison of path delays makes small trojan circuits
		  significant from a delay point of view. The
		  experimentpsilas results show that the detection rate on
		  explicit payload trojans is 100{\%}, while this method
		  should be developed further if used to detect implicit
		  payload trojans.},
  author	= {Jin, Yier and Makris, Yiorgos},
  doi		= {10.1109/HST.2008.4559049},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Jin, Makris - Hardware Trojan detection using path delay
		  fingerprint.pdf:pdf},
  isbn		= {9781424424016},
  journal	= {2008 IEEE International Workshop on Hardware-Oriented
		  Security and Trust, HOST},
  pages		= {51--57},
  title		= {{Hardware Trojan detection using path delay fingerprint}},
  year		= {2008}
}

@Article{	  jin2010,
  abstract	= {Due to the globalization of the Integrated Circuit (IC)
		  manufacturing industry, hardware Trojans constitute an
		  increasingly probable threat to both commercial and
		  military applications. As traditional testing methods fall
		  short in finding hardware Trojans, several specialized
		  detection methods have surfaced. To facilitate research in
		  this area and embed internal barriers to prevent Trojan
		  attacks both at the design level and at the manufacturing
		  level, we propose a Design-for-Trojan-Test (DFTT)
		  methodology. DFTT is based on one key principle: increase
		  the complexity for hardware Trojan attackers, thereby
		  making successful hardware Trojan-based attacks extremely
		  difficult to accomplish. A DFTT tool is also developed to
		  automate the hardening process. The effectiveness of our
		  Trojan prevention method is demonstrated on the Trivium
		  encryption core.},
  author	= {Jin, Yier and Kupp, Nathan and Makris, Yiorgos},
  doi		= {10.1109/ICECS.2010.5724725},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Jin, Kupp, Makris - DFTT Design for Trojan test.pdf:pdf},
  isbn		= {9781424481576},
  journal	= {2010 IEEE International Conference on Electronics,
		  Circuits, and Systems, ICECS 2010 - Proceedings},
  pages		= {1168--1171},
  title		= {{DFTT: Design for Trojan test}},
  year		= {2010}
}

@Article{	  jin2010a,
  abstract	= {The article studies the problem of hardware Trojans in
		  wireless cryptographic ICs. The objective is to design
		  Trojans to leak secret information through the wireless
		  channel. The authors investigate challenges related to
		  detection for such Trojans and propose using statistical
		  analysis of the side-channel signals to help detect them.},
  author	= {Jin, Yier and Makris, Yiorgos},
  doi		= {10.1109/MDT.2010.21},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Jin, Makris - Hardware Trojans in wireless cryptographic
		  ICs.pdf:pdf},
  issn		= {07407475},
  journal	= {IEEE Design and Test of Computers},
  number	= {1},
  pages		= {26--35},
  title		= {{Hardware Trojans in wireless cryptographic ICs}},
  volume	= {27},
  year		= {2010}
}

@Article{	  jin2011,
  abstract	= {Although cloud computing has emerged as a promising future
		  computing model, security concerns due to malicious tenants
		  have been deterring its fast adoption. In cloud computing,
		  multiple tenants may share physical systems by using
		  virtualization techniques},
  author	= {Jin, Seongwook and Ahn, Jeongseob and Cha, Sanghoon and
		  Huh, Jaehyuk},
  doi		= {10.1145/2155620.2155652},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Jin et al. - Architectural Support for Secure
		  Virtualization under a Vulnerable Hypervisor.pdf:pdf},
  isbn		= {9781450310536},
  issn		= {10724451},
  journal	= {Proceedings of the 44th Annual IEEE/ACM International
		  Symposium on Microarchitecture - MICRO-44 '11},
  mendeley-groups={4 - Hypervisor},
  pages		= {272},
  title		= {{Architectural support for secure virtualization under a
		  vulnerable hypervisor}},
  url		= {http://dl.acm.org/citation.cfm?doid=2155620.2155652},
  year		= {2011}
}

@Article{	  jin2011a,
  abstract	= {In conventional virtualized systems, a hypervisor can
		  access the memory pages of guest virtual machines without
		  any restriction, as the hypervisor has a full control over
		  the address translation mechanism. In this paper, we
		  propose Secure MMU, a hardware-based mechanism to isolate
		  the memory of guest virtual machines from unauthorized
		  accesses even from the hypervisor. The proposed mechanism
		  extends the current nested paging support for
		  virtualization with a small hardware cost. With Secure MMU,
		  the hypervisor can flexibly allocate physical memory pages
		  to virtual machines for resource management, but update
		  nested page tables only through the secure hardware
		  mechanism, which verifies each mapping change. With the
		  hardware-rooted memory isolation among virtual machines,
		  the memory of a virtual machine in cloud computing can be
		  securely protected from a compromised hypervisor or
		  co-tenant virtual machines.},
  author	= {Jin, Seongwook and Huh, Jaehyuk},
  doi		= {10.1109/DSNW.2011.5958816},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Jin, Huh - Secure MMU Architectural Support for Memory
		  Isolation among Virtual Machines.pdf:pdf},
  isbn		= {9781457703751},
  journal	= {Proceedings of the International Conference on Dependable
		  Systems and Networks},
  keywords	= {Cryptography,Hardware,Memory management,Program
		  processors,Registers,Virtual machine monitors,Virtual
		  machining,address translation mechanism,authorisation,cloud
		  computing,cotenant virtual machine,guest virtual
		  machines,hardware rooted memory
		  isolation,hypervisor,mapping change verification,nested
		  paging support,physical memory page allocation,resource
		  allocation,resource management,secure MMU,secure hardware
		  mechanism,storage allocation,unauthorized access,virtual
		  machines,virtual storage,virtualisation,virtualization},
  mendeley-groups={4 - Hypervisor},
  pages		= {217--222},
  title		= {{Secure MMU: Architectural support for memory isolation
		  among virtual machines}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5958816}
		  ,
  year		= {2011}
}

@InProceedings{	  jin2014,
  author	= {Jin, Yier and Sullivan, Dean},
  booktitle	= {Design, Automation and Test in Europe Conference and
		  Exhibition (DATE)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Jin, Sullivan - Real-Time Trust Evaluation in Integrated
		  Circuits.pdf:pdf},
  isbn		= {9783981537024},
  title		= {{Real-Time Trust Evaluation in Integrated Circuits}},
  year		= {2014}
}

@Article{	  jing2014,
  author	= {Jing, Yiming and Zhao, Ziming and Ahn, Gail-Joon and Hu,
		  Hongxin},
  doi		= {10.1145/2664243.2664250},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/p216-jing.pdf:pdf}
		  ,
  isbn		= {9781450330053},
  journal	= {Proceedings of the 30th Annual Computer Security
		  Applications Conference on - ACSAC '14},
  keywords	= {Android,emulator,malware},
  pages		= {216--225},
  title		= {{Morpheus}},
  url		= {http://dl.acm.org/citation.cfm?id=2664243.2664250},
  year		= {2014}
}

@Article{	  jones2006,
  abstract	= {In a virtualized environment, the VMM is the system's
		  primary resource manager. Some services usually implemented
		  at the OS layer, like I/O scheduling or certain kinds of
		  security monitoring, are therefore more naturally
		  implemented inside the VMM. Implementing such services at
		  the VMM layer can be complicated by the lack of OS and
		  application-level knowledge within a VMM. This paper
		  describes techniques that can be used by a VMM to
		  independently overcome part of the "semantic gap"
		  separating it from the guest operating systems it supports.
		  These techniques enable the VMM to track the existence and
		  activities of operating system processes. Antfarm is an
		  implementation of these techniques that works without
		  detailed knowledge of a guest's internal architecture or
		  implementation. An evaluation of Antfarm for two
		  virtualization environments and two operating systems shows
		  that it can accurately infer process events while incurring
		  only a small 2.5{\%} runtime overhead in the worst case. To
		  demonstrate the practical benefits of process information
		  in a VMM we implement an anticipatory disk scheduler at the
		  VMM level. This case study shows that significant disk
		  throughput improvements are possible in a virtualized
		  environment by exploiting process information within a
		  VMM.},
  annote	= {Looks to be first paper on virtual machine introspection},
  author	= {Jones, Stephen T. and Arpaci-dusseau, Andrea C. and
		  Arpaci-dusseau, Remzi H.},
  doi		= {http://portal.acm.org/citation.cfm?id=1267359.1267360},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Jones, Arpaci-dusseau, Arpaci-dusseau - Antfarm Tracking
		  Processes in a Virtual Machine Environment.pdf:pdf},
  journal	= {Proceedings of the USENIX Annual Technical Conference -
		  USENIX'06},
  pages		= {1--14},
  title		= {{Antfarm: Tracking Processes in a Virtual Machine
		  Environment}},
  year		= {2006}
}

@Article{	  jones2008,
  abstract	= {Use of stealth rootkit techniques to hide long-lived
		  malicious processes is a current and alarming security
		  issue. In this paper, we describe, implement, and evaluate
		  a novel VMM-based hidden process detection and
		  identification service called Lycosid that is based on the
		  cross-view validation principle. Like previous VMM-based
		  security services, Lycosid benefits from its protected
		  location. In contrast top revious VMM-based hidden process
		  detectors, Lycosid obtains guest process information
		  implicitly. Using implicit information reduces its
		  susceptibility to guest evasion attacks and decouples it
		  from specific guest operating system versions and patch
		  levels. The implicit information Lycosid depends on,
		  however, can be noisy and unreliable. Statistical inference
		  techniques like hypothesis testing and line arregression
		  allow Lycosid to trade time for accuracy. Despite low
		  quality inputs, Lycosid provides a robust, highly accurate
		  service usable even insecurity environments where the
		  consequences for wrong decisions can behig.},
  author	= {Jones, Stephen T. and Arpaci-Dusseau, Andrea C. and
		  Arpaci-Dusseau, Remzi H.},
  doi		= {10.1145/1346256.1346269},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Jones, Arpaci-Dusseau, Arpaci-Dusseau - VMM-based hidden
		  process detection and identification using
		  Lycosid.pdf:pdf},
  isbn		= {9781595937964},
  journal	= {Proceedings of the fourth ACM SIGPLAN/SIGOPS international
		  conference on Virtual execution environments - VEE '08},
  keywords	= {4,6,d,design,inference,measurement,security,security and
		  protec-,virtual machine},
  pages		= {91},
  title		= {{VMM-based hidden process detection and identification
		  using Lycosid}},
  url		= {http://portal.acm.org/citation.cfm?doid=1346256.1346269},
  year		= {2008}
}

@InProceedings{	  jovanovic06:pixy-short,
  address	= {New York, NY, USA},
  author	= {Jovanovic, Nenad and Kruegel, Christopher and Kirda,
		  Engin},
  booktitle	= {IN 2006 IEEE SYMPOSIUM ON SECURITY AND PRIVACY},
  doi		= {http://doi.acm.org/10.1145/1134744.1134751},
  isbn		= {1-59593-374-3},
  keywords	= {PHP,alias analysis,cross-site scripting,data flow
		  analysis,program analysis,scripting languages
		  security,static analysis,web application security},
  month		= {may},
  pages		= {258--263},
  publisher	= {ACM},
  series	= {PLAS '06},
  title		= {{Pixy: A Static Analysis Tool for Detecting Web
		  Application Vulnerabilities (Short Paper)}},
  url		= {http://doi.acm.org/10.1145/1134744.1134751},
  year		= {2006}
}

@InProceedings{	  jovanovic2006a,
  author	= {Jovanovic, Nenad and Kruegel, Christopher and Kirda,
		  Engin},
  booktitle	= {Proceedings of the 2006 workshop on Programming languages
		  and analysis for security},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Jovanovic, Kruegel, Kirda - Precise alias analysis for
		  static detection of web application
		  vulnerabilities.pdf:pdf},
  isbn		= {1595933743},
  keywords	= {alias analysis,cross-site scripting,data flow
		  analysis,gram analysis,php,pro-,rity,scripting languages
		  secu-,static analysis,web application security},
  title		= {{Precise alias analysis for static detection of web
		  application vulnerabilities}},
  url		= {http://dl.acm.org/citation.cfm?id=1134751},
  year		= {2006}
}

@Article{	  jung2004,
  abstract	= { Attackers routinely perform random portscans of IP
		  addresses to find vulnerable servers to compromise. Network
		  intrusion detection systems (NIDS) attempt to detect such
		  behavior and flag these portscanners as malicious. An
		  important need in such systems is prompt response: the
		  sooner a NIDS detects malice, the lower the resulting
		  damage. At the same time, a NIDS should not falsely
		  implicate benign remote hosts as malicious. Balancing the
		  goals of promptness and accuracy in detecting malicious
		  scanners is a delicate and difficult task. We develop a
		  connection between this problem and the theory of
		  sequential hypothesis testing and show that one can model
		  accesses to local IP addresses as a random walk on one of
		  two stochastic processes, corresponding respectively to the
		  access patterns of benign remote hosts and malicious ones.
		  The detection problem then becomes one of observing a
		  particular trajectory and inferring from it the most likely
		  classification for the remote host. We use this insight to
		  develop TRW (Threshold Random Walk), an online detection
		  algorithm that identifies malicious remote hosts. Using an
		  analysis of traces from two qualitatively different sites,
		  we show that TRW requires a much smaller number of
		  connection attempts (4 or 5 in practice) to detect
		  malicious activity compared to previous schemes, while also
		  providing theoretical bounds on the low (and configurable)
		  probabilities of missed detection and false alarms. In
		  summary, TRW performs significantly faster and also more
		  accurately than other current solutions.},
  author	= {Jung, Jaeyeon Jung Jaeyeon and Paxson, V. and a.W. Berger
		  and Balakrishnan, H.},
  doi		= {10.1109/SECPRI.2004.1301325},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Jung et al. - Fast portscan detection using sequential
		  hypothesis testing.pdf:pdf},
  isbn		= {0-7695-2136-3},
  issn		= {1081-6011},
  journal	= {IEEE Symposium on Security and Privacy, 2004. Proceedings.
		  2004},
  pages		= {1--15},
  title		= {{Fast portscan detection using sequential hypothesis
		  testing}},
  year		= {2004}
}

@Article{	  kadav2012,
  abstract	= {Device drivers are the single largest contributor to
		  operating-system kernel code with over 5 million lines of
		  code in the Linux kernel, and cause significant complexity,
		  bugs and development costs. Recent years have seen a flurry
		  of research aimed at improving the reliability and
		  simplifying the development of drivers. However, little is
		  known about what constitutes this huge body of code beyond
		  the small set of drivers used for research. In this paper,
		  we study the source code of Linux drivers to understand
		  what drivers actually do, how current research applies to
		  them and what opportunities exist for future research. We
		  determine whether assumptions made by most driver research,
		  such as that all drivers belong to a class, are indeed
		  true. We also analyze driver code and abstractions to
		  determine whether drivers can benefit from code
		  re-organization or hardware trends. We develop a set of
		  static-analysis tools to analyze driver code across various
		  axes. Broadly, our study looks at three aspects of driver
		  code (i) what are the characteristics of driver code
		  functionality and how applicable is driver research to all
		  drivers, (ii) how do drivers interact with the kernel,
		  devices, and buses, and (iii) are there similarities that
		  can be abstracted into libraries to reduce driver size and
		  complexity? We find that many assumptions made by driver
		  research do not apply to all drivers. At least 44{\%} of
		  drivers have code that is not captured by a class
		  definition, 28{\%} of drivers support more than one device
		  per driver, and 15{\%} of drivers do significant
		  computation over data. From the driver interactions study,
		  we find USB bus offers an efficient bus interface with
		  significant standardized code and coarse-grained access,
		  ideal for executing drivers in isolation. We also find that
		  drivers for different buses and classes have widely varying
		  levels of device interaction, which indicates that the cost
		  of isolation will vary by class. Finally, from our driver
		  similarity study, we find 8{\%} of all driver code is
		  substantially similar to code elsewhere and may be removed
		  with new abstractions or libraries.},
  author	= {Kadav, Asim and Swift, Michael M.},
  doi		= {10.1145/2189750.2150987},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Kadav, Swift - Understanding modern device
		  drivers.pdf:pdf},
  isbn		= {9781450307598},
  issn		= {01635964},
  journal	= {ACM SIGARCH Computer Architecture News},
  keywords	= {a,a driver,communicating with an increasing,device
		  drivers,each of which requires,for example,have tens of
		  devices,including keyboard,measurement,modern computer
		  systems are,modern desktop pc may,number of devices},
  number	= {1},
  pages		= {87},
  title		= {{Understanding modern device drivers}},
  volume	= {40},
  year		= {2012}
}

@Article{	  kamara2003,
  abstract	= {Firewalls protect a trusted network from an untrusted
		  network by filtering traffic according to a specified
		  security policy. A diverse set of firewalls is being used
		  today. As it is infeasible to examine and test each
		  firewall for all possible potential problems, a taxonomy is
		  needed to understand firewall vulnerabilities in the
		  context of firewall operations. This paper describes a
		  novel methodology for analyzing vulnerabilities in Internet
		  firewalls. A firewall vulnerability is defined as an error
		  made during firewall design, implementation, or
		  configuration, that can be exploited to attack the trusted
		  network that the firewall is supposed to protect. We
		  examine firewall internals, and cross-reference each
		  firewall operation with causes and effects of weaknesses in
		  that operation, analyzing twenty reported problems with
		  available firewalls. The result of our analysis is a set of
		  matrices that illustrate the distribution of firewall
		  vulnerability causes and effects over firewall operations.
		  These matrices are useful in avoiding and detecting
		  unforeseen problems during both firewall implementation and
		  firewall testing. Two case studies of Firewall-1 and Raptor
		  illustrate our methodology.},
  author	= {Kamara, Seny and Fahmy, Sonia and Schultz, Eugene and
		  Kerschbaum, Florian and Frantzen, Michael},
  doi		= {10.1016/S0167-4048(03)00310-9},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2003 -
		  Kamara et al. - Analysis of vulnerabilities in internet
		  firewalls.pdf:pdf},
  isbn		= {0167-4048},
  issn		= {01674048},
  journal	= {Computers and Security},
  keywords	= {Firewall testing,Firewall vulnerability analysis,Internet
		  firewalls},
  number	= {3},
  pages		= {214--232},
  title		= {{Analysis of vulnerabilities in internet firewalls}},
  volume	= {22},
  year		= {2003}
}

@Article{	  kamp2000,
  abstract	= {KW00},
  author	= {Kamp, Poul-henning and Watson, Robert N. M.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2000 -
		  Kamp, Watson - Jails Confining the omnipotent
		  root.pdf:pdf},
  journal	= {Proceeding of the 2nd International System Administration
		  and Networking Conference},
  pages		= {3--14},
  title		= {{Jails : Confining the omnipotent root}},
  year		= {2000}
}

@Article{	  kantola2012,
  annote	= {Automatic reduction in attack surface of legacy Android
		  application.},
  author	= {Kantola, David and Chin, Erika and He, Warren and Wagner,
		  David},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Kantola et al. - Reducing Attack Surfaces for
		  Intra-Application Communication in Android.pdf:pdf},
  isbn		= {9781450316668},
  journal	= {SPSM},
  keywords	= {android,message passing,mobile phone security},
  mendeley-groups={6 - Application/Attack surface reduction},
  title		= {{Reducing Attack Surfaces for Intra-Application
		  Communication in Android}},
  year		= {2012}
}

@Article{	  karger1991,
  author	= {Karger, Paul A. and Zurko, Mary Ellen and Bonin, Douglas
		  W. and Mason, Andrew H. and Kahn, Clifford E.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1991 -
		  Karger et al. - A Retrospective on the VAX VMM Security
		  Kernel.pdf:pdf},
  journal	= {IEEE Transactions on Software Engineering},
  title		= {{A Retrospective on the VAX VMM Security Kernel}},
  volume	= {17},
  year		= {1991}
}

@Article{	  kauer2007,
  abstract	= {In this paper we describe bugs and ways to attack trusted
		  computing systems based on a static root of trust such as
		  Microsoft's Bitlocker. We propose to use the dynamic root
		  of trust feature of newer x86 processors as this shortens
		  the trust chain, can minimize the Trusted Computing Base of
		  applications and is less vulnerable to TPM and BIOS
		  attacks. To support our claim we implemented the Open
		  Secure LOader (OSLO), the first publicly available
		  bootloader based on AMDs skinit instruction.},
  author	= {Kauer, Bernhard},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Kauer - OSLO improving the security of trusted
		  computing.pdf:pdf},
  isbn		= {111-333-5555-77-9},
  journal	= {Proceedings of 16th USENIX Security Symposium on USENIX
		  Security Symposium},
  pages		= {16:1----16:9},
  title		= {{OSLO: improving the security of trusted computing}},
  year		= {2007}
}

@Article{	  kayaalp2012,
  abstract	= {Code reuse attacks (CRAs) are recent security exploits
		  that allow attackers to execute arbitrary code on a
		  compromised machine. CRAs, exemplified by return-oriented
		  and jump-oriented programming approaches, reuse fragments
		  of the library code, thus avoiding the need for explicit
		  injection of attack code on the stack. Since the executed
		  code is reused existing code, CRAs bypass current hardware
		  and software security measures that prevent execution from
		  data or stack regions of memory. While software-based full
		  control flow integrity (CFI) checking can protect against
		  CRAs, it includes significant overhead, involves
		  non-trivial effort of constructing a control flow graph,
		  relies on proprietary tools and has potential
		  vulnerabilities due to the presence of unintended branch
		  instructions in architectures such as ×86 - those branches
		  are not checked by the software CFI. We propose branch
		  regulation (BR), a lightweight hardware-supported
		  protection mechanism against the CRAs that addresses all
		  limitations of software CFI. BR enforces simple control
		  flow rules in hardware at the function granularity to
		  disallow arbitrary control flow transfers from one function
		  into the middle of another function. This prevents common
		  classes of CRAs without the complexity and run-time
		  overhead of full CFI enforcement. BR incurs a slowdown of
		  about 2{\%} and increases the code footprint by less than
		  1{\%} on the average for the SPEC 2006 benchmarks.},
  author	= {Kayaalp, Mehmet and Ozsoy, Meltem and Abu-Ghazaleh, Nael
		  and Ponomarev, Dmitry},
  doi		= {10.1109/ISCA.2012.6237009},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Kayaalp et al. - Branch Regulation Low-Overhead Protection
		  from Code Reuse Attacks.pdf:pdf},
  isbn		= {978-1-4673-0476-4},
  issn		= {1063-6897},
  journal	= {2012 39th Annual International Symposium on Computer
		  Architecture (ISCA)},
  keywords	= {Benchmark testing,CRA bypass current hardware,CRA bypass
		  current software
		  security,Hardware,Libraries,Monitoring,Programming,Security,Software,arbitrary
		  code,branch regulation,code reuse attacks,control flow
		  graph,executed code,graph theory,jump-oriented programming
		  approach,low-overhead protection,return-oriented
		  programming approach,security of data,software-based full
		  control flow integrity},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {94--105},
  title		= {{Branch regulation: Low-overhead protection from code
		  reuse attacks}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6237009}
		  ,
  year		= {2012}
}

@InProceedings{	  kie\.zun2009,
  address	= {Vancouver, BC, Canada},
  author	= {Kie{\{}$\backslash$.z{\}}un, Adam and Guo, Philip J. and
		  Jayaraman, Karthick and Ernst, Michael D.},
  booktitle	= {ICSE'09, Proceedings of the 31st International Conference
		  on Software Engineering},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Kie{\{}.z{\}}un et al. - Automatic creation of SQL
		  injection and cross-site scripting attacks.pdf:pdf},
  title		= {{Automatic creation of SQL injection and cross-site
		  scripting attacks}},
  url		= {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=5070521}
		  ,
  year		= {2009}
}

@InProceedings{	  kim2012scalable,
  title		= {A scalable distributed concolic testing approach: An
		  empirical evaluation},
  author	= {Kim, Moonzoo and Kim, Yunho and Rothermel, Gregg},
  booktitle	= {Software Testing, Verification and Validation (ICST), 2012
		  IEEE Fifth International Conference on},
  pages		= {340--349},
  year		= {2012},
  organization	= {IEEE}
}

@Article{	  king2008,
  abstract	= {Hidden malicious circuits provide an attacker with a
		  stealthy attack vector. As they occupy a layer below the
		  entire software stack, malicious circuits can bypass
		  traditional defensive techniques. Yet current work on
		  trojan circuits considers only simple},
  author	= {King, St and Tucek, Joseph and Cozzie, A and Grier, Chris
		  and Jiang, Weihang and Zhou, Y},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  King et al. - Designing and Implementing Malicious
		  Hardware.pdf:pdf},
  journal	= {Leet},
  pages		= {1--18},
  title		= {{Designing and Implementing Malicious Hardware}},
  url		= {https://www.usenix.org/legacy/events/leet08/tech/full{\_}papers/king/king{\_}html/}
		  ,
  year		= {2008}
}

@Article{	  kivity2014,
  author	= {Kivity, Avi and Laor, Dor and Costa, Glauber and Enberg,
		  Pekka},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Kivity et al. - OSv—Optimizing the Operating System for
		  Virtual Machines.pdf:pdf},
  isbn		= {9781931971102},
  journal	= {Proceedings of the 2014 USENIX Annual Technical
		  Conference},
  pages		= {61--72},
  title		= {{OSv—Optimizing the Operating System for Virtual
		  Machines}},
  url		= {https://www.usenix.org/system/files/conference/atc14/atc14-paper-kivity.pdf}
		  ,
  year		= {2014}
}

@Article{	  kleberger2011,
  abstract	= {In this paper, we briefly survey the research with respect
		  to the security of the connected car, and in particular its
		  in-vehicle network. The aim is to highlight the current
		  state of the research; which are the problems found, and
		  what solutions have been suggested. We have structured our
		  investigation by categorizing the research into the
		  following five categories: problems in the in-vehicle
		  network, architectural security features, intrusion
		  detection systems, honeypots, and threats and attacks. We
		  conclude that even though quite some effort has already
		  been expended in the area, most of it has been directed
		  towards problem definition and not so much towards security
		  solutions. We also highlight a few areas that we believe
		  are of immediate concern.},
  author	= {Kleberger, Pierre and Olovsson, Tomas and Jonsson,
		  Erland},
  doi		= {10.1109/IVS.2011.5940525},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Kleberger, Olovsson, Jonsson - Security aspects of the
		  in-vehicle network in the connected car.pdf:pdf},
  isbn		= {9781457708909},
  issn		= {1931-0587},
  journal	= {IEEE Intelligent Vehicles Symposium, Proceedings},
  number	= {Iv},
  pages		= {528--533},
  title		= {{Security aspects of the in-vehicle network in the
		  connected car}},
  year		= {2011}
}

@Article{	  klein2009,
  abstract	= {Complete formal verification is the only known way to
		  guarantee that a system is free of programming errors. We
		  present our experience in performing the for- mal,
		  machine-checked verification of the seL4 mi- crokernel from
		  an abstract specification down to its C implementation. We
		  assume correctness of com- piler, assembly code, and
		  hardware, and we used a unique design approach that fuses
		  formal and oper- ating systems techniques. To our
		  knowledge, this is the first formal proof of functional
		  correctness of a complete, general-purpose operating-system
		  kernel. Functional correctness means here that the
		  implemen- tation always strictly follows our high-level
		  abstract specification of kernel behaviour. This
		  encompasses traditional design and implementation safety
		  proper- ties such as the kernel will never crash, and it
		  will never perform an unsafe operation. It also proves much
		  more: we can predict precisely how the kernel will behave
		  in every possible situation. seL4, a third-generation
		  microkernel of L4 prove- nance, comprises 8,700 lines of C
		  code and 600 lines of assembler. Its performance is
		  comparable to other high-performance L4 kernels. 1},
  author	= {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot
		  and Andronick, June and Cock, David and Derrin, Philip and
		  Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal
		  and Norrish, Michael and Sewell, Thomas and Tuch, Harvey
		  and Winwood, Simon},
  doi		= {10.1145/1629575.1629596},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Klein et al. - seL4 Formal verification of an OS
		  kernel.pdf:pdf},
  isbn		= {9781605587523},
  issn		= {00010782},
  journal	= {Proceedings of the ACM SIGOPS 22nd Symposium on Operating
		  System Principles},
  keywords	= {hol,isabelle,l4,microkernel,sel4},
  pages		= {207--220},
  title		= {{seL4: Formal verification of an OS kernel}},
  url		= {http://dl.acm.org/citation.cfm?id=1629596},
  year		= {2009}
}

@Article{	  koeberl2014,
  author	= {Koeberl, Patrick and Schulz, Steffen and Sadeghi,
		  Ahmad-Reza and Varadharajan, Vijay},
  doi		= {10.1145/2592798.2592824},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Koeberl et al. - TrustLite A Security Architecture for Tiny
		  Embedded Devices.pdf:pdf},
  isbn		= {9781450327046},
  journal	= {Proceedings of the European Conference on Computer Systems
		  (EuroSys)},
  pages		= {1--14},
  title		= {{TrustLite: A Security Architecture for Tiny Embedded
		  Devices}},
  url		= {http://dl.acm.org/citation.cfm?id=2592798.2592824},
  year		= {2014}
}

@Article{	  kolbitsch2010,
  author	= {Kolbitsch, Clemens and Holtz, Thorsten and Kruegel,
		  Christopher and Kirda, Engin},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Kolbitsch et al. - Inspector Gadget Automated Extraction of
		  Proprietary Gadgets from Malware Binaries.pdf:pdf},
  journal	= {Proceedings of the IEEE Symposium on Security and
		  Privacy},
  title		= {{Inspector Gadget: Automated Extraction of Proprietary
		  Gadgets from Malware Binaries}},
  year		= {2010}
}

@Article{	  koscher2010,
  author	= {Koscher, Karl and Czeskis, Alexei and Roesner, Franziska
		  and Patel, Shwetak and Kohno, Tadayoshi and Checkoway,
		  Stephen and Mccoy, Damon and Kantor, Brian and Anderson,
		  Danny and Shacham, Hovav and Savage, Stefan},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Koscher et al. - Experimental Security Analysis of a Modern
		  Automobile.pdf:pdf},
  journal	= {Proceedings of the IEEE Symposium on Security and
		  Privacy},
  keywords	= {automobiles,commu-,communication standards,computer
		  security,data buses,nication system security},
  pages		= {1--16},
  title		= {{Experimental Security Analysis of a Modern Automobile}},
  year		= {2010}
}

@Article{	  kourai2005,
  abstract	= {In this paper, a virtual distributed monitoring
		  environment called HyperSpector is described that achieves
		  secure intrusion detection in distributed computer systems.
		  While multiple intrusion detection systems (IDSes) can
		  protect a distributed system from attackers, they can
		  increase the number of insecure points in the protected
		  system. HyperSpector overcomes this problem without any
		  additional hardware by using virtualization to isolate each
		  IDS from the servers it monitors. The IDSes are located in
		  a virtual machine called an IDS VM and the servers are
		  located in a server VM. The IDS VMs among different hosts
		  are connected using a virtual network. To enable legacy
		  IDSes running in the IDS VM to monitor the server VM,
		  HyperSpector provides three inter-VM monitoring mechanisms:
		  software port mirroring, inter-VM disk mounting, and
		  inter-VM process mapping. Consequently, active attacks,
		  which directly attack the IDSes, are prevented. The impact
		  of passive attacks, which wait until data including
		  malicious code is read by an IDS and the IDS becomes
		  compromised, is confined to within an affected HyperSpector
		  environment.},
  author	= {Kourai, Kenichi and Chiba, S},
  doi		= {10.1145/1064979.1065006},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Kourai, Chiba - HyperSpector virtual distributed monitoring
		  environments for secure intrusion detection.pdf:pdf},
  isbn		= {1595930477},
  journal	= {{\ldots} conference on Virtual execution environments},
  keywords	= {dis-,inter-vm monitoring,virtual machine,virtual network},
  pages		= {197--207},
  title		= {{HyperSpector: virtual distributed monitoring environments
		  for secure intrusion detection}},
  url		= {http://dl.acm.org/citation.cfm?id=1065006},
  year		= {2005}
}

@Article{	  kreibich2004,
  abstract	= {This paper describes a system for automated generation of
		  attack signatures for network intrusion detection systems.
		  Our system applies pattern-matching techniques and protocol
		  conformance checks on multiple levels in the protocol
		  hierarchy to network trafﬁc captured a honeypot system.
		  We present results of running the system on an unprotected
		  cable modem connection for 24 hours. The system
		  successfully created precise trafﬁc signatures that
		  otherwise would have required the skills and time of a
		  security ofﬁcer to inspect the trafﬁc manually},
  author	= {Kreibich, Christian and Crowcroft, Jon},
  doi		= {10.1145/972374.972384},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Kreibich, Crowcroft - Honeycomb – Creating Intrusion
		  Detection Signatures Using Honeypots.pdf:pdf},
  isbn		= {0146-4833},
  issn		= {0146-4833},
  journal	= {ACM SIGCOMM Computer Communications Review},
  number	= {1},
  pages		= {51--56},
  title		= {{Honeycomb – Creating Intrusion Detection Signatures
		  Using Honeypots}},
  url		= {http://dpnm.postech.ac.kr/research/04/nsri/papers/honypot.pdf}
		  ,
  volume	= {34},
  year		= {2004}
}

@Article{	  krishnamurthy2010,
  abstract	= {For purposes of this paper, we define“Personally
		  identifiable information” (PII) as information which can
		  be used to dis- tinguish or trace an individual’s
		  identity either alone or when combined with other
		  information that is linkable to a specific individual. The
		  popularity of Online Social Networks (OSN) has accelerated
		  the appearance of vast amounts of personal information on
		  the Internet. Our research shows that it is possible for
		  third-parties to link PII, which is leaked via OSNs, with
		  user actions both within OSN sites and else- where on
		  non-OSN sites. We refer to this ability to link PII and
		  combine it with other information as “leakage”. We have
		  identified multiple ways by which such leakage occurs and
		  discuss measures to prevent it.},
  author	= {Krishnamurthy, Balachander and Wills, Craig E.},
  doi		= {10.1145/1672308.1672328},
  file		= {::},
  isbn		= {9781605584454},
  issn		= {01464833},
  journal	= {ACM SIGCOMM Computer Communication Review},
  keywords	= {online social networks,personally identifiable
		  in-,privacy},
  number	= {1},
  pages		= {112},
  title		= {{On the leakage of personally identifiable information via
		  online social networks}},
  volume	= {40},
  year		= {2010}
}

@Article{	  krugel2002,
  abstract	= {The constant increase of attacks against networks and
		  their resources (as recently shown by the GodeRed worm)
		  causes a necessity to protect these valuable assets.
		  Firewalls are now a common installation to repel intrusion
		  attempts in the first place. Intrusion detection systems
		  (IDS), which try to detect malicious activities instead of
		  preventing them, offer additional protection when the first
		  defense perimeter has been penetrated. ID systems attempt
		  to pin down attacks by comparing collected data to
		  predefined signatures known to be malicious (signature
		  based) or to a model o[ legal behavior (anomaly based).
		  Anomaly based systems have the advantage of being able to
		  detect previously unknown attacks but they suffer from the
		  difficulty to build a solid model of acceptable behavior
		  and the high number of alarms caused by unusual but
		  authorized activities. We present an approach that utilizes
		  application specific knowledge of the network services that
		  should be protected. This information helps to extend
		  current, simple network traffic models to form an
		  application model that allows to detect malicious content
		  hidden in single network packets. We describe the features
		  of our proposed model and present experimental data that
		  underlines the efficiency of our systems.},
  author	= {Kr{\"{u}}gel, C and Toth, Thomas and Kirda, Engin},
  doi		= {10.1145/508791.508835},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2002 -
		  Kr{\"{u}}gel, Toth, Kirda - Service specific anomaly
		  detection for network intrusion detection.pdf:pdf},
  isbn		= {1581134452},
  journal	= {Proceedings of the 2002 ACM symposium on {\ldots}},
  keywords	= {Anomaly Detection,Intrusion detection,network security},
  pages		= {201--208},
  title		= {{Service specific anomaly detection for network intrusion
		  detection}},
  url		= {http://dl.acm.org/citation.cfm?id=508835},
  year		= {2002}
}

@Article{	  kumar2006,
  abstract	= {There is a growing demand for network devices capable of
		  examining the content of data packets in order to improve
		  network security and provide application-specific services.
		  Most high performance systems that perform deep packet
		  inspection implement simple string matching algorithms to
		  match packets against a large, but finite set of strings.
		  owever, there is growing interest in the use of regular
		  expression-based pattern matching, since regular
		  expressions offer superior expressive power and
		  flexibility. Deterministic finite automata (DFA)
		  representations are typically used to implement regular
		  expressions. However, DFA representations of regular
		  expression sets arising in network applications require
		  large amounts of memory, limiting their practical
		  application.In this paper, we introduce a new
		  representation for regular expressions, called the Delayed
		  Input DFA (D2FA), which substantially reduces space
		  equirements as compared to a DFA. A D2FA is constructed by
		  transforming a DFA via incrementally replacing several
		  transitions of the automaton with a single default
		  transition. Our approach dramatically reduces the number of
		  distinct transitions between states. For a collection of
		  regular expressions drawn from current commercial and
		  academic systems, a D2FA representation reduces transitions
		  by more than 95{\%}. Given the substantially reduced space
		  equirements, we describe an efficient architecture that can
		  perform deep packet inspection at multi-gigabit rates. Our
		  architecture uses multiple on-chip memories in such a way
		  that each remains uniformly occupied and accessed over a
		  short duration, thus effectively distributing the load and
		  enabling high throughput. Our architecture can provide
		  ostffective packet content scanning at OC-192 rates with
		  memory requirements that are consistent with current ASIC
		  technology.},
  author	= {Kumar, Sailesh and Dharmapurikar, Sarang and Yu, Fang and
		  Crowley, Patrick and Turner, Jonathan},
  doi		= {10.1145/1151659.1159952},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Kumar et al. - Algorithms to accelerate multiple regular
		  expressions matching for deep packet inspection.pdf:pdf},
  isbn		= {1595933085},
  issn		= {01464833},
  journal	= {ACM SIGCOMM Computer Communication Review},
  keywords	= {deep packet inspection,dfa,regular expressions},
  number	= {4},
  pages		= {339},
  title		= {{Algorithms to accelerate multiple regular expressions
		  matching for deep packet inspection}},
  volume	= {36},
  year		= {2006}
}

@InProceedings{	  kurmus2011,
  abstract	= {Kernel vulnerabilities are a major current practical
		  security problem, as attested by the weaknesses and flaws
		  found in many commodity operating system kernels in recent
		  years. Ever-growing code size in those projects, due to the
		  addition of new features and the reluctance to remove
		  legacy support, indicate that this problem will remain a
		  severe system se- curity threat in the foreseeable future.
		  Reactive measures such as bug fixes via code reviews and
		  testing, while ef- fective, can only alleviate the issue.
		  Furthermore, common practices in system hardening often
		  focus on complex and sometimes hard to achieve goals that
		  require extensive man- ual intervention such as security
		  policies for sandboxing. In this paper, we explore an
		  alternative, automated and effective way of reducing the
		  attack surface in commodity operating system kernels, which
		  we call trimming. Trim- ming is a two-fold process: an
		  initial analysis of a given system for unused kernel code
		  sections is followed by an en- forcement phase, in which
		  the unused sections are removed or prevented from being
		  executed. We discuss the require- ments that should be
		  reflected in the design of a trimming infrastructure, and
		  present a lightweight and flexible imple- mentation example
		  for the Linux kernel by using dynamic binary
		  instrumentation as provided by kprobes. Our evalu- ations
		  show we can, in the case of a web server, reduce the attack
		  surface of the kernel (in terms of the number of kernel
		  functions accessible fromunprivileged users) by about
		  88{\%}},
  author	= {Kurmus, Anil and Sorniotti, Alessandro and Kapitza,
		  R{\"{u}}diger},
  booktitle	= {Proceedings of the Fourth European Workshop on System
		  Security - EUROSEC '11},
  doi		= {10.1145/1972551.1972557},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Kurmus, Sorniotti, Kapitza - Attack surface reduction for
		  commodity OS kernels.pdf:pdf},
  isbn		= {9781450306133},
  keywords	= {attack surface reduction,kernel hardening},
  pages		= {1--6},
  title		= {{Attack surface reduction for commodity OS kernels}},
  url		= {http://dl.acm.org/citation.cfm?id=1972551.1972557},
  year		= {2011}
}

@InProceedings{	  kurmus2011,
  abstract	= {Kernel vulnerabilities are a major current practical
		  security problem, as attested by the weaknesses and flaws
		  found in many commodity operating system kernels in recent
		  years. Ever-growing code size in those projects, due to the
		  addition of new features and the reluctance to remove
		  legacy support, indicate that this problem will remain a
		  severe system se- curity threat in the foreseeable future.
		  Reactive measures such as bug fixes via code reviews and
		  testing, while ef- fective, can only alleviate the issue.
		  Furthermore, common practices in system hardening often
		  focus on complex and sometimes hard to achieve goals that
		  require extensive man- ual intervention such as security
		  policies for sandboxing. In this paper, we explore an
		  alternative, automated and effective way of reducing the
		  attack surface in commodity operating system kernels, which
		  we call trimming. Trim- ming is a two-fold process: an
		  initial analysis of a given system for unused kernel code
		  sections is followed by an en- forcement phase, in which
		  the unused sections are removed or prevented from being
		  executed. We discuss the require- ments that should be
		  reflected in the design of a trimming infrastructure, and
		  present a lightweight and flexible imple- mentation example
		  for the Linux kernel by using dynamic binary
		  instrumentation as provided by kprobes. Our evalu- ations
		  show we can, in the case of a web server, reduce the attack
		  surface of the kernel (in terms of the number of kernel
		  functions accessible fromunprivileged users) by about
		  88{\%}},
  author	= {Kurmus, Anil and Sorniotti, Alessandro and Kapitza,
		  R{\"{u}}diger},
  booktitle	= {Proceedings of the Fourth European Workshop on System
		  Security - EUROSEC '11},
  doi		= {10.1145/1972551.1972557},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Kurmus, Sorniotti, Kapitza - Attack surface reduction for
		  commodity OS kernels.pdf:pdf},
  isbn		= {9781450306133},
  keywords	= {attack surface reduction,kernel hardening},
  mendeley-groups={5 - Operating System,6 - Application/Attack surface
		  reduction},
  pages		= {1--6},
  title		= {{Attack surface reduction for commodity OS kernels}},
  url		= {http://dl.acm.org/citation.cfm?id=1972551.1972557},
  year		= {2011}
}

@Article{	  kurmus2013,
  abstract	= {Attack Surface Metrics and Automated Compile-Time Kernel
		  Tailoring},
  author	= {Kurmus, Anil and Tartler, Reinhard and Dorneanu, Daniela
		  and Heinloth, Bernhard and Rothberg, Valentin and Ruprecht,
		  Andreas and Schroder-Preikschat, Wolfgang and Lohmann,
		  Daniel and Kapitza, Rudiger},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Kurmus et al. - Attack Surface Metrics and Automated
		  Compile-Time Kernel Tailoring.pdf:pdf},
  pages		= {1--63},
  title		= {{Attack Surface Metrics and Automated Compile-Time Kernel
		  Tailoring}},
  url		= {http://www.internetsociety.org/sites/default/files/Presentation03{\_}2.pdf}
		  ,
  year		= {2013}
}

@Article{	  kurmus2013,
  abstract	= {Attack Surface Metrics and Automated Compile-Time Kernel
		  Tailoring},
  author	= {Kurmus, Anil and Tartler, Reinhard and Dorneanu, Daniela
		  and Heinloth, Bernhard and Rothberg, Valentin and Ruprecht,
		  Andreas and Schroder-Preikschat, Wolfgang and Lohmann,
		  Daniel and Kapitza, Rudiger},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Kurmus et al. - Attack Surface Metrics and Automated
		  Compile-Time Kernel Tailoring.pdf:pdf},
  journal	= {NDSS},
  mendeley-groups={5 - Operating System,6 - Application/Attack surface
		  reduction},
  pages		= {1--63},
  title		= {{Attack Surface Metrics and Automated Compile-Time Kernel
		  Tailoring}},
  url		= {http://www.internetsociety.org/sites/default/files/Presentation03{\_}2.pdf}
		  ,
  year		= {2013}
}

@Article{	  kurmus2014,
  author	= {Kurmus, Anil and Dechand, Sergej and Kapitza, Rudiger},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Kurmus, Dechand, Kapitza - Quantifiable Run-time Kernel
		  Attack Surface Reduction.pdf:pdf},
  journal	= {Proceedings of the Conference on Detection of Intrusions
		  and Malware {\&} Vulnerability Assessment (DIMVA)},
  title		= {{Quantifiable Run-time Kernel Attack Surface Reduction}},
  year		= {2014}
}

@Article{	  kurmus2014,
  author	= {Kurmus, Anil and Dechand, Sergej and Kapitza, Rudiger},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Kurmus, Dechand, Kapitza - Quantifiable Run-time Kernel
		  Attack Surface Reduction.pdf:pdf},
  journal	= {Proceedings of the Conference on Detection of Intrusions
		  and Malware {\&} Vulnerability Assessment (DIMVA)},
  mendeley-groups={5 - Operating System,6 - Application/Attack surface
		  reduction},
  title		= {{Quantifiable Run-time Kernel Attack Surface Reduction}},
  year		= {2014}
}

@Article{	  kurmus2014a,
  author	= {Kurmus, Anil and Zippel, Robby},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Kurmus, Zippel - A Tale of Two Kernels Towards Ending
		  Kernel Hardening Wars with Split Kernel.pdf:pdf},
  isbn		= {9781450329576},
  journal	= {Proceedings of the ACM Conference on Computer and
		  Communications Security (CCS)},
  pages		= {1366--1377},
  title		= {{A Tale of Two Kernels: Towards Ending Kernel Hardening
		  Wars with Split Kernel}},
  year		= {2014}
}

@Article{	  larson2008,
  abstract	= {The automobile industry has grown to become an integral
		  part of our everyday life. As vehicles evolve, the primar-
		  ily mechanical solutions for vehicle control are gradually
		  replaced by electronics and software solutions forming in-
		  vehicle computer networks. An emerging trend is to intro-
		  duce wireless technology in the vehicle domain by attaching
		  a wireless gateway to the in-vehicle network. By allowing
		  wireless communication, real-time information exchange be-
		  tween vehicles and between infrastructure and vehicles be-
		  come reality. This communication allows for road condi-
		  tion reporting, decision making, and remote diagnostics and
		  firmware updates over-the-air. However, allowing external
		  parties wireless access to the in-vehicle network creates a
		  potential entry-point for cyber attacks. In this paper, we
		  investigate the security issues of allowing external
		  wireless communication. We use a defense-in-depth
		  perspective and discuss security challenges for each of the
		  prevention, detec- tion, deflection, countermeasures, and
		  recovery layers.},
  author	= {Larson, Ulf E. and Nilsson, Dennis K.},
  doi		= {10.1145/1413140.1413174},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Larson, Nilsson - Securing vehicles against cyber
		  attacks.pdf:pdf},
  isbn		= {9781605580982},
  journal	= {Proceedings of the 4th annual workshop on Cyber security
		  and informaiton intelligence research developing strategies
		  to meet the cyber security and information intelligence
		  challenges ahead - CSIIRW '08},
  keywords	= {challenges,out-,security,vehicle,wireless communication},
  pages		= {1},
  title		= {{Securing vehicles against cyber attacks}},
  url		= {http://portal.acm.org/citation.cfm?doid=1413140.1413174},
  year		= {2008}
}

@Article{	  lee2005,
  abstract	= {For economic reasons, in spite of security problems, the
		  com- mands of re-initializing the card and writing patch
		  code are widely used in smart cards. The current software
		  tester has difficulty in detecting these trapdoor commands
		  by reason that trapdoors are not published and programmed
		  sophisticatedly. Up to now the effective way to detect them
		  is to completely reveal and analyze the entire code of the
		  COS with applications such as the ITSEC. It is, however,
		  very time-consuming and expensive processes. We propose a
		  new approach of detecting trapdoors in smart cards using
		  timing and power analysis. By experiments, this paper shows
		  that this approach is a more practical method than the cur-
		  rent methods. Keywords:},
  author	= {Lee, Jung Youp and Jung, Seok Won and Lim, Jongin},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Lee, Jung, Lim - Detecting Trapdoors in Smart Cards Using
		  Timing and Power Analysis.pdf:pdf},
  issn		= {03029743},
  journal	= {Testing of Communicating System},
  keywords	= {power analysis,smart card,timing analysis,trapdoor},
  pages		= {275--288},
  title		= {{Detecting Trapdoors in Smart Cards Using Timing and Power
		  Analysis}},
  year		= {2005}
}

@InProceedings{	  li11:block,
  address	= {Orlando, FL},
  annote	= {The terrible paper that doesn't cite me! Oh well, you win
		  some, you lose some. - Its all right Adam, I will cite you
		  in every paper I write!! :D
		  
		  This is like Swaddler, except for the
		  {\&}quot;black-box.{\&}quot;
		  
		  This {\&}quot;black-box{\&}quot; approach, which just
		  doesn't require the source code, but does require access to
		  the session variables.
		  
		  They generate invariants based on the symbolic web pages,
		  the session variables, and their order.
		  
		  They had false positives, just like everyone with anomaly
		  detection, because their training data was incomplete.},
  author	= {Li, Xiaowei and Xue, Yuan},
  booktitle	= {Proceedings of the Annual Computer Security Applications
		  Conference (ACSAC 2011)},
  month		= {dec},
  title		= {{BLOCK: A Black-box Approach for Detection of State
		  Violation Attacks Towards Web Applications}},
  year		= {2011}
}

@Article{	  li2008,
  abstract	= {New attacker scenarios involving integrated circuits (ICs)
		  are emerging that pose a tremendous threat to national
		  security. Concerns about overseas fabrication facilities
		  and the protection of deployed ICs have given rise to
		  methods for IC authentication (ensuring that an IC being
		  used in a system has not been altered, replaced, or
		  spoofed) and hardware Trojan Horse (HTH) detection
		  (ensuring that an IC fabricated in a nonsecure facility
		  contains the desired functionality and nothing more), but
		  significant additional work is required to quell these
		  treats. This paper discusses how a technique for precisely
		  measuring the combinational delay of an arbitrarily large
		  number of register-to-register paths internal to the
		  functional portion of the IC can be used to provide the
		  desired authentication and design alteration (including HTH
		  implantation) detection. This low-cost delay measurement
		  technique does not affect the main IC functionality and can
		  be performed at-speed at both test-time and run-time.},
  author	= {Li, Jie and Lach, John},
  doi		= {10.1109/HST.2008.4559038},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 - Li,
		  Lach - At-speed delay characterization for IC
		  authentication and Trojan horse detection.pdf:pdf},
  isbn		= {9781424424016},
  journal	= {2008 IEEE International Workshop on Hardware-Oriented
		  Security and Trust, HOST},
  keywords	= {Hardware Trojan horse detection,Hardware security,IC
		  authentication,Path delay characterization},
  pages		= {8--14},
  title		= {{At-speed delay characterization for IC authentication and
		  Trojan horse detection}},
  year		= {2008}
}

@Article{	  li2010,
  author	= {Li, Yanlin and McCune, Jonathan M and Perrig, Adrian},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 - Li,
		  McCune, Perrig - SBAP Software-Based Attestation for
		  Peripherals.pdf:pdf},
  journal	= {Trust and Trustworthy Computing},
  title		= {{SBAP: Software-Based Attestation for Peripherals}},
  year		= {2010}
}

@Article{	  li2010a,
  abstract	= {Many security-critical web applications, such as online
		  banking and e-commerce, require a secure communication path
		  between the user and a remote server. Securing this endto-
		  end path is challenging and can be broken down into several
		  segments. The network part between the user's machine and
		  the server is usually well protected, using secure
		  communication protocols, such as the Transport Layer
		  Security (TLS) protocol. However, the user's sensitive
		  inputs (such as password and credit card number) are
		  handled by the operating system (OS) and the web
		  applications before being encrypted and passed on to the
		  network; also some sensitive information from the server
		  (such as private account balance and transaction
		  confirmation) is handled by OS/applications before being
		  displayed to the user. This user interface part of the
		  communication path, which includes the OS and web
		  applications, is often untrusted because of possible
		  malware (virus, rootkits, spyware, etc.) and
		  vulnerabilities within the client. In this paper, a secure
		  user interface running under an untrusted OS is proposed,
		  which is independent of the OS/applications and has a very
		  small code base size. This secure user interface attests
		  itself to the remote server and then handles the sensitive
		  input and output by itself, bypassing the OS kernel and web
		  applications. It utilizes network software stacks in the
		  OS, however, the sensitive information is cryptographically
		  protected before being revealed to the potentially
		  malicious OS. This ensures the confidentiality and
		  integrity of the sensitive information. Using this secure
		  user interface, even while running under untrusted
		  OS/applications, the user's sensitive input, private
		  output, and transaction integrity can be protected.},
  author	= {Li, Chunxiao and Raghunathan, Anand and Jha, Niraj K.},
  doi		= {10.1109/CIT.2010.162},
  file		= {::},
  isbn		= {9780769541082},
  journal	= {Proceedings - 10th IEEE International Conference on
		  Computer and Information Technology, CIT-2010, 7th IEEE
		  International Conference on Embedded Software and Systems,
		  ICESS-2010, ScalCom-2010},
  number	= {Cit},
  pages		= {865--870},
  title		= {{A secure user interface for web applications running
		  under an untrusted operating system}},
  year		= {2010}
}

@InProceedings{	  li2011,
  abstract	= {x},
  author	= {Li, Yanlin and Mccune, Jonathan M and Perrig, Adrian},
  booktitle	= {Proceedings of the ACM Conference on Computer and
		  Communications Security (CCS)},
  doi		= {10.1145/2046707.2046711},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Li,
		  Mccune, Perrig - VIPER Verifying the Integrity of
		  PERipherals' Firmware.pdf:pdf},
  isbn		= {9781450309486},
  issn		= {09581669},
  keywords	= {firmware,integrity peripherals,proxy attack,software},
  number	= {October},
  pages		= {3--16},
  pmid		= {20669782},
  title		= {{VIPER : Verifying the Integrity of PERipherals'
		  Firmware}},
  url		= {http://dl.acm.org/citation.cfm?id=2046711},
  volume	= {22},
  year		= {2011}
}

@Article{	  li2011a,
  abstract	= {Protecting kernel control data (e.g., function pointers
		  and return addresses) has been a serious issue plaguing
		  rootkit defenders. In particular, rootkit authors only need
		  to compromise one piece of control data to launch their
		  attacks, while defenders need to protect thousands of such
		  values widely scattered across kernel memory space. Worse,
		  some of this data (e.g., return addresses) is volatile and
		  can be dynamically generated at run time. Existing
		  solutions, however, offer either incomplete protection or
		  excessive performance overhead. To overcome these
		  limitations, we present indexed hooks, a scheme that
		  greatly facilitates kernel control-flow enforcement by
		  thoroughly transforming and restricting kernel control data
		  to take only legal jump targets (allowed by the kernel's
		  control-flow graph). By doing so, we can severely limit the
		  attackers' possibility of exploiting them as an infection
		  vector to launch rootkit attacks. To validate our approach,
		  we have developed a compiler-based prototype that
		  implements this technique in the FreeBSD 8.0 kernel,
		  transforming 49{\&}{\#}x2009;025 control transfer
		  instructions (<formula formulatype="inline"><tex
		  Notation="TeX">{\$}\backslashsim{\$}</tex>
		  </formula>7.25{\%} of the code base) to use indexed hooks
		  instead of direct pointers. Our evaluation results indicate
		  that our approach is generic, effective, and can be
		  implemented on commodity hardware with a low performance
		  overhead (<formula formulatype="inline"><tex
		  Notation="TeX">{\$}{\&}lt;{\$}</tex></formula>5{\%} based
		  on benchmarks).},
  author	= {Li, Jinku and Wang, Zhi and Bletsch, Tyler and Srinivasan,
		  Deepa and Grace, Michael and Jiang, Xuxian},
  doi		= {10.1109/TIFS.2011.2159712},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Li
		  et al. - Comprehensive and efficient protection of kernel
		  control data.pdf:pdf},
  issn		= {15566013},
  journal	= {IEEE Transactions on Information Forensics and Security},
  number	= {4},
  pages		= {1404--1417},
  title		= {{Comprehensive and efficient protection of kernel control
		  data}},
  volume	= {6},
  year		= {2011}
}

@InProceedings{	  li2012,
  address	= {San Antonio, Texas},
  annote	= {Black-box approach to detect logic flaws at the database
		  layer.
		  
		  They model the application as an Extended Finite State
		  Machine (EFSM).
		  
		  They build up a profile of the web applicaiton during
		  attack-free use and use this profile to detect attacks.
		  
		  It is essentially like Swaddler, but they don't require the
		  source code. Although they do need the developer to explain
		  how to access the session values.},
  author	= {Li, Xiaowei and Yan, Wei and Xue, Yuan},
  booktitle	= {Proceedings of the second ACM conference on Data and
		  Application Security and Privacy (CODASPY)},
  doi		= {10.1145/2133601.2133605},
  isbn		= {9781450310918},
  publisher	= {ACM},
  title		= {{SENTINEL : Securing Database from Logic Flaws in Web
		  Applications}},
  year		= {2012}
}

@Article{	  li2014,
  annote	= {1. How to sandbox both an application from an OS and the
		  OS from an application.},
  author	= {Li, Yanlin and McCune, Jonathan and Newsome, James and
		  Perrig, Adrian and Baker, Brandon and Drewry, Will},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 - Li
		  et al. - MiniBox A Two-Way Sandbox for x86 Native
		  Code.pdf:pdf},
  isbn		= {978-1-931971-10-2},
  journal	= {2014 USENIX Annual Technical Conference (USENIX ATC 14)},
  pages		= {409--420},
  title		= {{MiniBox: A Two-Way Sandbox for x86 Native Code}},
  url		= {https://www.usenix.org/conference/atc14/technical-sessions/presentation/li{\_}yanlin}
		  ,
  year		= {2014}
}

@Article{	  li2014a,
  abstract	= {To prevent Iago attacks caused by mmap or sysbrk,
		  the$\backslash$nhypervisor checks that the newly ... to be
		  mapped as$\backslash$nexecutable, as this represents a
		  significant$\backslash$nincrease in attack surface. ... in
		  network I/O. In$\backslash$nthe MIEE, the supported thread
		  synchro- nization$\backslash$nsystem calls include
		  semaphores Yanlin Li,$\backslash$nCyLab/Carnegie Mellon
		  University; Jonathan McCune$\backslash$nand James Newsome,
		  CyLab/Carnegie Mellon University$\backslash$nand Google,
		  Inc.; Adrian Perrig, CyLab/Carnegie$\backslash$nMellon
		  University; Brandon Baker and Will
		  Drewry,$\backslash$nGoogle, Inc.$\backslash$n},
  author	= {Li, Yanlin and McCune, Jonathan and Newsome, James and
		  Perrig, Adrian and Baker, Brandon and Drewry, Will},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/MiniBox-A
		  Two-Way Sandbox for x86 Native Code.pdf:pdf},
  isbn		= {978-1-931971-10-2},
  journal	= {2014 USENIX Annual Technical Conference (USENIX ATC 14)},
  pages		= {409--420},
  title		= {{MiniBox: A Two-Way Sandbox for x86 Native Code}},
  url		= {https://www.usenix.org/conference/atc14/technical-sessions/presentation/li{\_}yanlin}
		  ,
  year		= {2014}
}

@Article{	  lin2009,
  abstract	= {This paper introduces a new software polymorphism
		  technique that randomizes program data structure layout.
		  This technique will generate different data structure
		  layouts for a program and thus diversify the binary code
		  compiled from the same program source code. This technique
		  can mitigate attacks (e.g., kernel rootkit attacks) that
		  require knowledge about data structure definitions. It is
		  also able to disrupt the generation of data structure-based
		  program signatures. We have implemented our data structure
		  layout randomization technique in the open source compiler
		  collection gcc-4.2.4 and applied it to a number of
		  programs. Our evaluation results show that our technique is
		  able to achieve software binary diversity. We also apply
		  the technique to one operating system data structure in
		  order to foil a number of kernel rootkit attacks.
		  Meanwhile, programs produced by the technique were analyzed
		  by a state-of-the-art data structure inference system and
		  it was demonstrated that reliance on data structure
		  signatures alone may lead to false negatives in malware
		  detection.},
  annote	= {1. How to protect data structures from corruption.
		  
		  2. Apply ASLR style techniques to the data structures
		  
		  3. Randomize the data structures of binaries at compile
		  time.
		  
		  4. Could go in either OS or application layer, but I'm
		  putting it in OS b/c the paper focuses on kernel
		  rootkits.},
  author	= {Lin, Zhiqiang and Riley, Ryan D. and Xu, Dongyan},
  doi		= {10.1007/978-3-642-02918-9{\_}7},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Lin, Riley, Xu - Polymorphing software by randomizing data
		  structure layout.pdf:pdf},
  isbn		= {3642029175},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  pages		= {107--126},
  title		= {{Polymorphing software by randomizing data structure
		  layout}},
  volume	= {5587 LNCS},
  year		= {2009}
}

@Article{	  liu2008,
  abstract	= {Firewalls are the mainstay of enterprise security and the
		  most widely adopted technology for protecting private
		  networks. An error in a firewall policy either creates
		  security holes that will allow malicious traffic to sneak
		  into a private network or blocks legitimate traffic and
		  disrupts normal business processes, which in turn could
		  lead to irreparable, if not tragic, consequences. It has
		  been observed that most firewall policies on the Internet
		  are poorly designed and have many errors. Therefore, how to
		  design firewall policies correctly is an important issue.
		  In this paper, we propose the method of diverse firewall
		  design, which consists of three phases: a design phase, a
		  comparison phase, and a resolution phase. In the design
		  phase, the same requirement specification of a firewall
		  policy is given to multiple teams who proceed independently
		  to design different versions of the firewall policy. In the
		  comparison phase, the resulting multiple versions are
		  compared with each other to detect all functional
		  discrepancies between them. In the resolution phase, all
		  discrepancies are resolved and a firewall that is agreed
		  upon by all teams is generated.},
  author	= {Liu, Alex X. and Gouda, Mohamed G.},
  doi		= {10.1109/TPDS.2007.70802},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Liu, Gouda - Diverse firewall design.pdf:pdf},
  isbn		= {0-7695-2052-9},
  issn		= {10459219},
  journal	= {IEEE Transactions on Parallel and Distributed Systems},
  keywords	= {Change impact analysis,Design diversity,Firewall
		  policy,Network security,Policy design},
  number	= {9},
  pages		= {1237--1251},
  title		= {{Diverse firewall design}},
  volume	= {19},
  year		= {2008}
}

@Article{	  liu2009,
  author	= {Liu, Yali and Corbett, Cherita and Chiang, Ken and
		  Archibald, Rennie},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 - Liu
		  et al. - Detecting Sensitive Data Exfiltration by an
		  Insider Attack.pdf:pdf},
  isbn		= {9781605580982},
  keywords	= {SIDD: A Framework for Detecting Sensitive Data Exf},
  pages		= {1--4},
  title		= {{Detecting Sensitive Data Exfiltration by an Insider
		  Attack}},
  year		= {2009}
}

@Article{	  liu2013,
  author	= {Liu, Yu and Jin, Yier and Makris, Yiorgos},
  doi		= {10.1109/ICCAD.2013.6691149},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Liu, Jin, Makris - Hardware Trojans in wireless
		  cryptographic ICs Silicon demonstration {\&} detection
		  method evaluation.pdf:pdf},
  isbn		= {9781479910717},
  issn		= {10923152},
  journal	= {IEEE/ACM International Conference on Computer-Aided
		  Design, Digest of Technical Papers, ICCAD},
  pages		= {399--404},
  title		= {{Hardware Trojans in wireless cryptographic ICs: Silicon
		  demonstration {\&} detection method evaluation}},
  year		= {2013}
}

@Article{	  liu2014,
  author	= {Liu, Yu and Huang, Ke and Makris, Yiorgos},
  doi		= {10.1145/2593069.2593147},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Liu, Huang, Makris - Hardware Trojan Detection through
		  Golden Chip-Free Statistical Side-Channel
		  Fingerprinting.pdf:pdf},
  isbn		= {9781450327305},
  issn		= {0738100X},
  journal	= {Proceedings of the The 51st Annual Design Automation
		  Conference on Design Automation Conference - DAC '14},
  keywords	= {golden chip,hardware trojan,ing,process control
		  monitor,side-channel fingerprint-,wireless cryptographic
		  ic},
  pages		= {1--6},
  title		= {{Hardware Trojan Detection through Golden Chip-Free
		  Statistical Side-Channel Fingerprinting}},
  url		= {http://dl.acm.org/citation.cfm?doid=2593069.2593147},
  year		= {2014}
}

@InProceedings{	  livshits2009,
  annote	= {Good paper about how to infer the (sources, sinks,
		  sanitizers) specification statically starting from an
		  initial specification.
		  
		  They use probabalistic reasoning, on the assumption that
		  most program paths will have correct sanitization.
		  
		  They do some fancy stuff to calculate this, based on the
		  dataflow graph along with probabilistic reasoning.},
  author	= {Livshits, Benjamin and Nori, Aditya V. and Rajamani,
		  Sriram K. and Banerjee, Anindya},
  booktitle	= {Proceedings of the ACM SIGPLAN Conference on Programming
		  Language Design and Implementation},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Livshits et al. - Merlin Specification Inference for
		  Explicit Information Flow Problems.pdf:pdf},
  isbn		= {9781605583921},
  keywords	= {security analysis tools,specification inference},
  title		= {{Merlin: Specification Inference for Explicit Information
		  Flow Problems}},
  url		= {http://dl.acm.org/citation.cfm?id=1542485},
  year		= {2009}
}

@Article{	  livshits2009a,
  abstract	= {The last several years have seen a proliferation of static
		  and runtime analysis tools for finding security violations
		  that are caused by explicit information flow in programs.
		  Much of this interest has been caused by the increase in
		  the number of vulnerabilities such as cross-site scripting
		  and SQL injection. In fact, these explicit information flow
		  vulnerabilities commonly found in Web applications now
		  outnumber vulnerabilities such as buffer overruns common in
		  type-unsafe languages such as C and C++. Tools checking for
		  these vulnerabilities require a specification to operate.
		  In most cases the task of providing such a specification is
		  delegated to the user. Moreover, the efficacy of these
		  tools is only as good as the specification. Unfortunately,
		  writing a comprehensive specification presents a major
		  challenge: parts of the specification are easy to miss,
		  leading to missed vulnerabilities; similarly, incorrect
		  specifications may lead to false positives. This paper
		  proposes Merlin, a new approach for automatically inferring
		  explicit information flow specifications from program code.
		  Such specifications greatly reduce manual labor, and
		  enhance the quality of results, while using tools that
		  check for security violations caused by explicit
		  information flow. Beginning with a data propagation graph,
		  which represents interprocedural flow of information in the
		  program, Merlin aims to automatically infer an information
		  flow specification. Merlin models information flow paths in
		  the propagation graph using probabilistic constraints. A
		  naive modeling requires an exponential number of
		  constraints, one per path in the propagation graph. For
		  scalability, we approximate these path constraints using
		  constraints on chosen triples of nodes, resulting in a
		  cubic number of constraints. We characterize this
		  approximation as a probabilistic abstraction, using the
		  theory of probabilistic refinement developed by McIver and
		  Morgan. We solve the resulting system of probabilistic
		  constraints using factor graphs, which are a well-known
		  structure for performing probabilistic inference. We
		  experimentally validate the Merlin approach by applying it
		  to 10 large business-critical Web applications that have
		  been analyzed with CAT.NET, a state-of-the-art static
		  analysis tool for .NET. We find a total of 167 new
		  confirmed specifications, which result in a total of 322
		  additional vulnerabilities across the 10 benchmarks. More
		  accurate specifications also reduce the false positive
		  rate: in our experiments, Merlin-inferred specifications
		  result in 13 false positives being removed; this
		  constitutes a 15{\%} reduction in the CAT.NET false
		  positive rate on these 10 programs. The final false
		  positive rate for CAT.NET after applying Merlin in our
		  experiments drops to under 1{\%}.},
  author	= {Livshits, B and Nori, a V and Rajamani, S K and Banerjee,
		  a},
  doi		= {10.1145/1543135.1542485},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Livshits et al. - Merlin Specification Inference for
		  Explicit Information Flow Problems(2).pdf:pdf},
  isbn		= {9781605583921},
  issn		= {0362-1340},
  journal	= {Programming Language Design and Implementation},
  keywords	= {security analysis tools,specification inference,tolearn},
  pages		= {75--86},
  title		= {{Merlin: Specification Inference for Explicit Information
		  Flow Problems}},
  url		= {http://research.microsoft.com/en-us/um/people/livshits/papers/tr/merlin{\_}tr.pdf}
		  ,
  year		= {2009}
}

@Article{	  livshits2009a,
  abstract	= {The last several years have seen a proliferation of static
		  and runtime analysis tools for finding security violations
		  that are caused by explicit information flow in programs.
		  Much of this interest has been caused by the increase in
		  the number of vulnerabilities such as cross-site scripting
		  and SQL injection. In fact, these explicit information flow
		  vulnerabilities commonly found in Web applications now
		  outnumber vulnerabilities such as buffer overruns common in
		  type-unsafe languages such as C and C++. Tools checking for
		  these vulnerabilities require a specification to operate.
		  In most cases the task of providing such a specification is
		  delegated to the user. Moreover, the efficacy of these
		  tools is only as good as the specification. Unfortunately,
		  writing a comprehensive specification presents a major
		  challenge: parts of the specification are easy to miss,
		  leading to missed vulnerabilities; similarly, incorrect
		  specifications may lead to false positives. This paper
		  proposes Merlin, a new approach for automatically inferring
		  explicit information flow specifications from program code.
		  Such specifications greatly reduce manual labor, and
		  enhance the quality of results, while using tools that
		  check for security violations caused by explicit
		  information flow. Beginning with a data propagation graph,
		  which represents interprocedural flow of information in the
		  program, Merlin aims to automatically infer an information
		  flow specification. Merlin models information flow paths in
		  the propagation graph using probabilistic constraints. A
		  naive modeling requires an exponential number of
		  constraints, one per path in the propagation graph. For
		  scalability, we approximate these path constraints using
		  constraints on chosen triples of nodes, resulting in a
		  cubic number of constraints. We characterize this
		  approximation as a probabilistic abstraction, using the
		  theory of probabilistic refinement developed by McIver and
		  Morgan. We solve the resulting system of probabilistic
		  constraints using factor graphs, which are a well-known
		  structure for performing probabilistic inference. We
		  experimentally validate the Merlin approach by applying it
		  to 10 large business-critical Web applications that have
		  been analyzed with CAT.NET, a state-of-the-art static
		  analysis tool for .NET. We find a total of 167 new
		  confirmed specifications, which result in a total of 322
		  additional vulnerabilities across the 10 benchmarks. More
		  accurate specifications also reduce the false positive
		  rate: in our experiments, Merlin-inferred specifications
		  result in 13 false positives being removed; this
		  constitutes a 15{\%} reduction in the CAT.NET false
		  positive rate on these 10 programs. The final false
		  positive rate for CAT.NET after applying Merlin in our
		  experiments drops to under 1{\%}.},
  author	= {Livshits, B and Nori, a V and Rajamani, S K and Banerjee,
		  a},
  doi		= {10.1145/1543135.1542485},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Livshits et al. - Merlin Specification Inference for
		  Explicit Information Flow Problems(2).pdf:pdf},
  isbn		= {9781605583921},
  issn		= {0362-1340},
  journal	= {Programming Language Design and Implementation},
  keywords	= {security analysis tools,specification inference,tolearn},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {75--86},
  title		= {{Merlin: Specification Inference for Explicit Information
		  Flow Problems}},
  url		= {http://research.microsoft.com/en-us/um/people/livshits/papers/tr/merlin{\_}tr.pdf}
		  ,
  year		= {2009}
}

@InProceedings{	  livshits:java_static_analysis,
  annote	= {Context-sensitive (inter-procedure), points-to analysis of
		  Java servlets to discover SQL Injection, XSS, and HTTP
		  Splitting attacks.
		  
		  Specifically, they track the taint of objects through the
		  application.
		  
		  They also claim that it is scalable, because it uses BDDs.
		  
		  They added Container analysis and handling String routines
		  to improve the points-to analysis.
		  
		  They found a lot of bugs, and the problems were due to
		  incomplete analysis.},
  author	= {Livshits, V. Benjamin and Lam, Monica},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  month		= {aug},
  pages		= {271--286},
  title		= {{Finding Security Vulnerabilities in Java Applications
		  with Static Analysis}},
  year		= {2005}
}

@Manual{	  lockheimer:2012,
  title		= "Android and Security",
  author	= "Hiroshi Lockheimer",
  url		= "http://googlemobile.blogspot.com/2012/02/android-and-security.html"
		  ,
  year		= "2012"
}

@Article{	  lu2011,
  abstract	= {Over the last few years, malware analysis has been one of
		  the hottest areas in security research. Many techniques and
		  tools have been developed to assist in automatic analysis
		  of malware. This ranges from basic tools like disassemblers
		  and decompilers, to static and dynamic tools that analyze
		  mal- ware behaviors, to automatic malware clustering and
		  clas- sification techniques, to virtualization technologies
		  to assist malware analysis, to signature- and anomaly-based
		  malware detection, and many others. However, most of these
		  tech- niques and tools would not work on new attacking
		  tech- niques, e.g., attacks that use return-oriented
		  programming (ROP). In this paper, we look into the
		  possibility of enabling ex- isting defense technologies
		  designed for normal malware to cope with malware using
		  return-oriented programming. We discuss difficulties in
		  removing ROP from malware, and de- sign and implement an
		  automatic converter, called deRop, that converts an ROP
		  exploit into shellcode that is semanti- cally equivalent
		  with the original ROP exploit but does not use ROP, which
		  could then be analyzed by existing malware defense
		  technologies. We apply deRop on four real ROP malwares and
		  demonstrate success in using deRop for the automatic
		  conversion. We further discuss applicability and
		  limitations of deRop.},
  author	= {{Lu, Kangjie, and Zou, Dabi, and Wen, Weiping, and Gao},
		  Debin},
  doi		= {0.1145/2076732.2076784},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Lu
		  - deRop Removing Return-Oriented Programming from
		  Malware.pdf:pdf},
  isbn		= {9781450306720},
  journal	= {Annual Computer Security Applications Conference (ACSAC)},
  keywords	= {malware anal-,return-oriented programming},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {363--372},
  title		= {{deRop: Removing Return-Oriented Programming from
		  Malware}},
  url		= {http://doi.acm.org/10.1145/2076732.2076784$\backslash$nhttp://www.acsac.org/2011/}
		  ,
  year		= {2011}
}

@Article{	  lu2011a,
  author	= {Lu, Kangjie and Zou, Dabi and Wen, Weiping and Gao,
		  Debin},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Lu
		  et al. - Packed, Printable, and Polymorphic Return-Oriented
		  Programming.pdf:pdf},
  journal	= {Recent Advances in Intrusion Detection},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Packed, Printable, and Polymorphic Return-Oriented
		  Programming}},
  year		= {2011}
}

@Article{	  madhavapeddy2010,
  abstract	= {The wide availability of cloud computing offers an
		  unprecedented opportunity to rethink how we construct
		  applications. The cloud is currently mostly used to package
		  up existing software stacks and operating systems (e.g.
		  LAMP) for scaling out websites. We instead view the cloud
		  as a stable hardware platform, and present a programming
		  framework which permits applications to be constructed to
		  run directly on top of it without intervening software
		  layers. Our prototype (dubbed Mirage) is unashamedly
		  academic; it extends the Objective Caml language with
		  storage extensions and a custom run-time to emit binaries
		  that execute as a guest operating system under Xen. Mirage
		  applications exhibit significant performance speedups for
		  I/O and memory handling versus the same code running under
		  Linux/Xen. Our results can be generalised to offer insight
		  into improving more commonly used languages such as PHP,
		  Python and Ruby, and we discuss lessons learnt and future
		  directions.},
  author	= {Madhavapeddy, Anil and Mortier, Richard and Sohan,
		  Ripduman and Gazagnaire, Thomas and Hand, Steven and
		  Deegan, Tim and Mcauley, Derek and Crowcroft, Jon},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Madhavapeddy et al. - Turning Down the LAMP Software
		  Specialisation for the Cloud.pdf:pdf},
  journal	= {Proceedings of the 2nd USENIX conference on Hot topics in
		  cloud computing},
  number	= {23},
  pages		= {7},
  pmid		= {3057499},
  title		= {{Turning Down the LAMP : Software Specialisation for the
		  Cloud}},
  url		= {http://portal.acm.org/citation.cfm?id=1863114},
  volume	= {85},
  year		= {2010}
}

@Article{	  madhavapeddy2013,
  author	= {Madhavapeddy, Anil and Mortier, Richard and Rotsos,
		  Charalampos and Scott, David and Singh, Balraj and
		  Gazagnaire, Thomas and Smith, Steven and Hand, Steven and
		  Crowcroft, Jon},
  doi		= {10.1145/2499368.2451167},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Madhavapeddy et al. - Unikernels Library Operating Systems
		  for the Cloud.pdf:pdf},
  isbn		= {978-1-4503-1870-9},
  issn		= {0362-1340},
  journal	= {ASPLOS},
  title		= {{Unikernels: Library Operating Systems for the Cloud}},
  year		= {2013}
}

@Article{	  madhavapeddy2015,
  author	= {Madhavapeddy, a and Leonard, T},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Madhavapeddy, Leonard - Jitsu Just-in-time summoning of
		  unikernels.pdf:pdf},
  isbn		= {9781931971218},
  journal	= {USENIX Symposium on Networked Systems Design and
		  Implementation},
  title		= {{Jitsu: Just-in-time summoning of unikernels}},
  url		= {https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-madhavapeddy.pdf}
		  ,
  year		= {2015}
}

@Article{	  maier2014,
  abstract	= {In this paper, we demonstrate that Android malware can
		  bypass all automated analysis systems, including AV
		  solutions, mobile sandboxes, and the Google Bouncer. We
		  propose a tool called Sand-Finger for the fingerprinting of
		  Android-based analysis systems. By analyzing the
		  fingerprints of ten unique analysis environments from
		  different vendors, we were able to find characteristics in
		  which all tested environments differ from actual hardware.
		  Depending on the availability of an analysis system,
		  malware can either behave benignly or load malicious code
		  at runtime. We classify this group of malware as
		  Divide-and-Conquer attacks that are efficiently obfuscated
		  by a combination of fingerprinting and dynamic code
		  loading. In this group, we aggregate attacks that work
		  against dynamic as well as static analysis. To demonstrate
		  our approach, we create proof-of-concept malware that
		  surpasses up-to-date malware scanners for Android. We also
		  prove that known malware samples can enter the Google Play
		  Store by modifying them only slightly. Due to Android's
		  lack of an API for malware scanning at runtime, it is
		  impossible for AV solutions to secure Android devices
		  against these attacks.},
  author	= {Maier, Dominik and Muller, Tilo and Protsenko, Mykola},
  doi		= {10.1109/ARES.2014.12},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Malware
		  detection/06980261.pdf:pdf},
  isbn		= {9781479942237},
  journal	= {Proceedings - 9th International Conference on
		  Availability, Reliability and Security, ARES 2014},
  keywords	= {AV,Android malware,Google bouncer,Mobile
		  sandboxes,Obfuscation,Static and dynamic analysis},
  pages		= {30--39},
  title		= {{Divide-and-conquer: Why android malware cannot be
		  stopped}},
  year		= {2014}
}

@Article{	  majumdar2007,
  abstract	= {We present hybrid concolic testing, an algorithm that
		  interleaves random testing with concolic execution to
		  obtain both a deep and a wide exploration of program state
		  space. Our algorithm generates test inputs automatically by
		  interleaving random testing until saturation with bounded
		  exhaustive symbolic exploration of program points. It thus
		  combines the ability of random search to reach deep program
		  states quickly together with the ability of concolic
		  testing to explore states in a neighborhood exhaustively.
		  We have implemented our algorithm on top of CUTE and
		  applied it to obtain better branch coverage for an editor
		  implementation (VIM 5.7, 150 K lines of code) as well as a
		  data structure implementation in C. Our experiments suggest
		  that hybrid concolic testing can handle large programs and
		  provide, for the same testing budget, almost 4times the
		  branch coverage than random testing and almost 2times that
		  of concolic testing.},
  author	= {Majumdar, Rupak and Sen, Koushik},
  doi		= {10.1109/ICSE.2007.41},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Majumdar, Sen - Hybrid concolic testing.pdf:pdf},
  isbn		= {0769528287},
  issn		= {02705257},
  journal	= {Proceedings - International Conference on Software
		  Engineering},
  keywords	= {Concolic testing,Directed random testing},
  pages		= {416--425},
  title		= {{Hybrid concolic testing}},
  year		= {2007}
}

@TechReport{	  manadhata2007,
  abstract	= {We propose a metric to determine whether one version of a
		  system is relatively more secure than another with respect
		  to the systems attack surface. Intuitively, themore exposed
		  the attack surface, the more likely the system could be
		  successfully attacked, and hence the more insecure it is.
		  We define an attack surface in terms of the systems actions
		  that are externally visible to its users and the systems
		  resources that each action accesses or modifies. To apply
		  our metric in practice, rather than consider all possible
		  system resources, we narrow our focus on a relevant subset
		  of resource types, which we call attack classes; these
		  reflect the types of system resources that are more likely
		  to be targets of attack. We assign payoffs to attack
		  classes to represent likelihoods of attack; resources in an
		  attack class with a high payoff value are more likely to be
		  targets or enablers of an attack than resources in an
		  attack class with a low payoff value. We outline a method
		  to identify attack classes and to measure a systems attack
		  surface. We demonstrate and validate our method by
		  measuring the relative attack surface of four different
		  versions of the Linux operating system.},
  author	= {Manadhata, Pratyusa K and Tan, Kymie and Maxion, Roy and
		  Wing, Jeannette},
  booktitle	= {CMU},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Manadhata et al. - An Approach to Measuring A System's
		  Attack Surface.pdf:pdf},
  mendeley-groups={6 - Application/Attack surface reduction},
  number	= {August},
  title		= {{An Approach to Measuring A System's Attack Surface}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.61.1998{\&}amp;rep=rep1{\&}amp;type=pdf$\backslash$nhttp://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2{\&}doc=GetTRDoc.pdf{\&}AD=ADA458115}
		  ,
  year		= {2007}
}

@TechReport{	  manadhata2008,
  abstract	= {Software vendors such as SAP are increasingly concerned
		  about mitigating the security risk of their
		  $\backslash$nsoftware. Code quality improvement is a
		  traditional approach to mitigate security risk; measur-
		  $\backslash$ning and reducing the attack surface of
		  software is a complementary approach. In this paper, we
		  $\backslash$nintroduce a method for measuring the attack
		  surfaces of SAP business applications implemented
		  $\backslash$nin Java. We implement a tool as an Eclipse
		  plugin to measure an SAP software system's attack
		  $\backslash$nsurface in an automated manner. We demonstrate
		  the feasibility of our approach by measuring the
		  $\backslash$nattack surfaces of three versions of an SAP
		  software system. SAP's software developers can use the
		  $\backslash$ntool as part of the software development
		  process to improve software quality and security. SAP's
		  $\backslash$ncustomers can also use the tool to mitigate
		  their security risk.},
  author	= {Manadhata, Pratyusa K and Wing, Jeannette M},
  booktitle	= {CMU},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Manadhata, Wing - Measuring the Attack Surfaces of SAP
		  Business Applications.pdf:pdf},
  mendeley-groups={6 - Application/Attack surface reduction},
  title		= {{Measuring the Attack Surfaces of SAP Business
		  Applications}},
  year		= {2008}
}

@InProceedings{	  martin08:goal_directed_mc,
  annote	= {This paper uses model checking to generate test sequences
		  to detect XSS and SQL injection attacks.
		  
		  They look for flows from an application's sink to sources,
		  but they model multi-step attacks by using model checking.
		  
		  They have some hueristics to guide the model checking
		  framework},
  author	= {Martin, Michael and Lam, Monica},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Martin, Lam - Automatic Generation of XSS and SQL Injection
		  Attacks with Goal-Directed Model Checking.pdf:pdf},
  month		= {jul},
  pages		= {31--43},
  title		= {{Automatic Generation of XSS and SQL Injection Attacks
		  with Goal-Directed Model Checking}},
  year		= {2008}
}

@InProceedings{	  martin08:goal_directed_mc,
  annote	= {This paper uses model checking to generate test sequences
		  to detect XSS and SQL injection attacks.
		  
		  They look for flows from an application's sink to sources,
		  but they model multi-step attacks by using model checking.
		  
		  They have some hueristics to guide the model checking
		  framework},
  author	= {Martin, Michael and Lam, Monica},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Martin, Lam - Automatic Generation of XSS and SQL Injection
		  Attacks with Goal-Directed Model Checking.pdf:pdf},
  month		= {jul},
  pages		= {31--43},
  title		= {{Automatic Generation of XSS and SQL Injection Attacks
		  with Goal-Directed Model Checking}},
  year		= {2008}
}

@Article{	  martins2014,
  abstract	= {Over the years middleboxes have become a fundamental part
		  of today’s networks. Despite their usefulness, they come
		  with a number of problems, many of which arise from the
		  fact that they are hardware-based: they are costly,
		  difficult to manage, and their functionality is hard or
		  impossible to change, to name a few. To address these
		  issues, there is a recent trend towards network function
		  virtualization (NFV), in essence proposing to turn these
		  middleboxes into software-based, virtualized entities.
		  Towards this goal we introduce ClickOS, a high-performance,
		  virtualized software middlebox platform. ClickOS virtual
		  machines are small (5MB), boot quickly (about 30
		  milliseconds), add little delay (45 microseconds) and over
		  one hundred of them can be concurrently run while
		  saturating a 10Gb pipe on a commodity server. We further
		  implement a wide range of middleboxes including a firewall,
		  a carrier-grade NAT and a load balancer and show that
		  ClickOS can handle packets in the millions per second.},
  annote	= {1. Improve the overhead and latency to VMs that use
		  networking.
		  
		  2. Implement a VM where the I/O interfaces are optimized
		  for I/O.
		  
		  3. Very low overhead on I/O interfaces, as long as the
		  applications use their Click interface.},
  author	= {Martins, Joao and Ahmed, Mohamed and Raiciu, Costin and
		  Olteanu, Vladimir and Honda, Michio and Huici, Roberto and
		  Felipe, Bifulco},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Martins et al. - ClickOS and the Art of Network Function
		  Virtualization.pdf:pdf},
  isbn		= {9781931971096},
  journal	= {11th USENIX Symposium on Networked Systems Design and
		  Implementation (NSDI 14)},
  pages		= {459----473},
  title		= {{ClickOS and the Art of Network Function Virtualization}},
  url		= {https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-martins.pdf}
		  ,
  year		= {2014}
}

@Article{	  maskiewicz2014,
  author	= {Maskiewicz, Jacob and Ellis, Benjamin and Mouradian, James
		  and Shacham, Hovav},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Maskiewicz et al. - Mouse Trap Exploiting Firmware Updates
		  in USB Peripherals.pdf:pdf},
  journal	= {Proceedings of the USENIX Workshop on Offensive
		  Technologies (WOOT)},
  title		= {{Mouse Trap: Exploiting Firmware Updates in USB
		  Peripherals}},
  year		= {2014}
}

@Article{	  mccamant2006,
  abstract	= {Executing untrusted code while preserving security
		  requires that the code be prevented from modifying memory
		  or executing instructions except as explicitly allowed.
		  Software-based fault isolation (SFI) or “sandboxing”
		  enforces such a policy by rewriting the untrusted code at
		  the instruction level. However, the original sandboxing
		  technique of Wahbe et al. is applicable only to RISC
		  architectures, and most other previous work is either
		  insecure, or has been not described in enough detail to
		  give confidence in its security properties. We present a
		  new sandboxing technique that can be applied to a CISC
		  architecture like the IA-32, and whose application can be
		  checked at load-time to minimize the TCB. We describe an
		  implementation which provides a robust security guarantee
		  and has lowruntime overheads (an average of 21{\%} on the
		  SPECint2000 benchmarks). We evaluate the utility of the
		  technique by applying it to untrusted decompression modules
		  in an archive tool, and its safety by constructing a
		  machine-checked proof that any program approved by the
		  verification algorithm will respect the desired safety
		  property.},
  author	= {Mccamant, Stephen and Morrisett, Greg},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/pittsfield-usenix2006.pdf:pdf}
		  ,
  journal	= {USENIX Association},
  pages		= {209--224},
  title		= {{Evaluating SFI for a CISC Architecture}},
  year		= {2006}
}

@Article{	  mccune2010,
  abstract	= {An important security challenge is to protect the
		  execution of security-sensitive code on legacy systems from
		  malware that may infect the OS, applications, or system
		  devices. Prior work experienced a tradeoff between the
		  level of security achieved and efficiency. In this work, we
		  leverage the features of modern processors from AMD and
		  Intel to overcome the tradeoff to simultaneously achieve a
		  high level of security and high performance. We present
		  TrustVisor, a special-purpose hypervisor that provides code
		  integrity as well as data integrity and secrecy for
		  selected portions of an application. TrustVisor achieves a
		  high level of security, first because it can protect
		  sensitive code at a very fine granularity, and second
		  because it has a very small code base (only around 6K lines
		  of code) that makes verification feasible. TrustVisor can
		  also attest the existence of isolated execution to an
		  external entity. We have implemented TrustVisor to protect
		  security-sensitive code blocks while imposing less than
		  7{\&}amp;{\#}x025; overhead on the legacy OS and its
		  applications in the common case.},
  annote	= {1. How to enable applications to perform secure
		  computation on an untrusted OS.
		  
		  2. Design a hypervisor (TrustVisor) which provides an API
		  for application code to invoke an isolated execution
		  environment.
		  
		  3. Low overhead 7{\%} and fairly small TCB 6k.},
  author	= {McCune, Jonathan M. and Li, Yanlin and Qu, Ning and Zhou,
		  Zongwei and Datta, Anupam and Gligor, Virgil and Perrig,
		  Adrian},
  doi		= {10.1109/SP.2010.17},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  McCune et al. - Trust visor Efficient TCB reduction and
		  attestation.pdf:pdf},
  isbn		= {9780769540351},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {143--158},
  title		= {{Trust visor: Efficient TCB reduction and attestation}},
  volume	= {2009},
  year		= {2010}
}

@Article{	  monshizadeh2014,
  author	= {Monshizadeh, Maliheh and {Prasad Naldurg} and
		  Venkatakrishnan, V N},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Monshizadeh, Prasad Naldurg, Venkatakrishnan - MACE
		  Detecting Privilege Escalation Vulnerabilities in Web
		  Applications.pdf:pdf},
  isbn		= {9781450329576},
  journal	= {CCS},
  keywords	= {access control,authorization,web security},
  title		= {{MACE : Detecting Privilege Escalation Vulnerabilities in
		  Web Applications}},
  year		= {2014}
}

@Article{	  monshizadeh2014,
  author	= {Monshizadeh, Maliheh and {Prasad Naldurg} and
		  Venkatakrishnan, V N},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Monshizadeh, Prasad Naldurg, Venkatakrishnan - MACE
		  Detecting Privilege Escalation Vulnerabilities in Web
		  Applications.pdf:pdf},
  isbn		= {9781450329576},
  journal	= {CCS},
  keywords	= {access control,authorization,web security},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  title		= {{MACE : Detecting Privilege Escalation Vulnerabilities in
		  Web Applications}},
  year		= {2014}
}

@Article{	  murray2008,
  abstract	= {Virtual machine monitors (VMMs) have been hailed as the
		  basis for an increasing number of reliable or trusted
		  computing systems. The Xen VMM is a relatively small piece
		  of software -- a hypervisor -- that runs at a lower level
		  than a conventional operating system in order to provide
		  isolation between virtual machines: its size is offered as
		  an argument for its trustworthiness. However, the
		  management of a Xen-based system requires a privileged,
		  full-blown operating system to be included in the trusted
		  computing base (TCB). In this paper, we introduce our work
		  to disaggregate the management virtual machine in a
		  Xen-based system. We begin by analysing the Xen
		  architecture and explaining why the status quo results in a
		  large TCB. We then describe our implementation, which moves
		  the domain builder, the most important privileged
		  component, into a minimal trusted compartment. We
		  illustrate how this approach may be used to implement
		  "trusted virtualisation" and improve the security of
		  virtual TPM implementations. Finally, we evaluate our
		  approach in terms of the reduction in TCB size, and by
		  performing a security analysis of the disaggregated
		  system.},
  author	= {Murray, Derek Gordon and Milos, Grzegorz and Hand,
		  Steven},
  doi		= {10.1145/1346256.1346278},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Murray, Milos, Hand - Improving Xen security through
		  disaggregation.pdf:pdf},
  isbn		= {9781595937964},
  journal	= {Proceedings of the fourth ACM SIGPLAN/SIGOPS international
		  conference on Virtual execution environments - VEE '08},
  pages		= {151},
  title		= {{Improving Xen security through disaggregation}},
  url		= {http://dl.acm.org/citation.cfm?id=1346256.1346278},
  year		= {2008}
}

@Article{	  muthukumaran2015,
  author	= {Muthukumaran, Divya and Keeffe, Dan O and Priebe,
		  Christian and Eyers, David and Shand, Brian and Pietzuch,
		  Peter},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Muthukumaran et al. - FlowWatcher Defending against Data
		  Disclosure Vulnerabilities in Web Applications.pdf:pdf},
  isbn		= {9781450338325},
  journal	= {Ccs},
  keywords	= {data disclosure,http proxy,policy,web application
		  security},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {603--615},
  title		= {{FlowWatcher : Defending against Data Disclosure
		  Vulnerabilities in Web Applications}},
  year		= {2015}
}

@Article{	  narasimhan2011,
  abstract	= {Malicious modification of integrated circuits, referred to
		  as Hardware Trojans, in untrusted fabrication facility has
		  emerged as a major security threat. Logic testing
		  approaches are not very effective for detecting large
		  sequential Trojans which require multiple state transitions
		  often triggered by rare circuit events in order to activate
		  and cause malfunction. On the other hand, side-channel
		  analysis has emerged as an effective approach for detection
		  of such large sequential Trojans. However, existing
		  side-channel approaches suffer from large reduction in
		  detection sensitivity with increasing process variations or
		  decreasing Trojan size. In this paper, we propose TeSR, a
		  Temporal Self-Referencing approach that compares the
		  current signature of a chip at two different time windows
		  to completely eliminate the effect of process noise, thus
		  providing high detection sensitivity for Trojans of varying
		  size. Furthermore, unlike existing approaches, it does not
		  require golden chip instances as a reference. Simulation
		  results for three complex designs and three representative
		  sequential Trojan circuits demonstrate the effectiveness of
		  the approach under large inter- and intra-die process
		  variations.},
  author	= {Narasimhan, Seetharam and Wang, Xinmu and Du, Dongdong and
		  Chakraborty, Rajat Subhra and Bhunia, Swarup},
  doi		= {10.1109/HST.2011.5954999},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Narasimhan et al. - TeSR A robust temporal self-referencing
		  approach for Hardware Trojan detection.pdf:pdf},
  isbn		= {9781457710575},
  journal	= {2011 IEEE International Symposium on Hardware-Oriented
		  Security and Trust, HOST 2011},
  keywords	= {Hardware Trojan,Trust in IC,self-referencing,side-channel
		  analysis},
  number	= {c},
  pages		= {71--74},
  title		= {{TeSR: A robust temporal self-referencing approach for
		  Hardware Trojan detection}},
  year		= {2011}
}

@Article{	  narasimhan2012,
  author	= {Narasimhan, Seetharam and Yueh, Wen and Wang, Xinmu and
		  Mukhopadhyay, Saibal and Bhunia, Swarup},
  doi		= {10.1109/MDT.2012.2210183},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Narasimhan et al. - Improving IC security against trojan
		  attacks through integration of security monitors.pdf:pdf},
  issn		= {07407475},
  journal	= {IEEE Design and Test of Computers},
  number	= {5},
  pages		= {37--46},
  title		= {{Improving IC security against trojan attacks through
		  integration of security monitors}},
  volume	= {29},
  year		= {2012}
}

@Article{	  naumovich2004,
  annote	= {This paper analyzes the difference in permissions that are
		  granted to Enterprise Java Beans (EJBs) and the permissions
		  that the methods use.
		  
		  The authors try to tackle the problem of over/under
		  priveliege in the applicaitons. This is because a user
		  specificies which methods which role can access, but not
		  what data.
		  
		  So they statically find out which methods either call which
		  other methods that the role may not have permission for.
		  
		  Overall, the paper is eh.},
  author	= {Naumovich, Gleb and Centonze, Paolina},
  doi		= {10.1145/1022494.1022530},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Naumovich, Centonze - Static Analysis of Role-Based Access
		  Control in J2EE Applications.pdf:pdf},
  issn		= {01635948},
  journal	= {ACM SIGSOFT Software Engineering},
  month		= {sep},
  number	= {5},
  pages		= {1},
  title		= {{Static Analysis of Role-Based Access Control in J2EE
		  Applications}},
  url		= {http://portal.acm.org/citation.cfm?doid=1022494.1022530
		  http://dl.acm.org/citation.cfm?id=1022530},
  volume	= {29},
  year		= {2004}
}

@Article{	  nelson2010,
  abstract	= {Writing and maintaining firewall configurations can be
		  challenging, even for experienced system administrators.
		  Tools that uncover the consequences of configurations and
		  edits to them can help sysadmins prevent subtle yet serious
		  errors. Our tool, Margrave, offers powerful features for
		  firewall analysis, including enumerating consequences of
		  configuration edits, detecting overlaps and conflicts among
		  rules, tracing firewall behavior to specific rules, and
		  verification against security goals. Margrave differs from
		  other firewall-analysis tools in supporting queries at
		  multiple levels (rules, filters, firewalls, and networks of
		  firewalls), comparing separate firewalls in a single query,
		  supporting reflexive ACLs, and presenting exhaustive sets
		  of concrete scenarios that embody queries. Margrave
		  supports real-world firewall configuration languages,
		  decomposing them into multiple policies that capture
		  different aspects of firewall functionality. We present
		  evaluation on networking-forum posts and on an in-use
		  enterprise firewall-configuration.},
  author	= {Nelson, Timothy and Dougherty, Daniel J and Barratt,
		  Christopher and Fisler, Kathi},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Nelson et al. - The Margrave Tool for Firewall
		  Analysis.pdf:pdf},
  journal	= {Proceedings of the 24th USENIX Large Installation System
		  Administration Conference LISA 2010},
  pages		= {1--8},
  title		= {{The Margrave Tool for Firewall Analysis}},
  url		= {http://web.cs.wpi.edu/{~}tn/publications/lisa10-margrave-final.pdf}
		  ,
  year		= {2010}
}

@Article{	  newsome2005dynamic,
  title		= {Dynamic taint analysis for automatic detection, analysis,
		  and signature generation of exploits on commodity
		  software},
  author	= {Newsome, James and Song, Dawn},
  year		= {2005},
  publisher	= {Internet Society}
}

@Article{	  oberheide2012dissecting,
  title		= {Dissecting the android bouncer},
  author	= {Oberheide, Jon and Miller, Charlie},
  journal	= {SummerCon2012, New York},
  year		= {2012}
}

@Article{	  onarlioglu2010,
  abstract	= {Despite the numerous prevention and protection mechanisms
		  that have been introduced into modern operating systems,
		  the exploita- tion of memory corruption vulnerabilities
		  still represents a serious threat to the security of
		  software systems and networks. A re- cent exploitation
		  technique, called Return-Oriented Programming (ROP), has
		  lately attracted a considerable attention from academia.
		  Past research on the topic has mostly focused on refining
		  the orig- inal attack technique, or on proposing partial
		  solutions that target only particular variants of the
		  attack. In this paper, we present G-Free, a compiler-based
		  approach that represents the first practical solution
		  against any possible form of ROP. Our solution is able to
		  eliminate all unaligned free-branch instructions inside a
		  binary executable, and to protect the aligned free-branch
		  instructions to prevent them from being misused by an
		  attacker. We developed a prototype based on our approach,
		  and evaluated it by compiling GNU libc and a number of
		  real-world applications. The results of the experiments
		  show that our solution is able to prevent any form of
		  return-oriented programming.},
  author	= {Onarlioglu, Kaan and Bilge, Leyla and Lanzi, Andrea and
		  Balzarotti, Davide and Kirda, Engin},
  doi		= {10.1145/1920261.1920269},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Onarlioglu et al. - G-Free Defeating Return-Oriented
		  Programming through Gadget-less Binaries.pdf:pdf},
  isbn		= {9781450301336},
  journal	= {Proceedings of the 26th Annual Computer Security
		  Applications Conference on - ACSAC '10},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {49},
  title		= {{G-Free: Defeating Return-Oriented Programming through
		  Gadget-less Binaries}},
  url		= {http://portal.acm.org/citation.cfm?doid=1920261.1920269},
  year		= {2010}
}

@InProceedings{	  onarlioglu2013,
  abstract	= {Privacy has become an issue of paramount importance for
		  many users. As a result, encryption tools such as True
		  Crypt, OS-based full-disk encryption such as File Vault,
		  and privacy modes in all modern browsers have become
		  popular. However, although such tools are useful, they are
		  not perfect. For example, prior work has shown that
		  browsers still leave many traces of user information on
		  disk even if they are started in private browsing mode. In
		  addition, disk encryption alone is not sufficient, as key
		  disclosure through coercion remains possible. Clearly, it
		  would be useful and highly desirable to have OS-level
		  support that provides strong privacy guarantees for any
		  application -- not only browsers. In this paper, we present
		  the design and implementation of PrivExec, the first
		  operating system service for private execution. PrivExec
		  provides strong, general guarantees of private execution,
		  allowing any application to execute in a mode where storage
		  writes, either to the filesystem or to swap, will not be
		  recoverable by others during or after execution. PrivExec
		  does not require explicit application support,
		  recompilation, or any other preconditions. We have
		  implemented a prototype of PrivExec by extending the Linux
		  kernel that is performant, practical, and that secures
		  sensitive data against disclosure.},
  author	= {Onarlioglu, Kaan and Mulliner, Collin and Robertson,
		  William and Kirda, Engin},
  booktitle	= {Proceedings - IEEE Symposium on Security and Privacy},
  doi		= {10.1109/SP.2013.24},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Onarlioglu et al. - PrivExec Private execution as an
		  operating system service.pdf:pdf},
  isbn		= {9780769549774},
  issn		= {10816011},
  keywords	= {operating systems,privacy},
  pages		= {206--220},
  title		= {{PrivExec: Private execution as an operating system
		  service}},
  year		= {2013}
}

@Article{	  pappas2012,
  author	= {Pappas, Vasilis and Polychronakis, Michalis and Keromytis,
		  Angelos D.},
  doi		= {10.1109/SP.2012.41},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Pappas, Polychronakis, Keromytis - Smashing the Gadgets
		  Hindering Return-Oriented Programming Using In-Place Code
		  Randomization.pdf:pdf},
  isbn		= {978-1-4673-1244-8},
  journal	= {2012 IEEE Symposium on Security and Privacy},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {601--615},
  title		= {{Smashing the Gadgets: Hindering Return-Oriented
		  Programming Using In-place Code Randomization}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6234439}
		  ,
  year		= {2012}
}

@TechReport{	  pappas2012,
  abstract	= {The wide adoption of non-executable page protections in
		  recent versions of popular operating systems has given rise
		  to attacks that employ return-oriented programming (ROP) to
		  achieve arbitrary code execution without the injection of
		  any code. Existing defenses against ROP exploits either
		  require source code or symbolic debugging information,
		  impose a significant runtime overhead, which limits their
		  applicability for the protection of third-party
		  applications, or may require to make some assumptions about
		  the executable code of the protected applications. We
		  propose kBouncer, an efficient and fully transparent ROP
		  mitigation technique that does not requires source code or
		  debug symbols. kBouncer is based on runtime detection of
		  abnormal control transfers using hardware features found on
		  commodity processors.},
  author	= {Pappas, Vasilis},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Pappas - kBouncer Efficient and Transparent ROP
		  Mitigation.pdf:pdf},
  institution	= {Columbia University},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {1--8},
  title		= {{kBouncer : Efficient and Transparent ROP Mitigation}},
  year		= {2012}
}

@Article{	  pappas2013,
  author	= {Pappas, Vasilis and Polychronakis, Michalis and Keromytis,
		  Angelos D},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Pappas, Polychronakis, Keromytis - Transparent ROP Exploit
		  Mitigation Using Indirect Branch Tracing.pdf:pdf},
  isbn		= {9781931971034},
  journal	= {USENIX Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Transparent ROP Exploit Mitigation Using Indirect Branch
		  Tracing}},
  year		= {2013}
}

@Article{	  park2010,
  abstract	= {JTAG (Joint Test Access Group) is a powerful tool for the
		  embedded system development environments. The features of
		  JTAG, however, can be exploited by malicious users as a
		  backdoor for launching attacks, an approach which now
		  constitutes a major threat in the domain of device hacking.
		  To deny unauthenticated users access to the features of
		  JTAG port, this paper proposes a novel JTAG security
		  mechanism. The proposed solution uses authentication based
		  on credentials to achieve improved security and usability
		  over existing solutions. Our approach is easily applicable
		  to all standard JTAG environments because its structure is
		  designed to be independent from the application
		  environment. Further, the approach has lower implementation
		  cost than encryption/decryption-based solutions since only
		  hash and XOR calculations are employed in its
		  authentication protocol. The security of the proposed
		  mechanism has been verified through analysis against all
		  forms of expected attacks, and its functionality is
		  demonstrated with a real-life implementation.},
  author	= {Park, Keunyoung and Yoo, Sang Guun and Kim, Taejun and
		  Kim, Juho},
  doi		= {10.1007/s10836-010-5170-y},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Park et al. - JTAG security system based on
		  credentials.pdf:pdf},
  isbn		= {0923-8174},
  issn		= {09238174},
  journal	= {Journal of Electronic Testing: Theory and Applications
		  (JETTA)},
  keywords	= {Authentication,Credential,JTAG,Security},
  number	= {5},
  pages		= {549--557},
  title		= {{JTAG security system based on credentials}},
  volume	= {26},
  year		= {2010}
}

@Article{	  paseman2013,
  author	= {Paseman, Raymond and Orailoglu, Alex},
  doi		= {10.1109/VTS.2013.6548926},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Paseman, Orailoglu - Towards a cost-effective hardware
		  trojan detection methodology.pdf:pdf},
  isbn		= {9781467355438},
  journal	= {Proceedings of the IEEE VLSI Test Symposium},
  keywords	= {artemios g,athena,circuits,detection techniques,hardware
		  trojans horses,industrial systems
		  institute,integrated,rc,security,trusted
		  hardware,voyiatzis},
  title		= {{Towards a cost-effective hardware trojan detection
		  methodology}},
  year		= {2013}
}

@Article{	  patcha2007,
  abstract	= {As advances in networking technology help to connect the
		  distant corners of the globe and as the Internet continues
		  to expand its influence as a medium for communications and
		  commerce, the threat from spammers, attackers and criminal
		  enterprises has also grown accordingly. It is the
		  prevalence of such threats that has made intrusion
		  detection systems-the cyberspace's equivalent to the
		  burglar alarm-join ranks with firewalls as one of the
		  fundamental technologies for network security. However,
		  today's commercially available intrusion detection systems
		  are predominantly signature-based intrusion detection
		  systems that are designed to detect known attacks by
		  utilizing the signatures of those attacks. Such systems
		  require frequent rule-base updates and signature updates,
		  and are not capable of detecting unknown attacks. In
		  contrast, anomaly detection systems, a subset of intrusion
		  detection systems, model the normal system/network behavior
		  which enables them to be extremely effective in finding and
		  foiling both known as well as unknown or "zero day"
		  attacks. While anomaly detection systems are attractive
		  conceptually, a host of technological problems need to be
		  overcome before they can be widely adopted. These problems
		  include: high false alarm rate, failure to scale to gigabit
		  speeds, etc. In this paper, we provide a comprehensive
		  survey of anomaly detection systems and hybrid intrusion
		  detection systems of the recent past and present. We also
		  discuss recent technological trends in anomaly detection
		  and identify open problems and challenges in this area. ??
		  2007 Elsevier B.V. All rights reserved.},
  author	= {Patcha, Animesh and Park, Jung Min},
  doi		= {10.1016/j.comnet.2007.02.001},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Patcha, Park - An overview of anomaly detection techniques
		  Existing solutions and latest technological
		  trends.pdf:pdf},
  isbn		= {1389-1286},
  issn		= {13891286},
  journal	= {Computer Networks},
  keywords	= {Anomaly detection,Data mining,Machine learning,Statistical
		  anomaly detection,Survey},
  number	= {12},
  pages		= {3448--3470},
  title		= {{An overview of anomaly detection techniques: Existing
		  solutions and latest technological trends}},
  volume	= {51},
  year		= {2007}
}

@InProceedings{	  payet2013,
  author	= {Payet, Pierre and Doup{\'{e}}, Adam and Kruegel,
		  Christopher},
  booktitle	= {SAC},
  doi		= {10.1145/2480362.2480699},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Payet, Doup{\'{e}}, Kruegel - EARs in the Wild Large-Scale
		  Analysis of Execution After Redirect
		  Vulnerabilities.pdf:pdf},
  isbn		= {9781450316569},
  pages		= {1792--1799},
  title		= {{EARs in the Wild : Large-Scale Analysis of Execution
		  After Redirect Vulnerabilities}},
  year		= {2013}
}

@InProceedings{	  payet2013,
  author	= {Payet, Pierre and Doup{\'{e}}, Adam and Kruegel,
		  Christopher},
  booktitle	= {SAC},
  doi		= {10.1145/2480362.2480699},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Payet, Doup{\'{e}}, Kruegel - EARs in the Wild Large-Scale
		  Analysis of Execution After Redirect
		  Vulnerabilities.pdf:pdf},
  isbn		= {9781450316569},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {1792--1799},
  title		= {{EARs in the Wild : Large-Scale Analysis of Execution
		  After Redirect Vulnerabilities}},
  year		= {2013}
}

@Article{	  payne2008,
  abstract	= {Host-based security tools such as anti-virus and intrusion
		  detection systems are not adequately protected on today's
		  computers. Malware is often designed to immediately disable
		  any security tools upon installation, rendering them
		  useless. While current research has focused on moving these
		  vulnerable security tools into an isolated virtual machine,
		  this approach cripples security tools by preventing them
		  from doing active monitoring. This paper describes an
		  architecture that takes a hybrid approach, giving security
		  tools the ability to do active monitoring while still
		  benefiting from the increased security of an isolated
		  virtual machine. We discuss the architecture and a
		  prototype implementation that can process hooks from a
		  virtual machine running Windows XP on Xen. We conclude with
		  a security analysis and show the performance of a single
		  hook to be 28 musecs in the best case.},
  author	= {Payne, Bryan D. and Carbone, Martim and Sharif, Monirul
		  and Lee, Wenke},
  doi		= {10.1109/SP.2008.24},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Payne et al. - Lares An architecture for secure active
		  monitoring using virtualization.pdf:pdf},
  isbn		= {9780769531687},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {233--247},
  title		= {{Lares: An architecture for secure active monitoring using
		  virtualization}},
  year		= {2008}
}

@Article{	  pellegrino2014,
  author	= {Pellegrino, Giancarlo and Balzarotti, Davide},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Pellegrino, Balzarotti - Toward Black-Box Detection of
		  Logic Flaws in Web Applications.pdf:pdf},
  isbn		= {1891562355},
  journal	= {Network and Distributed System Security Symposium (NDSS)},
  number	= {February},
  pages		= {23--26},
  title		= {{Toward Black-Box Detection of Logic Flaws in Web
		  Applications}},
  url		= {http://s3.eurecom.fr/docs/ndss14{\_}pellegrino.pdf},
  year		= {2014}
}

@Article{	  pellegrino2014,
  author	= {Pellegrino, Giancarlo and Balzarotti, Davide},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Pellegrino, Balzarotti - Toward Black-Box Detection of
		  Logic Flaws in Web Applications.pdf:pdf},
  isbn		= {1891562355},
  journal	= {Network and Distributed System Security Symposium (NDSS)},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  number	= {February},
  pages		= {23--26},
  title		= {{Toward Black-Box Detection of Logic Flaws in Web
		  Applications}},
  url		= {http://s3.eurecom.fr/docs/ndss14{\_}pellegrino.pdf},
  year		= {2014}
}

@Article{	  perez-botero2013,
  abstract	= {The rise of the Cloud Computing paradigm has led to
		  security concerns, taking into account that resources are
		  shared and mediated by a Hypervisor which may be targeted
		  by rogue guest VMs and remote attackers. In order to better
		  define the threats to which a cloud server's Hypervisor is
		  exposed, we conducted a thorough analysis of the codebase
		  of two popular open-source Hypervisors, Xen and KVM,
		  followed by an extensive study of the vulnerability reports
		  associated with them. Based on our findings, we propose a
		  characterization of Hypervisor Vulnerabilities comprised of
		  three dimensions: the trigger source (i.e. where the
		  attacker is located), the attack vector (i.e. the
		  Hypervisor functionality that enables the security breach),
		  and the attack target (i.e. the runtime domain that is
		  compromised). This can be used to understand potential
		  paths different attacks can take, and which vulnerabilities
		  enable them. Moreover, most common paths can be discovered
		  to learn where the defenses should be focused, or
		  conversely, least common paths can be used to find
		  yet-unexplored ways attackers may use to get into the
		  system. © 2013 ACM.},
  author	= {Perez-Botero, Diego and Szefer, Jakub and Lee, Ruby B.},
  doi		= {10.1145/2484402.2484406},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Perez-botero, Szefer, Lee - Characterizing Hypervisor
		  Vulnerabilities in Cloud Computing Servers.pdf:pdf},
  isbn		= {9781450320672},
  journal	= {Proceedings of the 2013 international workshop on Security
		  in cloud computing - Cloud Computing '13},
  keywords	= {attack vectors,hypervisor vulnerabilities,secure cloud
		  computing,virtualization,vulnerability categorization},
  mendeley-groups={4 - Hypervisor},
  number	= {May},
  pages		= {3},
  title		= {{Characterizing hypervisor vulnerabilities in cloud
		  computing servers}},
  url		= {http://dl.acm.org/citation.cfm?doid=2484402.2484406},
  year		= {2013}
}

@Article{	  petroni2004,
  abstract	= {Copilot is a coprocessor-based kernel integrity monitor
		  for commodity systems. Copilot is designed to detect mali-
		  cious modifications to a host’s kernel and has correctly
		  de- tected the presence of 12 real-world rootkits, each
		  within 30 seconds of their installation with less than a
		  1{\%} penalty to the host’s performance. Copilot requires
		  no modifica- tions to the protected host’s software and
		  can be expected to operate correctly even when the host
		  kernel is thoroughly compromised – an advantage over
		  traditional monitors de- signed to run on the host itself.},
  archiveprefix	= {arXiv},
  arxivid	= {20},
  author	= {Petroni, Nick L. and Fraser, Timothy and Molina, Jesus and
		  Arbaugh, William a.},
  doi		= {10.1145/358198.358210},
  eprint	= {20},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Petroni et al. - Copilot - a Coprocessor-based Kernel
		  Runtime Integrity Monitor.pdf:pdf},
  issn		= {09518320},
  journal	= {USENIX Security Symposium},
  pages		= {179--194},
  title		= {{Copilot - a Coprocessor-based Kernel Runtime Integrity
		  Monitor}},
  year		= {2004}
}

@Article{	  petroni2007,
  abstract	= {This paper presents a new approach to dynamically moni-
		  toring operating system kernel integrity, based on a
		  property called state-based control- ow integrity (SBCFI).
		  Violations of SBCFI signal a persistent, unexpected modi
		  cation of the kernel's control- ow graph. We performed a
		  thorough anal- ysis of 25 Linux rootkits and found that 24
		  (96{\%}) employ persistent control- ow modi cations; an
		  informal study of Windows rootkits yielded similar results.
		  We have imple- mented SBCFI enforcement as part of the Xen
		  and VMware virtual machine monitors. Our implementation
		  detected all the control- ow modifying rootkits we could
		  install, while imposing negligible overhead for both a
		  typical web server workload and CPU-intensive workloads
		  when operating at 1 second intervals on a multi-core
		  machine.},
  author	= {Petroni, Nick L and Hicks, Michael},
  doi		= {10.1145/1315245.1315260},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Petroni, Hicks - Automated detection of persistent kernel
		  control-flow attacks.pdf:pdf},
  isbn		= {9781595937032},
  issn		= {15437221},
  journal	= {ACM conference on Computer and communications security
		  (CCS) (2007)},
  keywords	= {cfi,integrity,kernel,rootkit,virtualization},
  pages		= {103--115},
  title		= {{Automated detection of persistent kernel control-flow
		  attacks}},
  year		= {2007}
}

@Article{	  polychronakis2011,
  abstract	= {The prevalence of code injection attacks has led to the
		  wide adoption of exploit mitigations based on nonexecutable
		  memory pages. In turn, attackers are increasingly relying
		  on return-oriented programming (ROP) to bypass these
		  protections. At the same time, existing detection
		  techniques based on shellcode identification are oblivious
		  to this new breed of exploits, since attack vectors may not
		  contain binary code anymore. In this paper, we present a
		  detection method for the identification of ROP payloads in
		  arbitrary data such as network traffic or process memory
		  buffers. Our technique speculatively drives the execution
		  of code that already exists in the address space of a
		  targeted process according to the scanned input data, and
		  identifies the execution of valid ROP code at runtime. Our
		  experimental evaluation demonstrates that our prototype
		  implementation can detect a broad range of ROP exploits
		  against Windows applications without false positives, while
		  it can be easily integrated into existing defenses based on
		  shell-code detection.},
  author	= {Polychronakis, Michalis and Keromytis, Angelos D.},
  doi		= {10.1109/MALWARE.2011.6112327},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Polychronakis, Keromytis - ROP Payload Detection Using
		  Speculative Code Execution.pdf:pdf},
  isbn		= {9781467300339},
  journal	= {Proceedings of the 2011 6th International Conference on
		  Malicious and Unwanted Software, Malware 2011},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {58--65},
  title		= {{ROP payload detection using speculative code execution}},
  year		= {2011}
}

@Article{	  qu2011,
  abstract	= {Automatic testing, in particular test input generation,
		  has become increasingly popular in the research community
		  over the past ten years. In this paper, we conduct a survey
		  on existing concolic testing tools, discussing their
		  strengths and limitations, and environments in which they
		  can be applied. We also conduct a case study to determine
		  the prevalence of the identified limitations in six large
		  software systems (four from open-source and two from ABB),
		  as well as the effectiveness and scalability of the
		  publicly available tools. The results show that pointers
		  and native calls are the most prevalent limitations,
		  preventing tools from generating high branch coverage test
		  cases, and variables of float type are the least prevalent.
		  The scalability of the publically available tools is also a
		  limitation for industrial use, due to the large overhead of
		  creating a test harness. Finally, we propose suggestions on
		  how practitioners can use these tools and how researchers
		  can improve concolic testing.},
  author	= {Qu, Xiao and Robinson, Brian},
  doi		= {10.1109/ESEM.2011.20},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Qu,
		  Robinson - A Case Study of Concolic Testing Tools and their
		  Limitations.pdf:pdf},
  isbn		= {978-0-7695-4604-9},
  issn		= {1938-6451},
  journal	= {2011 International Symposium on Empirical Software
		  Engineering and Measurement},
  keywords	= {automatic test generation,concolic testing},
  number	= {August},
  pages		= {117--126},
  title		= {{A Case Study of Concolic Testing Tools and their
		  Limitations}},
  year		= {2011}
}

@Article{	  rajendran2013,
  author	= {Rajendran, Jeyavijayan J V and Kanuparthi, Arun Karthik
		  and Karri, Ramesh and Addepalli, Sateesh K. and Zahran,
		  Mohamed and Ormazabal, Gaston},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Rajendran et al. - Securing Processors Against Insider
		  Attacks A Circuit-Microarchitecture Co-Design
		  Approach.pdf:pdf},
  journal	= {IEEE Design {\&} Test},
  number	= {April},
  pages		= {35--44},
  title		= {{Securing Processors Against Insider Attacks : A
		  Circuit-Microarchitecture Co-Design Approach}},
  year		= {2013}
}

@InProceedings{	  ren2015,
  author	= {Ren, Xuanle and Tavares, Grade and Blanton, R D Shawn},
  booktitle	= {Proceedings of the Design, Automation {\&} Test in Europe
		  Conference {\&} Exhibition (DATE)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Ren, Tavares, Blanton - Detection of Illegitimate Access to
		  JTAG via Statistical Learning in Chip.pdf:pdf},
  isbn		= {9783981537048},
  pages		= {109--114},
  title		= {{Detection of Illegitimate Access to JTAG via Statistical
		  Learning in Chip}},
  year		= {2015}
}

@Article{	  riley2008,
  abstract	= {Kernel rootkits pose a significant threat to computer
		  systems as they run at the highest privilege level and have
		  unrestricted access to the resources of their victims. Many
		  current efforts in kernel rootkit defense focus on the
		  detection of kernel rootkits - after a rootkit attack has
		  taken place, while the smaller number of efforts in kernel
		  rootkit prevention exhibit limitations in their capability
		  or deployability. In this paper we present a kernel rootkit
		  prevention system called NICKLE which addresses a common,
		  fundamental characteristic of most kernel rootkits: the
		  need for executing their own kernel code. NICKLE is a
		  lightweight, virtual machine monitor (VMM) based system
		  that transparently prevents unauthorized kernel code
		  execution for unmodified commodity (guest) OSes. NICKLE is
		  based on a new scheme called memory shadowing, wherein the
		  trusted VMM maintains a shadow physical memory for a
		  running VM and performs real-time kernel code
		  authentication so that only authenticated kernel code will
		  be stored in the shadow memory. Further, NICKLE
		  transparently routes guest kernel instruction fetches to
		  the shadow memory at runtime. By doing so, NICKLE
		  guarantees that only the authenticated kernel code will be
		  executed, foiling the kernel rootkit's attempt to strike in
		  the first place. We have implemented NICKLE in three VMM
		  platforms: QEMU+KQEMU, VMware Workstation, and VirtualBox.
		  Our experiments with 23 real-world kernel rootkits
		  targeting the Linux or Windows OSes demonstrate NICKLE's
		  effectiveness. Furthermore, our performance evaluation
		  shows that NICKLE introduces small overhead to the VMM
		  platform (e.g., < 2{\%} to QEMU+KQEMU).},
  author	= {Riley, Ryan and Jiang, Xuxian and Xu, Dongyan},
  doi		= {10.1007/978-3-540-87403-4{\_}1},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Riley, Jiang, Xu - Guest-transparent prevention of kernel
		  rootkits with VMM-based memory shadowing.pdf:pdf},
  isbn		= {354087402X},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  number	= {1},
  pages		= {1--20},
  title		= {{Guest-transparent prevention of kernel rootkits with
		  VMM-based memory shadowing}},
  volume	= {5230 LNCS},
  year		= {2008}
}

@Article{	  riley2008a,
  abstract	= {Kernel rootkits pose a significant threat to computer
		  systems as they run at the highest privilege level and have
		  unrestricted access to the resources of their victims. Many
		  current efforts in kernel rootkit defense focus on the
		  detection of kernel rootkits - after a rootkit attack has
		  taken place, while the smaller number of efforts in kernel
		  rootkit prevention exhibit limitations in their capability
		  or deployability. In this paper we present a kernel rootkit
		  prevention system called NICKLE which addresses a common,
		  fundamental characteristic of most kernel rootkits: the
		  need for executing their own kernel code. NICKLE is a
		  lightweight, virtual machine monitor (VMM) based system
		  that transparently prevents unauthorized kernel code
		  execution for unmodified commodity (guest) OSes. NICKLE is
		  based on a new scheme called memory shadowing, wherein the
		  trusted VMM maintains a shadow physical memory for a
		  running VM and performs real-time kernel code
		  authentication so that only authenticated kernel code will
		  be stored in the shadow memory. Further, NICKLE
		  transparently routes guest kernel instruction fetches to
		  the shadow memory at runtime. By doing so, NICKLE
		  guarantees that only the authenticated kernel code will be
		  executed, foiling the kernel rootkit's attempt to strike in
		  the first place. We have implemented NICKLE in three VMM
		  platforms: QEMU+KQEMU, VMware Workstation, and VirtualBox.
		  Our experiments with 23 real-world kernel rootkits
		  targeting the Linux or Windows OSes demonstrate NICKLE's
		  effectiveness. Furthermore, our performance evaluation
		  shows that NICKLE introduces small overhead to the VMM
		  platform (e.g., < 2{\%} to QEMU+KQEMU).},
  author	= {Riley, Ryan and Jiang, Xuxian and Xu, Dongyan},
  doi		= {10.1007/978-3-540-87403-4{\_}1},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Riley, Jiang, Xu - Guest-transparent prevention of kernel
		  rootkits with VMM-based memory shadowing(2).pdf:pdf},
  isbn		= {354087402X},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  pages		= {1--20},
  title		= {{Guest-transparent prevention of kernel rootkits with
		  VMM-based memory shadowing}},
  volume	= {5230 LNCS},
  year		= {2008}
}

@InProceedings{	  robin2000,
  abstract	= {A virtual machine monitor (VMM) allows multiple operating
		  systems to run concurrently on virtual machines (VMs) on a
		  single hardware platform. Each VM can be treated as an
		  independent operating system platform. A secure VMM would
		  enforce an overarching security policy on its VMs. The
		  potential benefits of a secure VMM for PCs include: a more
		  secure environment, familiar COTS operating systems and
		  applications, and enormous savings resulting from the
		  elimination of the need for separate platforms when both
		  high assurance policy enforcement, and COTS software are
		  required. This paper addresses the problem of implementing
		  secure VMMs on the Intel Pentium architecture. The
		  requirements for various types of VMMs are reviewed. We
		  report an analysis of the virtualizability of all of the
		  approximately 250 instructions of the Intel Pentium
		  platform and address its ability to support a VMM. Current
		  "virtualization" techniques for the Intel Pentium
		  architecture are examined and several security problems are
		  identified. An approach to providing a virtualizable
		  hardware base for a highly secure VMM is discussed.},
  author	= {Robin, John Scott and Irvine, Cynthia E},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  doi		= {10.1109/MSP.2010.92},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2000 -
		  Robin, Irvine - Analysis of the Intel Pentium's ability to
		  support a secure virtual machine monitor.pdf:pdf},
  issn		= {15407993},
  number	= {3},
  pages		= {10},
  title		= {{Analysis of the Intel Pentium's ability to support a
		  secure virtual machine monitor}},
  url		= {http://portal.acm.org/citation.cfm?id=1251316},
  volume	= {8},
  year		= {2000}
}

@Article{	  roemer2012,
  author	= {Roemer, Ryan and Buchanan, Erik and Shacham, Hovav and
		  Savage, Stefan},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Roemer et al. - Return-Oriented Programming Systems ,
		  Languages , and Applications.pdf:pdf},
  journal	= {ACM Transactions on Information and System Security
		  (TISSEC)},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {1--36},
  title		= {{Return-Oriented Programming : Systems , Languages , and
		  Applications}},
  volume	= {V},
  year		= {2012}
}

@Article{	  roesch1999,
  abstract	= {Network intrusion detection systems (NIDS) are an
		  important part of any network security architecture. They
		  provide a layer of defense which monitors network traffic
		  for predefined suspicious activity or patterns, and alert
		  system administrators when potential hostile traffic is
		  detected. Commercial NIDS have many differences, but
		  Information Systems departments must face the commonalities
		  that they share such as significant system footprint,
		  complex deployment and high monetary cost. Snort was
		  designed to address these issues.},
  author	= {Roesch, M},
  doi		= {http://portal.acm.org/citation.cfm?id=1039834.1039864},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/1999 -
		  Roesch - Snort Lightweight Intrusion Detection for
		  Networks.pdf:pdf},
  isbn		= {1-880446-25-1},
  journal	= {LISA '99: 13th Systems Administration Conference},
  pages		= {229--238},
  title		= {{Snort: Lightweight Intrusion Detection for Networks.}},
  url		= {http://static.usenix.org/publications/library/proceedings/lisa99/full{\_}papers/roesch/roesch.pdf}
		  ,
  year		= {1999}
}

@Article{	  rolt2014,
  author	= {Rolt, Jean Da and Natale, Giorgio Di and Flottes,
		  Marie-lise and Rouzeyre, Bruno},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Rolt et al. - Thwarting Scan-Based Attacks on Secure-ICs
		  With On-Chip Comparison.pdf:pdf},
  journal	= {IEEE Transactions on Very Large Scale Integration (VLSI)
		  Systems},
  number	= {4},
  pages		= {947--951},
  title		= {{Thwarting Scan-Based Attacks on Secure-ICs With On-Chip
		  Comparison}},
  volume	= {22},
  year		= {2014}
}

@Article{	  rosenfeld2010,
  abstract	= {JTAG is a well-known standard mechanism for in-field test.
		  Although it provides high controllability and
		  observability, it also poses great security challenges.
		  This article analyzes various attacks and proposes
		  protection schemes.},
  author	= {Rosenfeld, Kurt and Karri, Ramesh},
  doi		= {10.1109/MDT.2010.9},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Rosenfeld, Karri - Attacks and defenses for JTAG.pdf:pdf},
  issn		= {07407475},
  journal	= {IEEE Design and Test of Computers},
  number	= {1},
  pages		= {36--47},
  title		= {{Attacks and defenses for JTAG}},
  volume	= {27},
  year		= {2010}
}

@Article{	  rosenfeld2011,
  abstract	= {Test access mechanisms are critical components in digital
		  systems. They affect not only production and operational
		  economics, but also system security. We propose a security
		  enhancement for system-on-chip (SoC) test access that
		  addresses the threat posed by untrustworthy cores. The
		  scheme maintains the economy of shared wiring (bus or
		  daisy-chain) while achieving most of the security benefits
		  of star-topology test access wiring. Using the proposed
		  scheme, the tester is able to establish distinct
		  cryptographic session keys with each of the cores,
		  significantly reducing the exposure in cases where one or
		  more of the cores contains malicious or otherwise
		  untrustworthy logic. The proposed scheme is out of the
		  functional path and does not affect functional timing or
		  power consumption.},
  author	= {Rosenfeld, Kurt and Karri, Ramesh},
  doi		= {10.1109/VTS.2011.5783765},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Rosenfeld, Karri - Security-aware SoC test access
		  mechanisms.pdf:pdf},
  isbn		= {9781612846552},
  issn		= {1093-0167},
  journal	= {Proceedings of the IEEE VLSI Test Symposium},
  pages		= {100--104},
  title		= {{Security-aware SoC test access mechanisms}},
  year		= {2011}
}

@Article{	  rouf2010,
  abstract	= {Wireless networks are being integrated into the modern
		  automobile. The security and privacy implications of such
		  in-car networks, however, have are not well understood as
		  their transmissions propagate beyond the con- nes of a
		  car's body. To understand the risks associated with these
		  wireless systems, this paper presents a privacy and
		  security evaluation of wireless Tire Pressure Monitoring
		  Systems using both laboratory experiments with isolated
		  tire pressure sensor modules and experiments with a
		  complete vehicle system. We show that eavesdropping is
		  easily possible at a distance of roughly 40m from a passing
		  vehicle. Further, reverse-engineering of the underlying
		  protocols revealed static 32 bit identi- ers and that
		  messages can be easily triggered remotely, which raises
		  privacy concerns as vehicles can be tracked through these
		  identiers. Further, current protocols do not employ
		  authentication and vehicle implementations do not perform
		  basic input validation, thereby allowing for remote spoong
		  of sensor messages. We validated this experimentally by
		  triggering tire pressure warning messages in a moving
		  vehicle from a customized software radio attack platform
		  located in a nearby vehicle. Finally, the paper concludes
		  with a set of recommendations for improving the privacy and
		  security of tire pressure monitoring systems and other
		  forthcoming in-car wireless sensor networks.},
  author	= {Rouf, Ishtiaq and Miller, Rob and Mustafa, Hossen and
		  Taylor, Travis and Oh, Sangho and Xu, Wenyuan and Grutese,
		  Marco and Trappe, Wade and Seskar, Ivan},
  doi		= {10.1177/004057368303900411},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Rouf et al. - Security and privacy vulnerabilities of
		  in-car wireless networks A tire pressure monitoring system
		  case study.pdf:pdf},
  isbn		= {888-7-6666-5555-4},
  issn		= {0040-5736},
  journal	= {Proceedings of the USENIX Security Symposium},
  number	= {4},
  pages		= {11--13},
  title		= {{Security and privacy vulnerabilities of in-car wireless
		  networks: A tire pressure monitoring system case study.}},
  volume	= {39},
  year		= {2010}
}

@Article{	  ruprecht2014,
  author	= {Ruprecht, Andreas and Heinloth, Bernhard and Lohmann,
		  Daniel},
  doi		= {10.1145/2775053.2658767},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Ruprecht, Heinloth, Lohmann - Automatic feature selection
		  in large-scale system-software product lines:},
  isbn		= {978-1-4503-3161-6},
  issn		= {03621340},
  journal	= {ACM SIGPLAN Notices},
  keywords	= {Feature Selection,Linux,Software Product Lines,Software
		  Tailoring},
  mendeley-groups={6 - Application/Attack surface reduction},
  number	= {3},
  pages		= {39--48},
  title		= {{Automatic feature selection in large-scale
		  system-software product lines}},
  url		= {http://dl.acm.org/citation.cfm?id=2775053.2658767},
  volume	= {50},
  year		= {2014}
}

@Article{	  sailer2004,
  abstract	= {We present the design and implementation of a secure
		  integrity measurement system for Linux. All executable con-
		  tent that is loaded onto the Linux system is measured
		  before execution and these measurements are protected by
		  the Trusted Platform Module (TPM) that is part of the
		  Trusted Computing Group (TCG) standards. Our system is the
		  first to extend the TCG trust measurement concepts to
		  dynamic executable content from the BIOS all the way up
		  into the application layer. In effect, we show that many of
		  the Microsoft NGSCB guarantees can be obtained on today’s
		  hardware and today’s software and that these guarantees
		  do not require a new CPU mode or operating system but
		  merely depend on the availability of an independent trusted
		  entity, a TPM for example. We apply our trust measurement
		  architecture to a web server application where we show how
		  our system can detect undesirable invocations, such as
		  rootkit programs, and that our measurement architecture is
		  practical in terms of the number of measurements taken and
		  the performance impact of making them.},
  annote	= {1. How to implement integrity verification in a real-world
		  system?
		  
		  2. Use the TPM to store the integrity checks.
		  
		  3. Implemented a real integrity verification system using
		  Linux using the TPM.},
  author	= {Sailer, Reiner and Zhang, Xiaolan and Jaeger, Trent and
		  Doorn, Leendert Van},
  doi		= {10.1109/MSP.2010.92},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Sailer et al. - Design and Implementation of a TCG-based
		  Integrity Measurement Architecture.pdf:pdf},
  issn		= {15407993},
  journal	= {USENIX Security Symposium},
  pages		= {17},
  title		= {{Design and Implementation of a TCG-based Integrity
		  Measurement Architecture}},
  year		= {2004}
}

@Article{	  salmani2009,
  abstract	= {Hardware Trojans in integrated circuits and systems have
		  become serious concern to fabless semiconductor industry
		  and government agencies in recent years. Most of the
		  previously proposed Trojan detection methods rely on Trojan
		  activation to either observe a faulty output or measure
		  side-channel signals such as transient current or charge.
		  From the authentication stand point, time to trigger a
		  hardware Trojan circuit is a a major concern. This paper
		  analyzes time to (i) generate a transition in functional
		  Trojans and (ii) fully activate them. An efficient dummy
		  flip-flop insertion procedure is proposed to increase
		  Trojan activity. Depending on authentication time and
		  circuit topology, a transition probability threshold is
		  selected so that inserted dummy flip-flops would moderately
		  impact area overhead. The simulation results on s38417
		  benchmark circuit demonstrate that, with a negligible area
		  overhead, our proposed method can significantly increase
		  Trojan activity and reduce Trojan activation time.},
  author	= {Salmani, H and Tehranipoor, Mohammad and Plusquellic,
		  Jim},
  doi		= {10.1109/HST.2009.5224968},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Salmani, Tehranipoor, Plusquellic - New design strategy for
		  improving hardware trojan detection and reducing trojan
		  activation ti.pdf:pdf},
  isbn		= {9781424448043},
  journal	= {Hardware-Oriented {\ldots}},
  pages		= {66--73},
  title		= {{New design strategy for improving hardware trojan
		  detection and reducing trojan activation time}},
  url		= {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=5224968}
		  ,
  year		= {2009}
}

@InProceedings{	  samuel2011,
  author	= {Samuel, Mike and Saxena, Prateek and Song, Dawn},
  booktitle	= {Proceedings of the 18th ACM Conference on Computer and
		  Communications Security (CCS 2011)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Samuel, Saxena, Song - Context-sensitive auto-sanitization
		  in web templating languages using type qualifiers.pdf:pdf},
  isbn		= {9781450309486},
  keywords	= {cross-site scripting,type systems},
  title		= {{Context-sensitive auto-sanitization in web templating
		  languages using type qualifiers}},
  url		= {http://dl.acm.org/citation.cfm?id=2046775},
  year		= {2011}
}

@Article{	  sang2010,
  abstract	= {It is difficult to protect an operating system kernel in
		  an efficient way. Attackers can corrupt or subvert it by
		  two different means: (1) the CPU; (2) the Direct Memory
		  Access (DMA) capability of I/O controllers. DMA-based
		  attacks can be blocked using an I/OMMU. This component,
		  embedded in most of current chipsets, enables the operating
		  system to virtualize the main memory for I/O controllers
		  and to restrict their access to only some memory regions.
		  In this paper, we present different vulnerabilities we
		  identified on Intel VT-d, which implements an I/OMMU. An
		  example of exploitation of one of them is then detailed.
		  Finally, we give some recommendations to prevent these
		  vulnerabilities from being used for malicious purposes.},
  author	= {Sang, Fernand Lone and Lacombe, {\'{E}}ric ́ and
		  Nicomette, Vincent and Deswarte, Yves},
  doi		= {10.1109/MALWARE.2010.5665798},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Sang et al. - Exploiting an IOMMU vulnerability.pdf:pdf},
  isbn		= {9781424493555},
  journal	= {Proceedings of the 5th IEEE International Conference on
		  Malicious and Unwanted Software (MALWARE)},
  pages		= {7--14},
  title		= {{Exploiting an I/OMMU vulnerability}},
  year		= {2010}
}

@Article{	  sasaki2012,
  abstract	= {Malicious insiders are difficult to detect and prevent,
		  because insiders such as employees have legitimate rights
		  to access organization's resources in order to carry out
		  their responsibilities. To overcome this problem, we have
		  developed a framework that detects suspicious insiders
		  using a psychological trigger that impels malicious
		  insiders to behave suspiciously. Also, we have proposed an
		  architecture comprising an announcer, a monitor, and an
		  analyzer. First, the announcer creates an event (called a
		  "trigger") that impels malicious insiders to behave
		  suspiciously. Then the monitors record suspicious actions
		  such as file/e-mail deletions. Finally, the analyzer
		  identifies the suspicious insiders by comparing the number
		  of deletions before/after the trigger. In this paper, we
		  extend monitoring reaction from only "data deletion" to
		  "stop further malicious activities". This extension allows
		  a wider variety of use cases such as "finding private web
		  browsing" and "finding use of unnecessary applications".
		  Also, we extend the architecture so as to monitor servers
		  as well as clients. The server monitoring architecture is
		  required in the case of server side data deletions, i.e.,
		  e-mail or file deletions at the server side. Moreover, we
		  describe the effectiveness of our approach in such cases.},
  author	= {Sasaki, T.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Sasaki - A framework for detecting insider threats using
		  psychological triggers.pdf:pdf},
  issn		= {20935374},
  journal	= {Journal of Wireless Mobile Networks, Ubiquitous Computing,
		  and Dependable Applications},
  keywords	= {Insider threats detection,Sealing of evidences},
  number	= {1-2},
  pages		= {99--119},
  title		= {{A framework for detecting insider threats using
		  psychological triggers}},
  url		= {http://www.scopus.com/inward/record.url?eid=2-s2.0-84886872895{\&}partnerID=tZOtx3y1}
		  ,
  volume	= {3},
  year		= {2012}
}

@Article{	  saxena2008,
  abstract	= {Fine-grained binary instrumentations, such as those for
		  taint-tracking, have become very popular in computer
		  security due to their applications in exploit detection,
		  sandboxing, malware analysis, etc. However, practical
		  application of taint-tracking has been limited by high
		  performance overheads. For instance, previous software
		  based techniques for taint-tracking on binary code have
		  typically slowed down programs by a factor of 3 or more. In
		  contrast, source-code based techniques have achieved better
		  performance using high level optimizations. Unfortunately,
		  these optimizations are difficult to perform on binaries
		  since much of the high level program structure required by
		  such static analyses is lost during the compilation
		  process. In this paper, we address this challenge by
		  developing static techniques that can recover some of the
		  higher level structure from x86 binaries. Our new static
		  analysis enables effective optimizations, which are applied
		  in the context of taint tracking. As a result, we achieve a
		  substantial reduction in performance overheads as compared
		  to previous works.},
  author	= {Saxena, Prateek and Saxena, Prateek and Sekar, R and
		  Sekar, R and Puranik, Varun and Puranik, Varun},
  doi		= {10.1145/1356058.1356069},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Saxena et al. - Efficient Fine-Grained Binary
		  Instrumentation with Applications to
		  Taint-Tracking.pdf:pdf},
  isbn		= {978-1-59593-978-4},
  journal	= {Cgo},
  keywords	= {binary analysis/rewriting,information flow,taint
		  tracking},
  pages		= {9},
  title		= {{Efficient Fine-Grained Binary Instrumentation with
		  Applications to Taint-Tracking}},
  url		= {http://portal.acm.org/citation.cfm?id=1356069},
  year		= {2008}
}

@InProceedings{	  saxena2011,
  address	= {Chicago, IL},
  author	= {Saxena, Prateek and Molnar, David and Livshits, Benjamin},
  booktitle	= {Proceedings of the 18th ACM Conference on Computer and
		  Communications Security (CCS 2011)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Saxena, Molnar, Livshits - ScriptGard Automatic
		  Context-Sensitive Sanitization for Large-Scale Legacy Web
		  Applications Categorie.pdf:pdf},
  isbn		= {9781450309486},
  keywords	= {cross-site scripting,runtime analysis,web applications},
  pages		= {601----614},
  title		= {{ScriptGard : Automatic Context-Sensitive Sanitization for
		  Large-Scale Legacy Web Applications Categories and Subject
		  Descriptors}},
  year		= {2011}
}

@InProceedings{	  saxena2011,
  address	= {Chicago, IL},
  author	= {Saxena, Prateek and Molnar, David and Livshits, Benjamin},
  booktitle	= {Proceedings of the 18th ACM Conference on Computer and
		  Communications Security (CCS 2011)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Saxena, Molnar, Livshits - ScriptGard Automatic
		  Context-Sensitive Sanitization for Large-Scale Legacy Web
		  Applications Categorie.pdf:pdf},
  isbn		= {9781450309486},
  keywords	= {cross-site scripting,runtime analysis,web applications},
  pages		= {601----614},
  title		= {{ScriptGard : Automatic Context-Sensitive Sanitization for
		  Large-Scale Legacy Web Applications Categories and Subject
		  Descriptors}},
  year		= {2011}
}

@InProceedings{	  scholte2012,
  author	= {Scholte, Theodoor and Robertson, William K and Balzarotti,
		  Davide and Kirda, Engin},
  booktitle	= {Computer Software and Applications Conference (COMPSAC),
		  2010 IEEE 36 Annual},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Scholte et al. - Preventing Input Validation
		  Vulnerabilities in Web Applications through Automated Type
		  Analysis.pdf:pdf},
  title		= {{Preventing Input Validation Vulnerabilities in Web
		  Applications through Automated Type Analysis}},
  url		= {http://iseclab.org/papers/compsac-scholte.pdf},
  year		= {2012}
}

@Article{	  schuett2014,
  author	= {Schuett, Carl and Butts, Jonathan and Dunlap, Stephen},
  doi		= {10.1016/j.ijcip.2013.04.004},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Schuett, Butts, Dunlap - An evaluation of modification
		  attacks on programmable logic controllers.pdf:pdf},
  issn		= {18745482},
  journal	= {International Journal of Critical Infrastructure
		  Protection},
  keywords	= {Firmware,Industrial control systems,Modification
		  attacks,Programmable logic controllers,Reverse
		  engineering},
  number	= {2},
  pages		= {76--84},
  publisher	= {Elsevier},
  title		= {{An evaluation of modification attacks on programmable
		  logic controllers}},
  url		= {http://dx.doi.org/10.1016/j.ijcip.2014.01.004},
  year		= {2014}
}

@Article{	  schuster2014,
  author	= {Schuster, Felix and Tendyck, Thomas and Pewny, Jannik and
		  Maa{\ss}, Andreas and Steegmanns, Martin and Contag, Moritz
		  and Holz, Thorsten and Horst, G},
  doi		= {10.1007/978-3-319-11379-1{\_}5},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Schuster et al. - Evaluating the Effectiveness of Current
		  Anti-ROP Defenses.pdf:pdf},
  isbn		= {331911378X},
  journal	= {Research in Attacks, Intrusions and Defenses},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {1--22},
  title		= {{Evaluating the Effectiveness of Current Anti-ROP
		  Defenses}},
  year		= {2014}
}

@Article{	  schuster2015,
  abstract	= {—Code reuse attacks such as return-oriented program-ming
		  (ROP) have become prevalent techniques to exploit memory
		  corruption vulnerabilities in software programs. A variety
		  of corresponding defenses has been proposed, of which some
		  have already been successfully bypassed—and the arms race
		  continues. In this paper, we perform a systematic
		  assessment of recently proposed CFI solutions and other
		  defenses against code reuse attacks in the context of C++.
		  We demonstrate that many of these defenses that do not
		  consider object-oriented C++ semantics pre-cisely can be
		  generically bypassed in practice. Our novel attack
		  technique, denoted as counterfeit object-oriented
		  programming (COOP), induces malicious program behavior by
		  only invoking chains of existing C++ virtual functions in a
		  program through corresponding existing call sites. COOP is
		  Turing complete in realistic attack scenarios and we show
		  its viability by developing sophisticated, real-world
		  exploits for Internet Explorer 10 on Windows and Firefox 36
		  on Linux. Moreover, we show that even recently proposed
		  defenses (CPS, T-VIP, vfGuard, and VTint) that specifically
		  target C++ are vulnerable to COOP. We observe that
		  constructing defenses resilient to COOP that do not require
		  access to source code seems to be challenging. We believe
		  that our investigation and results are helpful
		  contributions to the design and implementation of future
		  defenses against control-flow hijacking attacks.},
  author	= {Schuster, Felix and Tendyck, Thomas and Liebchen,
		  Christopher and Davi, Lucas and Sadeghi, Ahmad-Reza and
		  Holz, Thorsten},
  doi		= {10.1109/SP.2015.51},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Schuster et al. - Counterfeit Object-oriented Programming
		  On the Difficulty of Preventing Code Reuse Attacks in C
		  Application.pdf:pdf},
  isbn		= {9781467369497},
  issn		= {1081-6011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  title		= {{Counterfeit Object-oriented Programming On the Difficulty
		  of Preventing Code Reuse Attacks in C++ Applications}},
  year		= {2015}
}

@Article{	  schwartz2011,
  abstract	= {Prior work has shown that return oriented programming
		  (ROP) can be used to bypass WX, a software defense that
		  stops shellcode, by reusing instructions from large
		  libraries such as libc. Modern operating systems have since
		  enabled address randomization (ASLR), which randomizes the
		  location of libc, making these techniques unusable in
		  practice. However, modern ASLR implementations leave
		  smaller amounts of executable code unrandomized and it has
		  been unclear whether an attacker can use these small code
		  fragments to construct payloads in the general case. In
		  this paper, we show defenses as currently deployed can be
		  bypassed with new techniques for automatically creating ROP
		  payloads from small amounts of unrandomized code. We
		  propose using semantic program verification techniques for
		  identifying the functionality of gadgets, and design a ROP
		  compiler that is resistant to missing gadget types. To
		  demonstrate our techniques, we build Q, an end-to-end
		  system that automatically generates ROP payloads for a
		  given binary. Q can produce payloads for 80{\%} of Linux
		  /usr/bin programs larger than 20KB. We also show that Q can
		  automatically perform exploit hardening: given an exploit
		  that crashes with defenses on, Q outputs an exploit that
		  bypasses both WX and ASLR. We show that Q can harden nine
		  real-world Linux and Windows exploits, enabling an attacker
		  to automatically bypass defenses as deployed by industry
		  for those programs.},
  author	= {Schwartz, Ej and Avgerinos, Thanassis and Brumley, David},
  doi		= {10.1016/j.coph.2007.12.010},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Schwartz, Avgerinos, Brumley - Q Exploit Hardening Made
		  Easy.pdf:pdf},
  isbn		= {1471-4892},
  issn		= {14714892},
  journal	= {Usenix Sec},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  number	= {3},
  pages		= {25},
  pmid		= {18243052},
  title		= {{Q: Exploit hardening made easy}},
  url		= {http://www.usenix.org/event/sec11/tech/full{\_}papers/Schwartz.pdf}
		  ,
  volume	= {8},
  year		= {2011}
}

@Article{	  schweppe2011,
  author	= {Schweppe, Hendrik and Roudier, Yves and Weyl, Benjamin},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Schweppe, Roudier, Weyl - Car2X communication securing the
		  last meter.pdf:pdf},
  isbn		= {978-1-4244-8328-0},
  journal	= {Vehicular Technology Conference},
  pages		= {1--5},
  title		= {{Car2X communication: securing the last meter}},
  url		= {http://scholar.google.com/scholar?hl=en{\&}btnG=Search{\&}q=intitle:Car2X+Communication+:+Securing+the+Last+Meter{\#}1}
		  ,
  year		= {2011}
}

@Article{	  schweppe2012,
  abstract	= {Mobile devices such as smartphones have gained more and
		  more attention from security researchers and malware
		  authors, the latter frequently attacking those platforms
		  and stealing personal information. Vehicle on-board
		  networks, in particular infotainment systems, are
		  increasingly connected with such mobile devices and the
		  internet and will soon make it possible to load and install
		  third party applications. This makes them susceptible to
		  new attacks similar to those which plague mobile phones and
		  personal computers. The breach of privacy is equally
		  sensitive in the vehicular domain. Even worse, broken
		  security is a serious threat to car safety. In this paper,
		  we show how traditional automotive communication systems
		  can be instrumented with taint tracking tools in a security
		  framework that allows to dynamically monitor data flows
		  within and between control units to achieve elevated
		  security and privacy.},
  author	= {Schweppe, Hendrik and Roudier, Yves},
  doi		= {10.1109/VCSC.2012.6281235},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Schweppe, Roudier - Security and privacy for in-vehicle
		  networks.pdf:pdf},
  isbn		= {9781467326827},
  journal	= {2012 IEEE 1st International Workshop on Vehicular
		  Communications, Sensing, and Computing, VCSC 2012},
  keywords	= {Binary Instrumentation,Data Flow Tracking,Distributed
		  Tainting,In-Vehicle Network Security,On-Board
		  Systems,Privacy},
  pages		= {12--17},
  title		= {{Security and privacy for in-vehicle networks}},
  year		= {2012}
}

@Article{	  sehr2010,
  abstract	= {Software Fault Isolation (SFI) is an effective approach to
		  sandboxing binary code of questionable provenance, an
		  interesting use case for native plugins in a Web browser.
		  We present software fault isolation schemes for ARM and
		  x86-64 that provide control-flow and memory integrity with
		  average performance overhead of under 5{\%} on ARM and
		  7{\%} on x86-64. We believe these are the best known SFI
		  implementations for these architectures, with significantly
		  lower overhead than previous systems for similar
		  architectures. Our experience suggests that these SFI
		  implementations benefit from instruction-level parallelism,
		  and have particularly small impact for workloads that are
		  data memory-bound, both properties that tend to reduce the
		  impact of our SFI systems for future CPU implementations.},
  author	= {Sehr, David and Muth, Robert and Biffle, Cliff and
		  Khimenko, Victor and Pasko, Egor and Schimpf, Karl and Yee,
		  Bennet and Chen, Bradley J.},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/Adapting
		  Software Fault Isolation to Contemporary CPU
		  Architectures.pdf:pdf},
  isbn		= {8887666655554},
  journal	= {19th Usenix Security Symposium},
  pages		= {1--12},
  title		= {{Adapting software fault isolation to contemporary CPU
		  architectures}},
  url		= {http://www.usenix.org/events/sec10/tech/full{\_}papers/Sehr.pdf}
		  ,
  year		= {2010}
}

@Article{	  sen2005,
  abstract	= {In unit testing, a program is decomposed into units which
		  are collections of functions. A part of unit can be tested
		  by generating inputs for a single entry function. The entry
		  function may contain pointer arguments, in which case the
		  inputs to the unit are memory graphs. The paper addresses
		  the problem of automating unit testing with memory graphs
		  as inputs. The approach used builds on previous work
		  combining symbolic and concrete execution, and more
		  specifically, using such a combination to generate test
		  inputs to explore all feasible execution paths. The current
		  work develops a method to represent and track constraints
		  that capture the behavior of a symbolic execution of a unit
		  with memory graphs as inputs. Moreover, an efficient
		  constraint solver is proposed to facilitate incremental
		  generation of such test inputs. Finally, CUTE, a tool
		  implementing the method is described together with the
		  results of applying CUTE to real-world examples of C
		  code.},
  author	= {Sen, Koushik and Marinov, Darko and Agha, Gul},
  doi		= {10.1145/1081706.1081750},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Sen, Marinov, Agha - CUTE A Concolic Unit Testing Engine
		  for C.pdf:pdf},
  isbn		= {1595930140},
  issn		= {01635948},
  journal	= {Program},
  keywords	= {concolic testing,data structure testing,explicit
		  path,model checking,random testing,testing,unit testing},
  pages		= {263--272},
  title		= {{CUTE : A Concolic Unit Testing Engine for C}},
  url		= {http://portal.acm.org/citation.cfm?id=1081750},
  volume	= {30},
  year		= {2005}
}

@InProceedings{	  sen2007concolic,
  title		= {Concolic testing},
  author	= {Sen, Koushik},
  booktitle	= {Proceedings of the twenty-second IEEE/ACM international
		  conference on Automated software engineering},
  pages		= {571--572},
  year		= {2007},
  organization	= {ACM}
}

@InProceedings{	  seshadri2006,
  abstract	= {We propose SecVisor, a tiny hypervisor that ensures code
		  integrity for commodity OS kernels. In particular, SecVisor
		  ensures that only user-approved code can execute in kernel
		  mode over the entire system lifetime. This protects the
		  kernel against code injection attacks, such as kernel
		  rootkits. SecVisor can achieve this propertyeven against an
		  attacker who controls everything but the CPU, the memory
		  controller, and system memory chips. Further, SecVisor can
		  even defend against attackers with knowledge of zero-day
		  kernel exploits. Our goal is to make SecVisor amenable to
		  formal verificationand manual audit, thereby making it
		  possible to rule out known classes of vulnerabilities. To
		  this end, SecVisor offers small code size and small
		  external interface. We rely on memory virtualization to
		  build SecVisor and implement two versions, one using
		  software memory virtualization and the other using
		  CPU-supported memory virtualization. The code sizes of the
		  runtime portions of these versions are 1739 and 1112 lines,
		  respectively. The size of the external interface for both
		  versions of SecVisor is 2 hypercalls. It is easy to port OS
		  kernels to SecVisor. We port the Linux kernel version
		  2.6.20 by adding 12 lines and deleting 81 lines, out of a
		  total of approximately 4.3 million lines of code in the
		  kernel.},
  author	= {Seshadri, Arvind and Luk, Mark and Qu, Ning and Perrig,
		  Adrian},
  booktitle	= {Proceedings of the ACM SIGOPS Symposium on Operating
		  Systems Principles},
  doi		= {10.1145/1323293.1294294},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Seshadri et al. - SecVisor A Tiny Hypervisor to Provide
		  Lifetime Kernel Code Integrity for Commodity OSes.pdf:pdf},
  isbn		= {9781595935915},
  issn		= {0163-5980},
  keywords	= {code attestation,code integrity,hypervisor,ing code
		  injection attacks,memory virtualization,prevent},
  pages		= {335--350},
  title		= {{SecVisor: A Tiny Hypervisor to Provide Lifetime Kernel
		  Code Integrity for Commodity OSes}},
  url		= {http://portal.acm.org/citation.cfm?id=1294294},
  volume	= {41},
  year		= {2006}
}

@Article{	  sharif2009,
  abstract	= {Kernel-level attacks or rootkits can compromise the
		  security of an operating system by executing with the
		  privilege of the kernel. Current approaches use
		  virtualization to gain higher privilege over these attacks,
		  and isolate security tools from the untrusted guest VM by
		  moving them out and placing them in a separate trusted VM.
		  Although out-of-VM isolation can help ensure security, the
		  added overhead of world-switches between the guest VMs for
		  each invocation of the monitor makes this approach
		  unsuitable for many applications, especially fine-grained
		  monitoring. In this paper, we present Secure In-VM
		  Monitoring (SIM), a general-purpose frame- work that
		  enables security monitoring applications to be placed back
		  in the untrusted guest VM for efficiency without
		  sacrificing the security guarantees provided by running
		  them outside of the VM. We utilize contemporary hardware
		  memory protection and hardware virtualization features
		  available in recent processors to create a hypervisor
		  protected address space where a monitor can execute and
		  access data in native speeds and to which execution is
		  transferred in a controlled manner that does not require
		  hyper- visor involvement. We have developed a prototype
		  into KVM uti- lizing Intel VT hardware virtualization
		  technology. We have also developed two representative
		  applications for theWindows OS that monitor system calls
		  and process creations. Our microbenchmarks show at least 10
		  times performance improvement in invocation of a monitor
		  inside SIM over a monitor residing in another trusted VM.
		  With a systematic security analysis of SIM against a number
		  of pos- sible threats, we show that SIM provides at least
		  the same security guarantees as what can be achieved by
		  out-of-VM monitors.},
  author	= {Sharif, Mi and Lee, Wenke and Cui, Weidong and Lanzi,
		  Andrea},
  doi		= {10.1145/1653662.1653720},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Sharif et al. - Secure in-vm monitoring using hardware
		  virtualization.pdf:pdf},
  isbn		= {9781605583525},
  issn		= {15437221},
  journal	= {{\ldots} of the 16th ACM conference on {\ldots}},
  keywords	= {all or part of,is granted without fee,kernel
		  integrity,malware,or hard copies of,permission to make
		  digital,personal or classroom use,provided that copies
		  are,secure monitoring,this work for,virtual machines},
  pages		= {11},
  title		= {{Secure in-vm monitoring using hardware virtualization}},
  url		= {http://dl.acm.org/citation.cfm?id=1653720},
  year		= {2009}
}

@Article{	  sheng2007,
  abstract	= {In this paper we describe the design and evaluation of
		  AntiPhishing Phil, an online game that teaches users good
		  habits to help them avoid phishing attacks. We used
		  learning science principles to design and iteratively
		  refine the game. We evaluated the game through a user
		  study: participants were tested on their ability to
		  identify fraudulent web sites before and after spending 15
		  minutes engaged in one of three anti-phishing training
		  activities (playing the game, reading an anti-phishing
		  tutorial we created based on the game, or reading existing
		  online training materials). We found that the participants
		  who played the game were better able to identify fraudulent
		  web sites compared to the participants in other conditions.
		  We attribute these effects to both the content of the
		  training messages presented in the game as well as the
		  presentation of these materials in an interactive game
		  format. Our results confirm that games can be an effective
		  way of educating people about phishing and other security
		  attacks.},
  author	= {Sheng, Steve and Magnien, Bryant and Kumaraguru,
		  Ponnurangam and Acquisti, Alessandro and Cranor, Lorrie
		  Faith and Hong, Jason and Nunge, Elizabeth},
  doi		= {http://doi.acm.org/10.1145/1280680.1280692},
  file		= {::},
  isbn		= {978-1-59593-801-5},
  issn		= {09501991},
  journal	= {SOUPS '07: Proceedings of the 3rd symposium on Usable
		  privacy and security},
  keywords	= {Phishing,development and testing,interactive
		  learning,learning science,security user education and game
		  design,usable privacy and security},
  pages		= {88--99},
  title		= {{Anti-Phishing Phil: the design and evaluation of a game
		  that teaches people not to fall for phish}},
  year		= {2007}
}

@Article{	  shinagawa2009,
  abstract	= {Virtual machine monitors (VMMs) are a popular platform for
		  implementing various security functionalities. To improve
		  the reliability of VMMs themselves, their code size should
		  be kept small. Unfortunately, existing VMMs require
		  numerous components, including device drivers and device
		  models to provide virtualized devices and resource managers
		  to share system resources across virtual machines (VMs) and
		  protect them. This paper introduces a VMM architecture
		  called parapass-through. The parapass-through architecture
		  is designed to minimize the code size of VMMs by allowing
		  most of the device access from the guest operating system
		  (OS) to pass-through the VMM, while the least amount of
		  access necessary to implement security functionalities is
		  intercepted and manipulated by the VMM. This architecture
		  utilizes the device drivers of the guest OS to handle real
		  devices, reducing the size of the device drivers and device
		  models required in the VMM. This architecture also limits
		  the number of VMs to one, eliminating the components for
		  sharing and protecting system resources among VMs. To apply
		  the parapass-through architecture to I/O devices using
		  Direct Memory Access (DMA), this paper introduces a novel
		  scheme using shadow DMA descriptors. Shadow DMA descriptors
		  allow the VMM to intercept and manipulate data transferred
		  via DMA, while most of the DMA access is handled by the
		  device driver of the guest OS. This paper presents a case
		  study that applies this scheme to Advanced Technology
		  Attachment (ATA) devices to enforce storage encryption. We
		  implemented a VMM, called the BitVisor, based on the
		  parapass-through architecture and measured the code sizes.
		  The experimental results revealed that the code size of the
		  hypervisor was approximately 20 kilo lines of code (KLOC)
		  and that of the ATA device driver was approximately 1.4
		  KLOC.},
  author	= {Shinagawa, Takahiro and Eiraku, Hideki and Tanimoto,
		  Kouichi and Omote, Kazumasa and Hasegawa, Shoichi and
		  Horie, Takashi and Hirano, Manabu and Kourai, Kenichi and
		  Oyama, Yoshihiro and Kawai, Eiji and Kono, Kenji and Chiba,
		  Shigeru and Shinjo, Yasushi and Kato, Kazuhiko},
  doi		= {10.1145/1508293.1508311},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Shinagawa et al. - BitVisor a thin hypervisor for enforcing
		  io device security.pdf:pdf},
  isbn		= {9781605583754},
  journal	= {VEE 09 Proceedings of the 2009 ACM SIGPLANSIGOPS
		  international conference on Virtual execution
		  environments},
  keywords	= {Virtual Machine Monitors (VMMs), Hypervisors, Trus},
  number	= {Vee},
  pages		= {121--130},
  title		= {{BitVisor: a thin hypervisor for enforcing i/o device
		  security}},
  url		= {http://portal.acm.org/ft{\_}gateway.cfm?id=1508311{\&}type=pdf{\&}coll=Portal{\&}dl=ACM{\&}CFID=46428054{\&}CFTOKEN=43833191}
		  ,
  year		= {2009}
}

@Article{	  shoshitaishvili2015,
  author	= {Shoshitaishvili, Yan and Wang, Ruoyu and Hauser,
		  Christophe and Kruegel, Christopher and Vigna, Giovanni},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  Shoshitaishvili et al. - Firmalice - Automatic Detection of
		  Authentication Bypass Vulnerabilities in Binary
		  Firmware.pdf:pdf},
  isbn		= {189156238X},
  journal	= {Proceedings of the Network and Distributed System Security
		  Symposium (NDSS)},
  number	= {February},
  pages		= {8--11},
  title		= {{Firmalice - Automatic Detection of Authentication Bypass
		  Vulnerabilities in Binary Firmware}},
  year		= {2015}
}

@Article{	  singaravelu2006,
  abstract	= {The large size and high complexity of security-sensitive
		  applications and systems software is a primary cause for
		  their poor testability and high vulnerability. One approach
		  to alleviate this problem is to extract the
		  security-sensitive parts of application and systems
		  software, thereby reducing the size and complexity of
		  software that needs to be trusted. At the system software
		  level, we use the Nizza architecture which relies on a
		  kernelized trusted computing base (TCB) and on the reuse of
		  legacy code using trusted wrappers to minimize the size of
		  the TCB. At the application level, we extract the
		  security-sensitive portions of an already existing
		  application into an AppCore. The AppCore is executed as a
		  trusted process in the Nizza architecture while the rest of
		  the application executes on a virtualized, untrusted legacy
		  operating system. In three case studies of real-world
		  applications (e-commerce transaction client, VPN gateway
		  and digital signatures in an e-mail client), we achieved a
		  considerable reduction in code size and complexity. In
		  contrast to the few hundred thousand lines of current
		  application software code running on millions of lines of
		  systems software code, we have AppCores with tens of
		  thousands of lines of code running on a hundred thousand
		  lines of systems software code. We also show the
		  performance penalty of AppCores to be modest (a few
		  percent) compared to current software.},
  author	= {Singaravelu, Lenin and Pu, Calton and H{\"{a}}rtig,
		  Hermann and Helmuth, Christian},
  doi		= {10.1145/1218063.1217951},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Singaravelu et al. - Reducing TCB complexity for
		  security-sensitive applications.pdf:pdf},
  isbn		= {1-59593-322-0},
  issn		= {01635980},
  journal	= {ACM SIGOPS Operating Systems Review},
  keywords	= {application security,trusted computing base},
  number	= {4},
  pages		= {161},
  title		= {{Reducing TCB complexity for security-sensitive
		  applications}},
  volume	= {40},
  year		= {2006}
}

@Article{	  skorobogatov2012,
  abstract	= {This paper is a short summary of the first real world de-
		  tection of a backdoor in a military grade FPGA. Using an
		  innovative patented technique we were able to detect and
		  analyse in the first doc- umented case of its kind, a
		  backdoor inserted into the Actel/Microsemi ProASIC3 chips
		  for accessing FPGA configuration. The backdoor was found
		  amongst additional JTAG functionality and exists on the
		  silicon itself, it was not present in any firmware loaded
		  onto the chip. Using Pipeline Emission Analysis (PEA), our
		  pioneered technique, we were able to extract the secret key
		  to activate the backdoor, as well as other security keys
		  such as the AES and the Passkey. This way an attacker can
		  extract all the configuration data from the chip, reprogram
		  crypto and access keys, modify low-level silicon features,
		  access unencrypted configuration bitstream or permanently
		  damage the device. Clearly this means the device is wide
		  open to intellectual property (IP) theft, fraud,
		  re-programming as well as reverse engineering of the design
		  which allows the introduction of a new backdoor or Trojan.
		  Most concerning, it is not possible to patch the backdoor
		  in chips already deployed, meaning those using this family
		  of chips have to accept the fact they can be easily
		  compromised or will have to be physically replaced after a
		  redesign of the silicon itself.},
  author	= {Skorobogatov, Sergei and Woods, Christopher},
  doi		= {10.1007/978-3-642-33027-8{\_}2},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Skorobogatov, Woods - Breakthrough silicon scanning
		  discovers backdoor in military chip.pdf:pdf},
  isbn		= {9783642330261},
  issn		= {03029743},
  journal	= {Cryptographic Hardware and Embedded Systems Workshop
		  (CHES)},
  keywords	= {Hardware Assurance,PEA,side-channel analysis,silicon
		  Trojans and backdoors,silicon scanning},
  number	= {September},
  pages		= {23--40},
  title		= {{Breakthrough silicon scanning discovers backdoor in
		  military chip}},
  volume	= {7428 LNCS},
  year		= {2012}
}

@Article{	  skowyra2013,
  author	= {Skowyra, R. and Casteel, K. and Okhravi, H. and Zeldovich,
		  N. and Streilein, W.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Skowyra et al. - Systematic Analysis of Defenses Against
		  Return-Oriented Programming.pdf:pdf},
  isbn		= {9783642412844},
  journal	= {Research in Attacks, Intrusions, and Defenses},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {82--102},
  title		= {{Systematic Analysis of Defenses Against Return-Oriented
		  Programming}},
  year		= {2013}
}

@Article{	  snow2013,
  abstract	= {Fine-grained address space layout randomization (ASLR) has
		  recently been proposed as a method of efficiently
		  mitigating runtime attacks. In this paper, we introduce the
		  design and implementation of a framework based on a novel
		  attack strategy, dubbed just-in-time code reuse, that
		  undermines the benefits of fine-grained ASLR. Specifically,
		  we derail the assumptions embodied in fine-grained ASLR by
		  exploiting the ability to repeatedly abuse a memory
		  disclosure to map an application's memory layout
		  on-the-fly, dynamically discover API functions and gadgets,
		  and JIT-compile a target program using those gadgets -- all
		  within a script environment at the time an exploit is
		  launched. We demonstrate the power of our framework by
		  using it in conjunction with a real-world exploit against
		  Internet Explorer, and also provide extensive evaluations
		  that demonstrate the practicality of just-in-time code
		  reuse attacks. Our findings suggest that fine-grained ASLR
		  may not be as promising as first thought.},
  author	= {Snow, K. Z. and Monrose, F. and Davi, L. and Dmitrienko,
		  A. and Liebchen, C. and Sadeghi, A.},
  doi		= {10.1109/SP.2013.45},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Snow et al. - Just-In-Time Code Reuse On the Effectiveness
		  of Fine-Grained Address Space Layout
		  Randomization.pdf:pdf},
  isbn		= {978-0-7695-4977-4},
  issn		= {1081-6011},
  journal	= {2013 IEEE Symposium on Security and Privacy},
  keywords	= {API functions,API gadgets,ASLR,Internet
		  Explorer,JIT-compile,Layout,Libraries,Payloads,Programming,Registers,Runtime,Security,application
		  program interfaces,attack strategy,fine-grained address
		  space layout randomization,just-in-time code reuse
		  attacks,memory disclosure,program compilers,runtime
		  attacks,script environment,search engines,security of
		  data},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {574--588},
  title		= {{Just-In-Time Code Reuse: On the Effectiveness of
		  Fine-Grained Address Space Layout Randomization}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6547134}
		  ,
  year		= {2013}
}

@Article{	  son2011,
  abstract	= {Web applications written in languages such as PHP and JSP
		  are notoriously vulnerable to accidentally omitted
		  authorization checks and other security bugs. Existing
		  techniques that find missing security checks in library and
		  system code assume that (1) security checks can be
		  recognized syntactically and (2) the same pattern of checks
		  applies universally to all programs. These assumptions do
		  not hold for Web applications. Each Web application uses
		  different variables and logic to check the user's
		  permissions. Even within the application, security logic
		  varies based on the user's role, e.g., regular users versus
		  administrators. This paper describes ROLECAST, the first
		  system capable of statically identifying security logic
		  that mediates security-sensitive events (such as database
		  writes) in Web applications, rather than taking a
		  specification of this logic as input. We observe a
		  consistent software engineering pattern-the code that
		  implements distinct user role functionality and its
		  security logic resides in distinct methods and files-and
		  develop a novel algorithm for discovering this pattern in
		  Web applications. Our algorithm partitions the set of file
		  contexts (a coarsening of calling contexts) on which
		  security-sensitive events are control dependent into roles.
		  Roles are based on common functionality and security logic.
		  ROLECAST identifies security-critical variables and applies
		  role-specific variable consistency analysis to find missing
		  security checks. ROLECAST discovered 13 previously
		  unreported, remotely exploitable vulnerabilities in 11
		  substantial PHP and JSP applications, with only 3 false
		  positives. This paper demonstrates that (1) accurate
		  inference of application- and role-specific security logic
		  improves the security of Web applications without
		  specifications, and (2) static analysis can discover
		  security logic automatically by exploiting distinctive
		  software engineering features.},
  author	= {Son, Sooel and McKinley, Kathryn S and Shmatikov, Vitaly},
  doi		= {10.1145/2048066.2048146},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Son, McKinley, Shmatikov - RoleCast finding missing
		  security checks when you do not know what checks
		  are.pdf:pdf},
  isbn		= {978-1-4503-0940-0},
  issn		= {0362-1340},
  journal	= {Oopsla},
  keywords	= {dblp},
  pages		= {1069--1084},
  title		= {{RoleCast: finding missing security checks when you do not
		  know what checks are.}},
  url		= {http://dblp.uni-trier.de/db/conf/oopsla/oopsla2011.html{\#}SonMS11}
		  ,
  year		= {2011}
}

@Article{	  son2011,
  abstract	= {Web applications written in languages such as PHP and JSP
		  are notoriously vulnerable to accidentally omitted
		  authorization checks and other security bugs. Existing
		  techniques that find missing security checks in library and
		  system code assume that (1) security checks can be
		  recognized syntactically and (2) the same pattern of checks
		  applies universally to all programs. These assumptions do
		  not hold for Web applications. Each Web application uses
		  different variables and logic to check the user's
		  permissions. Even within the application, security logic
		  varies based on the user's role, e.g., regular users versus
		  administrators. This paper describes ROLECAST, the first
		  system capable of statically identifying security logic
		  that mediates security-sensitive events (such as database
		  writes) in Web applications, rather than taking a
		  specification of this logic as input. We observe a
		  consistent software engineering pattern-the code that
		  implements distinct user role functionality and its
		  security logic resides in distinct methods and files-and
		  develop a novel algorithm for discovering this pattern in
		  Web applications. Our algorithm partitions the set of file
		  contexts (a coarsening of calling contexts) on which
		  security-sensitive events are control dependent into roles.
		  Roles are based on common functionality and security logic.
		  ROLECAST identifies security-critical variables and applies
		  role-specific variable consistency analysis to find missing
		  security checks. ROLECAST discovered 13 previously
		  unreported, remotely exploitable vulnerabilities in 11
		  substantial PHP and JSP applications, with only 3 false
		  positives. This paper demonstrates that (1) accurate
		  inference of application- and role-specific security logic
		  improves the security of Web applications without
		  specifications, and (2) static analysis can discover
		  security logic automatically by exploiting distinctive
		  software engineering features.},
  author	= {Son, Sooel and McKinley, Kathryn S and Shmatikov, Vitaly},
  doi		= {10.1145/2048066.2048146},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Son, McKinley, Shmatikov - RoleCast finding missing
		  security checks when you do not know what checks
		  are.pdf:pdf},
  isbn		= {978-1-4503-0940-0},
  issn		= {0362-1340},
  journal	= {Oopsla},
  keywords	= {dblp},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {1069--1084},
  title		= {{RoleCast: finding missing security checks when you do not
		  know what checks are.}},
  url		= {http://dblp.uni-trier.de/db/conf/oopsla/oopsla2011.html{\#}SonMS11}
		  ,
  year		= {2011}
}

@Article{	  son2013,
  abstract	= {Access-control policies in Web applications ensure that
		  only authorized users can perform security-sensitive oper-
		  ations. These policies usually check user credentials be-
		  fore executing actions such as writing to the database or
		  navigating to privileged pages. Typically, every Web ap-
		  plication uses its own, hand-crafted program logic to en-
		  force access control. Within a single application, this
		  logic can vary between different user roles, e.g.,
		  administrator or regular user. Unfortunately, developers
		  forget to include proper access-control checks, a lot. This
		  paper presents the design and implementation of FIXMEUP, a
		  static analysis and transformation tool that finds
		  access-control errors of omission and produces can- didate
		  repairs. FIXMEUP starts with a high-level specifi- cation
		  that indicates the conditional statement of a correct
		  access-control check and automatically computes an inter-
		  procedural access-control template (ACT), which includes
		  all program statements involved in this instance of access-
		  control logic. The ACT serves as both a low-level policy
		  specification and a program transformation template. FIX-
		  MEUP uses the ACT to find faulty access-control logic that
		  misses some or all of these statements, inserts only the
		  miss- ing statements, and ensures that unintended
		  dependences did not change the meaning of the
		  access-control policy. FIXMEUP then presents the
		  transformed program to the de- veloper, who decides whether
		  to accept the proposed repair. Our evaluation on ten
		  real-world PHP applications shows that FIXMEUP is capable
		  of finding subtle access- control bugs and performing
		  semantically correct repairs.},
  author	= {Son, Sooel and Mckinley, Kathryn S},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Son, Mckinley - Fix Me Up Repairing Access-Control Bugs in
		  Web Applications.pdf:pdf},
  journal	= {Proceedings of the 2013 Network and Distributed System
		  Security Symposium (NDSS 2013)},
  title		= {{Fix Me Up : Repairing Access-Control Bugs in Web
		  Applications}},
  year		= {2013}
}

@Article{	  son2013,
  abstract	= {Access-control policies in Web applications ensure that
		  only authorized users can perform security-sensitive oper-
		  ations. These policies usually check user credentials be-
		  fore executing actions such as writing to the database or
		  navigating to privileged pages. Typically, every Web ap-
		  plication uses its own, hand-crafted program logic to en-
		  force access control. Within a single application, this
		  logic can vary between different user roles, e.g.,
		  administrator or regular user. Unfortunately, developers
		  forget to include proper access-control checks, a lot. This
		  paper presents the design and implementation of FIXMEUP, a
		  static analysis and transformation tool that finds
		  access-control errors of omission and produces can- didate
		  repairs. FIXMEUP starts with a high-level specifi- cation
		  that indicates the conditional statement of a correct
		  access-control check and automatically computes an inter-
		  procedural access-control template (ACT), which includes
		  all program statements involved in this instance of access-
		  control logic. The ACT serves as both a low-level policy
		  specification and a program transformation template. FIX-
		  MEUP uses the ACT to find faulty access-control logic that
		  misses some or all of these statements, inserts only the
		  miss- ing statements, and ensures that unintended
		  dependences did not change the meaning of the
		  access-control policy. FIXMEUP then presents the
		  transformed program to the de- veloper, who decides whether
		  to accept the proposed repair. Our evaluation on ten
		  real-world PHP applications shows that FIXMEUP is capable
		  of finding subtle access- control bugs and performing
		  semantically correct repairs.},
  author	= {Son, Sooel and Mckinley, Kathryn S},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Son, Mckinley - Fix Me Up Repairing Access-Control Bugs in
		  Web Applications.pdf:pdf},
  journal	= {Proceedings of the 2013 Network and Distributed System
		  Security Symposium (NDSS 2013)},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  title		= {{Fix Me Up : Repairing Access-Control Bugs in Web
		  Applications}},
  year		= {2013}
}

@Article{	  song2008,
  abstract	= {In this paper, we give an overview of the BitBlaze
		  project, a new approach to computer security via binary
		  analysis. In particular, BitBlaze focuses on building a
		  unified binary analysis platform and using it to provide
		  novel solutions to a broad spectrum of different security
		  problems. The binary analysis platform is designed to
		  enable accurate analysis, provide an extensible
		  architecture, and combines static and dynamic analysis as
		  well as program verification techniques to satisfy the
		  common needs of security applications. By extracting
		  security-related properties from binary programs directly,
		  BitBlaze enables a principled, root-cause based approach to
		  computer security, offering novel and effective solutions,
		  as demonstrated with over a dozen different security
		  applications.},
  author	= {Song, Dawn and Brumley, David and Yin, Heng and Caballero,
		  Juan and Jager, Ivan and Kang, Min Gyung and Liang, Zhenkai
		  and Newsome, James and Poosankam, Pongsin and Saxena,
		  Prateek},
  doi		= {10.1007/978-3-540-89862-7{\_}1},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Song et al. - BitBlaze A new approach to computer security
		  via binary analysis.pdf:pdf},
  isbn		= {3540898611},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  keywords	= {Binary analysis,Malware analysis and defense,Reverse
		  engineering,Vulnerability analysis and defense},
  pages		= {1--25},
  title		= {{BitBlaze: A new approach to computer security via binary
		  analysis}},
  volume	= {5352 LNCS},
  year		= {2008}
}

@Article{	  srinivasan2011,
  abstract	= {Process Out-Grafting},
  author	= {Srinivasan, Deepa and Wang, Zhi and Jiang, Xuxian and Xu,
		  Dongyan},
  doi		= {10.1145/2046707.2046751},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Srinivasan et al. - Process Out-Grafting An Efficient “
		  Out-of-VM ” Approach for Fine-Grained Process Execution
		  Monitoring C.pdf:pdf},
  isbn		= {9781450309486},
  issn		= {15437221},
  journal	= {CCS},
  keywords	= {all or part of,is granted without fee,or hard copies
		  of,permission to make digital,personal or classroom
		  use,process monitoring,provided that copies are,semantic
		  gap,this work for,virtualization},
  mendeley-groups={4 - Hypervisor},
  pages		= {363--374},
  title		= {{Process Out-Grafting : An Efficient “ Out-of-VM ”
		  Approach for Fine-Grained Process Execution Monitoring
		  Categories and Subject Descriptors}},
  year		= {2011}
}

@InProceedings{	  stewin2013,
  author	= {Stewin, Patrick and Bystrov, Iurii},
  booktitle	= {Proceedings of the Conference on Detection of Intrusions
		  and Malware and Vulnerability Assessment (DIMVA)},
  doi		= {10.1007/978-3-642-37300-8-2},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Stewin, Bystrov - Understanding DMA malware.pdf:pdf},
  isbn		= {9783642372995},
  issn		= {03029743},
  keywords	= {Dedicated Hardware,Direct Memory
		  Access,I/OMMU,Keylogger,Malware,Manageability
		  Engine,Rootkit,Stealth,vPro,x86},
  pages		= {21--41},
  title		= {{Understanding DMA malware}},
  volume	= {7591 LNCS},
  year		= {2013}
}

@Article{	  stewin2013a,
  author	= {Stewin, Patrick},
  doi		= {10.1007/978-3-642-41284-4{\_}1},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Stewin - A primitive for revealing stealthy
		  peripheral-based attacks on the computing platform's main
		  memory.pdf:pdf},
  isbn		= {9783642412837},
  issn		= {03029743},
  journal	= {Proceedings of the Symposium on Recent Advances in
		  Intrusion Detection (RAID)},
  keywords	= {DMA Malware,Direct Memory Access (DMA),Intrusion
		  Detection,Operating System Security},
  pages		= {1--20},
  title		= {{A primitive for revealing stealthy peripheral-based
		  attacks on the computing platform's main memory}},
  volume	= {8145 LNCS},
  year		= {2013}
}

@TechReport{	  stewin2014,
  author	= {Stewin, Patrick},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Stewin - Enhanced BARM — Authentic Reporting to External
		  Platforms.pdf:pdf},
  number	= {September},
  title		= {{Enhanced BARM — Authentic Reporting to External
		  Platforms}},
  year		= {2014}
}

@Article{	  studnia2013,
  abstract	= {Embedded electronic components, socalled ECU (Electronic
		  Controls Units), are nowadays a prominent part of a car's
		  architecture. These ECUs, monitoring and controlling the
		  different subsystems of a car, are interconnected through
		  several gateways and compose the global internal network of
		  the car. Moreover, modern cars are now able to communicate
		  with other devices through wired or wireless interfaces
		  such as USB, Bluetooth, WiFi or even 3G. Such interfaces
		  may expose the internal network to the outside world and
		  can be seen as entry points for cyber attacks. In this
		  paper, we present a survey on security threats and
		  protection mechanisms in embedded automotive networks.
		  After introducing the different protocols being used in the
		  embedded networks of current vehicles, we then analyze the
		  potential threats targeting these networks and describe how
		  the attackers' opportunities can be enhanced by the new
		  communication abilities of modern cars. Finally, we present
		  the security solutions currently being devised to address
		  these problems.},
  author	= {Studnia, Ivan and Nicomette, Vincent and Alata, Eric and
		  Deswarte, Yves and Kaaniche, Mohamed and Laarouchi,
		  Youssef},
  doi		= {10.1109/DSNW.2013.6615528},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Studnia et al. - Survey on security threats and protection
		  mechanisms in embedded automotive networks.pdf:pdf},
  isbn		= {9781479901814},
  issn		= {2325-6648},
  journal	= {Proceedings of the International Conference on Dependable
		  Systems and Networks},
  title		= {{Survey on security threats and protection mechanisms in
		  embedded automotive networks}},
  year		= {2013}
}

@Article{	  sturton2011,
  abstract	= {In previous work Hicks et al. proposed a method called
		  Unused Circuit Identification (UCI) for detecting malicious
		  backdoors hidden in circuits at design time. The UCI
		  algorithm essentially looks for portions of the circuit
		  that go unused during design-time testing and flags them as
		  potentially malicious. In this paper we construct circuits
		  that have malicious behavior, but that would evade
		  detection by the UCI algorithm and still pass design-time
		  test cases. To enable our search for such circuits, we
		  define one class of malicious circuits and perform a
		  bounded exhaustive enumeration of all circuits in that
		  class. Our approach is simple and straight forward, yet it
		  proves to be effective at finding circuits that can thwart
		  UCI. We use the results of our search to construct a
		  practical attack on an open-source processor. Our malicious
		  backdoor allows any user-level program running on the
		  processor to enter supervisor mode through the use of a
		  secret {\&}{\#}x0E2; knock. We close with a discussion on
		  what we see as a major challenge facing any future
		  design-time malicious hardware detection scheme:
		  identifying a sufficient class of malicious circuits to
		  defend against.},
  author	= {Sturton, Cynthia and Hicks, Matthew and Wagner, David and
		  King, Samuel T.},
  doi		= {10.1109/SP.2011.32},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Sturton et al. - Defeating UCI Building stealthy and
		  malicious hardware.pdf:pdf},
  isbn		= {9780769544021},
  issn		= {10816011},
  journal	= {Proceedings of the IEEE Symposium on Security and
		  Privacy},
  keywords	= {Attack,Hardware,Security},
  pages		= {64--77},
  title		= {{Defeating UCI: Building stealthy and malicious
		  hardware}},
  year		= {2011}
}

@Article{	  stuttgen2015,
  author	= {St{\"{u}}ttgen, Johannes and V{\"{o}}mel, Stefan and
		  Denzel, Michael},
  doi		= {10.1016/j.diin.2015.01.010},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2015 -
		  St{\"{u}}ttgen, V{\"{o}}mel, Denzel - Acquisition and
		  analysis of compromised firmware using memory
		  forensics.pdf:pdf},
  issn		= {17422876},
  journal	= {Digital Investigation},
  pages		= {S50--S60},
  title		= {{Acquisition and analysis of compromised firmware using
		  memory forensics}},
  url		= {http://linkinghub.elsevier.com/retrieve/pii/S1742287615000110}
		  ,
  volume	= {12},
  year		= {2015}
}

@InProceedings{	  sun11:static-access-control,
  address	= {Berkeley, CA, USA},
  author	= {Sun, Fangqi and Xu, Liang and Su, Zhendong},
  booktitle	= {Proceedings of the 20th USENIX conference on Security
		  (USENIX 2011)},
  pages		= {11},
  publisher	= {USENIX Association},
  series	= {SEC'11},
  title		= {{Static detection of access control vulnerabilities in web
		  applications}},
  year		= {2011}
}

@InProceedings{	  sun11:static-access-control,
  address	= {Berkeley, CA, USA},
  author	= {Sun, Fangqi and Xu, Liang and Su, Zhendong},
  booktitle	= {Proceedings of the 20th USENIX conference on Security
		  (USENIX 2011)},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {11},
  publisher	= {USENIX Association},
  series	= {SEC'11},
  title		= {{Static detection of access control vulnerabilities in web
		  applications}},
  year		= {2011}
}

@InProceedings{	  sun2011,
  annote	= {THIS PAPER HAS EXAMPLE OF EARS.
		  
		  Really good paper that discusses how to statically detect
		  access control vulnerabilities.
		  
		  Requires developers to specificy user roles and starting
		  points.
		  
		  They then statically create a context-free grammer of each
		  page. They use this CFG to extract links.
		  
		  In this way, they statically build up the set of pages that
		  a user{\&}{\#}039;s role can explicitally access. Then they
		  explicitly try to access higher roles pages from a lower
		  role. If they can, then they detect a vulnerability.},
  author	= {Sun, Fangqi and Xu, Liang and Su, Zhendong},
  booktitle	= {Proceedings of the 20th USENIX conference on Security
		  (USENIX 2011)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Sun, Xu, Su - Static Detection of Access Control
		  Vulnerabilities in Web Applications.pdf:pdf},
  title		= {{Static Detection of Access Control Vulnerabilities in Web
		  Applications}},
  year		= {2011}
}

@Article{	  sun2014,
  abstract	= {Native code is external, difficult to analyze, mostly
		  computation. They isolate it by putting it in a different
		  app with zero permissions. They do not require OS mods or
		  source code, but they recompile the app in two separate
		  apps (Java and native). They need to proxy all the JNI
		  stuff. Good performance MiBench (17{\%} - 0.5{\%}). 28/30
		  real-wold apps work. App to 183{\%} with high context
		  switches.},
  author	= {Sun, Mengtao and Tan, Gang},
  doi		= {10.1145/2627393.2627396},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/p165-sun.pdf:pdf}
		  ,
  isbn		= {9781450329729},
  journal	= {Proceedings of the 2014 ACM Conference on Security and
		  Privacy in Wireless {\&} Mobile Networks (WiSec)},
  keywords	= {android,java native interface,privilege isolation},
  pages		= {165--176},
  title		= {{NativeGuard: Protecting Android Applications from
		  Third-Party Native Libraries}},
  year		= {2014}
}

@Article{	  szefer2011,
  abstract	= {Cloud computing is quickly becoming the platform of choice
		  for many web services. Virtualization is the key underlying
		  technology enabling cloud providers to host services for a
		  large number of customers. Unfortunately, virtualization
		  software is large, complex, and has a considerable attack
		  surface. As such, it is prone to bugs and vulnerabilities
		  that a malicious virtual machine (VM) can exploit to attack
		  or obstruct other VMs -- a major concern for organizations
		  wishing to move to the cloud. In contrast to previous work
		  on hardening or minimizing the virtualization software, we
		  eliminate the hypervisor attack surface by enabling the
		  guest VMs to run natively on the underlying hardware while
		  maintaining the ability to run multiple VMs concurrently.
		  Our NoHype system embodies four key ideas: (i)
		  pre-allocation of processor cores and memory resources,
		  (ii) use of virtualized I/O devices, (iii) minor
		  modifications to the guest OS to perform all system
		  discovery during bootup, and (iv) avoiding indirection by
		  bringing the guest virtual machine in more direct contact
		  with the underlying hardware. Hence, no hypervisor is
		  needed to allocate resources dynamically, emulate I/O
		  devices, support system discovery after bootup, or map
		  interrupts and other identifiers. NoHype capitalizes on the
		  unique use model in cloud computing, where customers
		  specify resource requirements ahead of time and providers
		  offer a suite of guest OS kernels. Our system supports
		  multiple tenants and capabilities commonly found in hosted
		  cloud infrastructures. Our prototype utilizes Xen 4.0 to
		  prepare the environment for guest VMs, and a slightly
		  modified version of Linux 2.6 for the guest OS. Our
		  evaluation with both SPEC and Apache benchmarks shows a
		  roughly 1{\%} performance gain when running applications on
		  NoHype compared to running them on top of Xen 4.0. Our
		  security analysis shows that, while there are some minor
		  limitations with cur- rent commodity hardware, NoHype is a
		  significant advance in the security of cloud computing.},
  author	= {Szefer, Jakub and Keller, Eric and Lee, Ruby B and
		  Rexford, Jennifer},
  doi		= {10.1145/2046707.2046754},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Szefer et al. - Eliminating the Hypervisor Attack Surface
		  for a More Secure Cloud.pdf:pdf},
  isbn		= {9781450309486},
  issn		= {15437221},
  journal	= {Proceedings of the 18th ACM conference on Computer and
		  Communications Security (CCS'11)},
  keywords	= {attack vec-,hardware security,hypervisor
		  security,multicore,secure cloud
		  computing,tors,virtualization},
  mendeley-groups={4 - Hypervisor},
  pages		= {401--412},
  title		= {{Eliminating the Hypervisor Attack Surface for a More
		  Secure Cloud Categories and Subject Descriptors}},
  year		= {2011}
}

@Article{	  szefer2011a,
  abstract	= {Cloud computing, enabled by virtualization technologies,
		  is becoming a mainstream computing model. Many companies
		  are starting to utilize the infrastructure-as-a-service
		  (IaaS) cloud computing model, leasing guest virtual
		  machines (VMs) from the infrastructure providers for
		  economic reasons: to reduce their operating costs and to
		  increase the flexibility of their own infrastructures. Yet,
		  many companies may be hesitant to move to cloud computing
		  due to security concerns. An integral part of any
		  virtualization technology is the all-powerful hyper visor.
		  A hyper visor is a system management software layer which
		  can access all resources of the platform. Much research has
		  been done on using hyper visors to monitor guest VMs for
		  malicious code and on hardening hyper visors to make them
		  more secure. There is, however, another threat which has
		  not been addressed by researchers - that of compromised or
		  malicious hyper visors that can extract sensitive or
		  confidential data from guest VMs. Consequently, we propose
		  that a new research direction needs to be undertaken to
		  tackle this threat. We further propose that new hardware
		  mechanisms in the multi core microprocessors are a viable
		  way of providing protections for the guest VMs from the
		  hyper visor, while still allowing the hyper visor to
		  flexibly manage the resources of the physical platform.
		  {\&}copy; 2011 IEEE.},
  author	= {Szefer, Jakub and Lee, RB},
  doi		= {10.1109/ICDCSW.2011.51},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Szefer, Lee - A Case for Hardware Protection of Guest VMs
		  from Compromised Hypervisors in Cloud Computing.pdf:pdf},
  isbn		= {978-1-4577-0384-3},
  journal	= {{\ldots} Computing Systems Workshops (ICDCSW), {\ldots}},
  mendeley-groups={4 - Hypervisor},
  number	= {June},
  pages		= {248--252},
  title		= {{A case for hardware protection of guest vms from
		  compromised hypervisors in cloud computing}},
  url		= {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=5961523}
		  ,
  year		= {2011}
}

@Article{	  szefer2012,
  abstract	= {Virtualization has become a standard part of many computer
		  systems. A key part of virtualization is the all-powerful
		  hypervisor which manages the physical platform and can
		  access all of its resources, including memory assigned to
		  the guest virtual machines (VMs). Continuing releases of
		  bug reports and exploits in the virtualization software
		  show that defending the hypervisor against attacks is very
		  difficult. In this work, we present hypervisor-secure
		  virtualization - a new research direction with the goal of
		  protecting the guest VMs from an untrusted hypervisor. We
		  also present the HyperWall architecture which achieves
		  hypervisor-secure virtualization, using hardware to provide
		  the protections. HyperWall allows a hypervisor to freely
		  manage the memory, processor cores and other resources of a
		  platform. Yet once VMs are created, our new Confidentiality
		  and Integrity Protection (CIP) tables protect the memory of
		  the guest VMs from accesses by the hypervisor or by DMA,
		  depending on the customer's specification. If a hypervisor
		  does become compromised, e.g. by an attack from a malicious
		  VM, it cannot be used in turn to attack other VMs. The
		  protections are enabled through minimal modifications to
		  the microprocessor and memory management units. Whereas
		  much of the previous work concentrates on protecting the
		  hypervisor from attacks by guest VMs, we tackle the problem
		  of protecting the guest VMs from the hypervisor. © 2012
		  ACM.},
  author	= {Szefer, Jakub and Lee, Ruby B.},
  doi		= {10.1145/2189750.2151022},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Szefer, Lee - Architectural support for hypervisor-secure
		  virtualization.pdf:pdf},
  isbn		= {9781450307598},
  issn		= {01635964},
  journal	= {ACM SIGARCH Computer Architecture News},
  keywords	= {at-,cloud computing,computer
		  architecture,confidentiality,hardware
		  security,hypervisor,integrity,security,testation,trust
		  evidence,virtualization},
  mendeley-groups={4 - Hypervisor},
  pages		= {437},
  title		= {{Architectural support for hypervisor-secure
		  virtualization}},
  volume	= {40},
  year		= {2012}
}

@Article{	  szekeres2013,
  abstract	= {Memory corruption bugs in software written in low-level
		  languages like C or C++ are one of the oldest problems in
		  computer security. The lack of safety in these languages
		  allows attackers to alter the program’s behavior or take
		  full control over it by hijacking its control flow. This
		  problem has existed for more than 30 years and a vast
		  number of potential solutions have been proposed, yet
		  memory corruption attacks continue to pose a serious
		  threat. Real world exploits show that all currently
		  deployed protections can be defeated. This paper sheds
		  light on the primary reasons for this by describing attacks
		  that succeed on today’s systems. We systematize the
		  current knowledge about various protection techniques by
		  setting up a general model for memory corrup- tion attacks.
		  Using this model we show what policies can stop which
		  attacks. The model identifies weaknesses of currently
		  deployed techniques, as well as other proposed protections
		  enforcing stricter policies. We analyze the reasons why
		  protection mechanisms imple- menting stricter polices are
		  not deployed. To achieve wide adoption, protection
		  mechanisms must support a multitude of features and must
		  satisfy a host of requirements. Especially important is
		  performance, as experience shows that only solutions whose
		  overhead is in reasonable bounds get deployed. A comparison
		  of different enforceable policies helps de- signers of new
		  protection mechanisms in finding the balance between
		  effectiveness (security) and efficiency.We identify some
		  open research problems, and provide suggestions on
		  improving the adoption of newer techniques.},
  author	= {Szekeres, L{\'{a}}szl{\'{o}} and Payer, Mathias and Wei,
		  Tao and Song, Dawn},
  doi		= {10.1109/SP.2013.13},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Payer, Wei, Song - SoK Eternal War in Memory.pdf:pdf},
  isbn		= {9780769549774},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {48--62},
  title		= {{SoK: Eternal war in memory}},
  year		= {2013}
}

@Article{	  szilagyi2010,
  author	= {Szilagyi, Chris and Koopman, Philip},
  doi		= {10.1145/1873548.1873558},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Szilagyi, Koopman - Low cost multicast authentication via
		  validity voting in time-triggered embedded control
		  networks.pdf:pdf},
  isbn		= {9781450300780},
  journal	= {Proceedings of the 5th Workshop on Embedded Systems
		  Security - WESS '10},
  pages		= {1--10},
  title		= {{Low cost multicast authentication via validity voting in
		  time-triggered embedded control networks}},
  url		= {http://portal.acm.org/citation.cfm?doid=1873548.1873558},
  year		= {2010}
}

@Article{	  ta-min2006,
  abstract	= {Proxos},
  author	= {Ta-min, Richard and Litty, Lionel},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Ta-min, Litty - Splitting Interfaces Making Trust Between
		  Applications and Operating Systems Configurable.pdf:pdf},
  isbn		= {1-931971-47-1},
  journal	= {Osdi},
  number	= {Vm},
  pages		= {279--292},
  title		= {{Splitting Interfaces: Making Trust Between Applications
		  and Operating Systems Configurable}},
  year		= {2006}
}

@InProceedings{	  tan08:autoises,
  author	= {Tan, L and Zhang, X and Ma, X and Xiong, W and Zhou, Y},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 - Tan
		  et al. - AutoISES Automatically Inferring Security
		  Specifications and Detecting Violations.pdf:pdf},
  month		= {jul},
  pages		= {379--394},
  title		= {{AutoISES: Automatically Inferring Security Specifications
		  and Detecting Violations}},
  year		= {2008}
}

@InProceedings{	  tan08:autoises,
  author	= {Tan, L and Zhang, X and Ma, X and Xiong, W and Zhou, Y},
  booktitle	= {Proceedings of the USENIX Security Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 - Tan
		  et al. - AutoISES Automatically Inferring Security
		  Specifications and Detecting Violations.pdf:pdf},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  month		= {jul},
  pages		= {379--394},
  title		= {{AutoISES: Automatically Inferring Security Specifications
		  and Detecting Violations}},
  year		= {2008}
}

@Article{	  tartler2012,
  author	= {Tartler, Reinhard and Kurmus, Anil and Ruprecht, Andreas},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Tartler, Kurmus, Ruprecht - Automatic OS kernel TCB
		  reduction by leveraging compile-time
		  configurability.pdf:pdf},
  journal	= {Proceedings of the {\ldots}},
  mendeley-groups={6 - Application/Attack surface reduction},
  title		= {{Automatic OS kernel TCB reduction by leveraging
		  compile-time configurability}},
  url		= {https://www.usenix.org/sites/default/files/conference/protected-files/tartler{\_}hotdep12{\_}slides.pdf}
		  ,
  year		= {2012}
}

@Article{	  tehranipoor2010,
  abstract	= {Editor's note:Today's integrated circuits are vulnerable
		  to hardware Trojans, which are malicious alterations to the
		  circuit, either during design or fabrication. This article
		  presents a classification of hardware Trojans and a survey
		  of published techniques for Trojan detection.},
  author	= {Tehranipoor, Mohammad and Koushanfar, Farinaz},
  doi		= {10.1109/MDT.2010.7},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Tehranipoor, Koushanfar - A survey of hardware trojan
		  taxonomy and detection.pdf:pdf},
  issn		= {07407475},
  journal	= {IEEE Design and Test of Computers},
  number	= {1},
  pages		= {10--25},
  title		= {{A survey of hardware trojan taxonomy and detection}},
  volume	= {27},
  year		= {2010}
}

@Article{	  thom2008,
  author	= {Thom, Peter R and Maccarley, C Arthur},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Thom, Maccarley - A Spy Under the Hood Controlling Risk and
		  Automotive EDR.pdf:pdf},
  journal	= {Risk Management},
  pages		= {22--26},
  title		= {{A Spy Under the Hood: Controlling Risk and Automotive
		  EDR}},
  year		= {2008}
}

@Article{	  tice2014,
  abstract	= {Constraining dynamic control transfers is a common tech-
		  nique for mitigating software vulnerabilities. This de-
		  fense has been widely and successfully used to protect
		  return addresses and stack data; hence, current attacks
		  instead typically corrupt vtable and function pointers to
		  subvert a forward edge (an indirect jump or call) in the
		  control-flow graph. Forward edges can be protected us- ing
		  Control-Flow Integrity (CFI) but, to date, CFI im-
		  plementations have been research prototypes, based on
		  impractical assumptions or ad hoc, heuristic techniques. To
		  be widely adoptable, CFI mechanisms must be inte- grated
		  into production compilers and be compatible with
		  software-engineering aspects such as incremental compi-
		  lation and dynamic libraries. This paper presents
		  implementations of fine-grained, forward-edge CFI
		  enforcement and analysis for GCC and LLVM that meet the
		  above requirements. An analysis and evaluation of the
		  security, performance, and resource consumption of these
		  mechanisms applied to the SPEC CPU2006 benchmarks and
		  common benchmarks for the Chromium web browser show the
		  practicality of our ap- proach: these fine-grained CFI
		  mechanisms have signif- icantly lower overhead than recent
		  academic CFI proto- types. Implementing CFI in industrial
		  compiler frame- works has also led to insights into design
		  tradeoffs and practical challenges, such as dynamic
		  loading.},
  author	= {Tice, Caroline and Roeder, Tom and Collingbourne, Peter
		  and Checkoway, Stephen and Erlingsson, {\'{U}}lfar and
		  Lozano, Luis and Pike, Geoff},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Tice et al. - Enforcing Forward-Edge Control-Flow Integrity
		  in GCC {\&} LLVM.pdf:pdf},
  isbn		= {9781931971157},
  journal	= {23rd USENIX Security Symposium},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {941--955},
  title		= {{Enforcing Forward-Edge Control-Flow Integrity in GCC {\&}
		  LLVM}},
  year		= {2014}
}

@Article{	  tran2011,
  abstract	= {Return-into-libc (RILC) is one of the most common forms of
		  code-reuse attacks. In this attack, an intruder uses a
		  buﬀer overﬂow or other exploit to redirect control
		  ﬂow through existing (libc) functions within the
		  legitimate program. While dangerous, it is generally
		  consid- ered limited in its expressive power since it only
		  allows the attacker to ex- ecute straight-line code. In
		  other words, RILC attacks are believed to be incapable of
		  arbitrary computationthey are not Turing complete. Con-
		  sequently, to address this limitation, researchers have
		  developed other code-reuse techniques, such as
		  return-oriented programming (ROP). In this paper, we make
		  the counterargument and demonstrate that the orig- inal
		  RILC technique is indeed Turing complete. Speciﬁcally, we
		  present a generalized RILC attack called Turing complete
		  RILC (TC-RILC) that allows for arbitrary computations. We
		  demonstrate that TC-RILC sat- isﬁes formal requirements
		  of Turing-completeness. In addition, because it depends on
		  the well-deﬁned semantics of libc functions, we also show
		  that a TC-RILC attack can be portable between diﬀerent
		  versions (or even diﬀerent families) of operating systems
		  and naturally has negative implications for some existing
		  anti-ROP defenses. The development of TC-RILC on both Linux
		  and Windows platforms demonstrates the ex- pressiveness and
		  practicality of the generalized RILC attack.},
  author	= {Tran, Minh and Etheridge, Mark and Bletsch, Tyler and
		  Jiang, Xuxian and Freeh, Vincent and Ning, Peng},
  doi		= {10.1007/978-3-642-23644-0{\_}7},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Tran et al. - On the Expressiveness of Return-into-libc
		  Attacks.pdf:pdf},
  isbn		= {9783642236433},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  keywords	= {Return-into-libc,Turing-complete,return-oriented
		  programming},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {121--141},
  title		= {{On the expressiveness of return-into-libc attacks}},
  volume	= {6961 LNCS},
  year		= {2011}
}

@InProceedings{	  tripp2009,
  annote	= {This is a paper describing how the static analysis of
		  AppScan (IBM{\&}{\#}039;s tool) works.
		  
		  They use a hybrid form of context-sensitivity and
		  context-insensitivty to balance scalability with percision.
		  
		  They{\&}{\#}039;re pretty good, but still have a lot of
		  false positives.},
  author	= {Tripp, Omer and Pistoia, Marco and Fink, Stephen and
		  Sridharan, Manu and Weisman, Omri},
  booktitle	= {Proceedings of the 2009 ACM SIGPLAN conference on
		  Programming language design and implementation},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Tripp et al. - TAJ Effective Taint Analysis of Web
		  Applications.pdf:pdf},
  isbn		= {9781605583921},
  keywords	= {attacks,bility,cross-site
		  scripting,flow,information,integrity,may occur when
		  a,originat-,security,static analysis,taint analysis,the
		  most common vulnera-,web application accepts data,web
		  applications,xss},
  title		= {{TAJ : Effective Taint Analysis of Web Applications}},
  year		= {2009}
}

@Article{	  tsow2006,
  author	= {Tsow, Alex and Jakobsson, Markus and Yang, Liu and Wetzel,
		  Susanne},
  doi		= {10.1080/15567280600995832},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Tsow et al. - Warkitting The Drive-by Subversion of
		  Wireless Home Routers.pdf:pdf},
  issn		= {1556-7281},
  journal	= {Journal of Digital Forensic Practice},
  number	= {3},
  pages		= {179--192},
  title		= {{Warkitting: The Drive-by Subversion of Wireless Home
		  Routers}},
  volume	= {1},
  year		= {2006}
}

@Article{	  tuck2004,
  abstract	= { Intrusion detection systems (IDSs) have become widely
		  recognized as powerful tools for identifying, deterring and
		  deflecting malicious attacks over the network. Essential to
		  almost every intrusion detection system is the ability to
		  search through packets and identify content that matches
		  known attacks. Space and time efficient string matching
		  algorithms are therefore important for identifying these
		  packets at line rate. We examine string matching algorithms
		  and their use for intrusion detection, in particular, we
		  focus our efforts on providing worst-case performance that
		  is amenable to hardware implementation. We contribute
		  modifications to the Aho-Corasick string-matching algorithm
		  that drastically reduce the amount of memory required and
		  improve its performance on hardware implementations. We
		  also show that these modifications do not drastically
		  affect software performance on commodity processors, and
		  therefore may be worth considering in these cases as
		  well.},
  author	= {Tuck, Nathan and Sherwood, Timothy and Calder, Brad and
		  Varghese, George},
  doi		= {10.1109/INFCOM.2004.1354682},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Tuck et al. - Deterministic memory-efficient string
		  matching algorithms for intrusion detection.pdf:pdf},
  isbn		= {0780383559},
  issn		= {0743166X},
  journal	= {Proceedings - IEEE INFOCOM},
  keywords	= {Network Algorithms,System Design},
  pages		= {2628--2639},
  title		= {{Deterministic memory-efficient string matching algorithms
		  for intrusion detection}},
  volume	= {4},
  year		= {2004}
}

@Article{	  valeur2004,
  author	= {Valeur, Fredrik and Vigna, Giovanni and Kruegel,
		  Christopher and Kemmerer, Richard A.},
  doi		= {10.1007/3-540-35375-5},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Valeur et al. - A Comprehensive Approach to Intrusion
		  Detection Alert Correlation.pdf:pdf},
  isbn		= {0001250000},
  issn		= {0001250000},
  journal	= {IEEE Transactions on Dependable and Security Computing},
  keywords	= {default resting state,hemispheric
		  specialization,laterality,mirror,neurons,self-awareness,self-recognition,social
		  cognition},
  pmid		= {1000111929},
  title		= {{A Comprehensive Approach to Intrusion Detection Alert
		  Correlation}},
  year		= {2004}
}

@Article{	  vasudevan2012,
  abstract	= {Much effort has been spent to reduce the software Trusted
		  Computing Base (TCB) of modern systems. However, there
		  remains a large and complex hardware TCB, including memory,
		  peripherals, and system buses. There are many stronger, but
		  still realistic, adversary models where we need to consider
		  that this hardware may be malicious or compromised. Thus,
		  there is a practical need to determine whether we can
		  achieve secure program execution in the presence of not
		  only malicious software, but also malicious hardware.},
  author	= {Vasudevan, Amit and McCune, Jonathan and Newsome, James
		  and Perrig, Adrian and van Doorn, Leendert},
  doi		= {10.1145/2414456.2414484},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Vasudevan et al. - CARMA A Hardware Tamper-resistant
		  Isolated Execution Environment on Commodity x86
		  Platforms.pdf:pdf},
  isbn		= {978-1-4503-1648-4},
  journal	= {Proceedings of the 7th ACM Symposium on Information,
		  Computer and Communications Security},
  keywords	= {cache-as-ram,cution,on-die exe-,secure execution,tcb
		  reduction},
  pages		= {48--49},
  title		= {{CARMA: A Hardware Tamper-resistant Isolated Execution
		  Environment on Commodity x86 Platforms}},
  url		= {http://doi.acm.org/10.1145/2414456.2414484},
  year		= {2012}
}

@Article{	  vasudevan2013,
  author	= {Vasudevan, A. and Chaki, S. and {Limin Jia} and McCune, J.
		  and Newsome, J. and Datta, A.},
  doi		= {10.1109/SP.2013.36},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Vasudevan et al. - Design , Implementation and Verification
		  of an eXtensible and Modular Hypervisor Framework.pdf:pdf},
  isbn		= {978-0-7695-4977-4},
  journal	= {2013 IEEE Symposium on Security and Privacy},
  keywords	= {-hypervisor framework,cation,hypapps,hypervisor
		  applications,memory integrity,verifi-},
  mendeley-groups={4 - Hypervisor},
  pages		= {430--444},
  title		= {{Design, Implementation and Verification of an eXtensible
		  and Modular Hypervisor Framework}},
  url		= {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6547125}
		  ,
  year		= {2013}
}

@Article{	  vidas2014,
  abstract	= {The large amounts of malware, and its diversity, have made
		  it nec- essary for the security community to use automated
		  dynamic anal- ysis systems. These systems often rely on
		  virtualization or emu- lation, and have recently started to
		  be available to process mobile malware. Conversely, malware
		  authors seek to detect such systems and evade analysis. In
		  this paper, we present techniques for detect- ing Android
		  runtime analysis systems. Our techniques are classi- fied
		  into four broad classes showing the ability to detect
		  systems based on differences in behavior, performance,
		  hardware and soft- ware components, and those resulting
		  from analysis system design choices. We also evaluate our
		  techniques against current publicly accessible systems, all
		  of which are easily identified and can there- fore be
		  hindered by a motivated adversary. Our results show some
		  fundamental limitations in the viability of
		  dynamicmobilemalware analysis platforms purely based on
		  virtualization.},
  author	= {Vidas, Timothy and Christin, Nicolas},
  doi		= {10.1145/2590296.2590325},
  file		= {::},
  isbn		= {9781450328005},
  journal	= {ASIA CCS '14 (9th ACM symposium on Information, computer
		  and communications security)},
  keywords	= {android,evasion,malware,sandbox,security},
  pages		= {447--458},
  title		= {{Evading android runtime analysis via sandbox detection}},
  url		= {http://dl.acm.org/citation.cfm?doid=2590296.2590325},
  year		= {2014}
}

@Article{	  vrable2005,
  abstract	= {The rapid evolution of large-scale worms, viruses and bot-
		  nets have made Internet malware a pressing concern. Such
		  infections are at the root of modern scourges including
		  DDoS extortion, on-line identity theft, SPAM, phishing, and
		  piracy. However, the most widely used tools for gathering
		  intelli- gence on new malware — network honeypots —
		  have forced investigators to choose between monitoring
		  activity at a large scale or capturing behavior with high
		  fidelity. In this paper, we describe an approach to
		  minimize this tension and improve honeypot scalability by
		  up to six orders of magni- tude while still closely
		  emulating the execution behavior of individual Internet
		  hosts. We have built a prototype hon- eyfarm system, called
		  Potemkin, that exploits virtual ma- chines, aggressive
		  memory sharing, and late binding of re- sources to achieve
		  this goal. While still an immature im- plementation,
		  Potemkin has emulated over 64,000 Internet honeypots in
		  live test runs, using only a handful of physical servers.},
  author	= {Vrable, Michael and Ma, Justin and Chen, Jay and Moore,
		  David and Vandekieft, Erik and Snoeren, Alex C and Voelker,
		  Geoffrey M and Savage, Stefan},
  doi		= {10.1145/1095810.1095825},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Vrable et al. - in the Potemkin Virtual Honeyfarm
		  Categories and Subject Descriptors.pdf:pdf},
  isbn		= {1595930795},
  issn		= {0163-5980},
  journal	= {Sosp},
  keywords	= {copy-on-write,honeyfarm,honeypot,malware,virtual ma-},
  pages		= {148--162},
  title		= {{in the Potemkin Virtual Honeyfarm Categories and Subject
		  Descriptors}},
  year		= {2005}
}

@Article{	  wahbe1993,
  abstract	= {Wa93},
  author	= {Wahbe, Robert and Lucco, Steven and Anderson, Thomas E.
		  and Graham, Susan L.},
  doi		= {10.1145/173668.168635},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/p203-wahbe.pdf:pdf}
		  ,
  isbn		= {9780897916325},
  issn		= {01635980},
  journal	= {ACM SIGOPS Operating Systems Review},
  number	= {5},
  pages		= {203--216},
  title		= {{Efficient software-based fault isolation}},
  url		= {http://portal.acm.org/citation.cfm?doid=173668.168635},
  volume	= {27},
  year		= {1993}
}

@Article{	  waksman2010,
  abstract	= {Most security mechanisms proposed to date unquestioningly
		  place trust in microprocessor hardware. This trust,
		  however, is misplaced and dangerous because microprocessors
		  are vulnerable to insider attacks that can catastrophically
		  compromise security, integrity and privacy of computer
		  systems. In this paper, we describe several methods to
		  strengthen the fundamental assumption about trust in
		  microprocessors. By employing practical, lightweight attack
		  detectors within a microprocessor, we show that it is
		  possible to protect against malicious logic embedded in
		  microprocessor hardware. We propose and evaluate two
		  area-efficient hardware methods - TrustNet and DataWatch -
		  that detect attacks on microprocessor hardware by
		  knowledgeable, malicious insiders. Our mechanisms leverage
		  the fact that multiple components within a microprocessor
		  (e.g., fetch, decode pipeline stage etc.) must necessarily
		  coordinate and communicate to execute even simple
		  instructions, and that any attack on a microprocessor must
		  cause erroneous communications between micro architectural
		  subcomponents used to build a processor. A key aspect of
		  our solution is that TrustNet and DataWatch are themselves
		  highly resilient to corruption. We demonstrate that under
		  realistic assumptions, our solutions can protect pipelines
		  and on-chip cache hierarchies at negligible area cost and
		  with no performance impact. Combining TrustNet and
		  DataWatch with prior work on fault detection has the
		  potential to provide complete coverage against a large
		  class of microprocessor attacks.},
  author	= {Waksman, Adam and Sethumadhavan, Simha},
  doi		= {10.1109/SP.2010.19},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Waksman, Sethumadhavan - Tamper evident
		  microprocessors.pdf:pdf},
  isbn		= {9780769540351},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  keywords	= {Backdoors,Hardware security,Microprocessors,Security based
		  on causal structure and division of},
  pages		= {173--188},
  title		= {{Tamper evident microprocessors}},
  year		= {2010}
}

@Article{	  waksman2011,
  abstract	= {Hardware components can contain hidden backdoors, which
		  can be enabled with catastrophic effects or for ill-gotten
		  profit. These backdoors can be inserted by a malicious
		  insider on the design team or a third-party IP provider. In
		  this paper, we propose techniques that allow us to build
		  trustworthy hardware systems from components designed by
		  untrusted designers or procured from untrusted third-party
		  IP providers. We present the first solution for disabling
		  digital, design-level hardware backdoors. The principle is
		  that rather than try to discover the malicious logic in the
		  design -- an extremely hard problem -- we make the backdoor
		  design problem itself intractable to the attacker. The key
		  idea is to scramble inputs that are supplied to the
		  hardware units at runtime, making it infeasible for
		  malicious components to acquire the information they need
		  to perform malicious actions. We show that the proposed
		  techniques cover the attack space of deterministic, digital
		  HDL backdoors, provide probabilistic security guarantees,
		  and can be applied to a wide variety of hardware
		  components. Our evaluation with the SPEC 2006 benchmarks
		  shows negligible performance loss (less than 1{\&}{\#}x025;
		  on average) and that our techniques can be integrated into
		  contemporary microprocessor designs.},
  author	= {Waksman, Adam and Sethumadhavan, Simha},
  doi		= {10.1109/SP.2011.27},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Waksman, Sethumadhavan - Silencing Hardware
		  Backdoors.pdf:pdf},
  isbn		= {9780769544021},
  issn		= {10816011},
  journal	= {Proceedings of the IEEE Symposium on Security and
		  Privacy},
  keywords	= {Backdoors,Hardware,Performance,Security,Triggers},
  pages		= {49--63},
  title		= {{Silencing Hardware Backdoors}},
  year		= {2011}
}

@Article{	  wang2004,
  abstract	= {We present a payload-based anomaly detector, we call PAYL,
		  for intrusion detection. PAYL models the normal application
		  payload of network traffic in a fully automatic,
		  unsupervised and very effecient fashion. We first compute
		  during a training phase a profile byte frequency
		  distribution and their standard deviation of the
		  application payload flowing to a single host and port. We
		  then use Mahalanobis distance during the detection phase to
		  calculate the similarity of new data against the
		  pre-computed profile. The detector compares this measure
		  against a threshold and generates an alert when the
		  distance of the new input exceeds this threshold. We
		  demonstrate the surprising effectiveness of the method on
		  the 1999 DARPA IDS dataset and a live dataset we collected
		  on the Columbia CS department network. In once case nearly
		  100{\%} accuracy is achieved with 0.1{\%} false positive
		  rate for port 80 traffic.},
  archiveprefix	= {arXiv},
  arxivid	= {file:///home/spikeh/Dropbox/chp{\%}253A10.1007{\%}252F11553595{\_}10.pdf}
		  ,
  author	= {Wang, Ke and Stolfo, Sj},
  doi		= {10.1007/978-3-540-30143-1{\_}11},
  eprint	= {//home/spikeh/Dropbox/chp{\%}253A10.1007{\%}252F11553595{\_}10.pdf}
		  ,
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Wang, Stolfo - Anomalous payload-based network intrusion
		  detection.pdf:pdf},
  isbn		= {978-3-540-23123-3},
  issn		= {03029743},
  journal	= {Recent Advances in Intrusion Detection},
  pages		= {203--222},
  primaryclass	= {file:},
  title		= {{Anomalous payload-based network intrusion detection}},
  url		= {http://link.springer.com/chapter/10.1007/978-3-540-30143-1{\_}11}
		  ,
  year		= {2004}
}

@Article{	  wang2005,
  abstract	= {Stealth malware programs that silently infect enterprise
		  and consumer machines are becoming a major threat to the
		  future of the Internet. Resource hiding is a powerful
		  stealth technique commonly used by malware to evade
		  detection by computer users and anti-malware scanners. In
		  this paper, we focus on a subclass of malware, termed
		  "ghostware", which hide files, configuration settings,
		  processes, and loaded modules from the operating system's
		  query and enumeration application programming interfaces
		  (APIs). Instead of targeting individual stealth
		  implementations, we describe a systematic framework for
		  detecting multiple types of hidden resources by leveraging
		  the hiding behavior as a detection mechanism. Specifically,
		  we adopt a cross-view diff-based approach to ghostware
		  detection by comparing a high-level infected scan with a
		  low-level clean scan and alternatively comparing an
		  inside-the-box infected scan with an outside-the-box clean
		  scan. We describe the design and implementation of the
		  Strider GhostBuster tool and demonstrate its efficiency and
		  effectiveness in detecting resources hidden by real-world
		  malware such as rootkits, Trojans, and key-loggers.},
  author	= {Wang, Y.-M. and Beck, D. and Vo, B. and Roussev, R. and
		  Verbowski, C.},
  doi		= {10.1109/DSN.2005.39},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Wang et al. - Detecting stealth software with Strider
		  GhostBuster.pdf:pdf},
  isbn		= {0-7695-2282-3},
  journal	= {International Conference on Dependable Systems and
		  Networks (DSN)},
  title		= {{Detecting stealth software with Strider GhostBuster}},
  year		= {2005}
}

@Article{	  wang2008,
  abstract	= {This paper addresses a new threat to the security of
		  integrated circuits (ICs) used in safety critical, security
		  and military systems. The migration of IC fabrication to
		  low-cost foundries has made ICs vulnerable to malicious
		  alterations, that could, under specific conditions, result
		  in functional changes and/or catastrophic failure of the
		  system in which they are embedded. We refer to such
		  malicious alternations and inclusions as Hardware Trojans.
		  The modification(s) introduced by the Trojan depends on the
		  application, with some designed to disable the system or
		  degrade signal integrity, while others are designed to
		  defeat hardware security and encryption to leak plain text
		  information. This paper explores the wide range of
		  malicious alternations of ICs that are possible and
		  proposes a general framework for their classification. The
		  taxonomy is essential for properly evaluating the
		  effectiveness of methods designed to detect Trojans. The
		  latter portion of the paper explores several Trojan
		  detection strategies and the classes of Trojans each is
		  most likely to detect.},
  author	= {Wang, Xiaoxiao and Tehranipoor, Mohammad and Plusquellic,
		  Jim},
  doi		= {10.1109/HST.2008.4559039},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Wang, Tehranipoor, Plusquellic - Detecting malicious
		  inclusions in secure hardware Challenges and
		  solutions.pdf:pdf},
  isbn		= {9781424424016},
  journal	= {2008 IEEE International Workshop on Hardware-Oriented
		  Security and Trust, HOST},
  pages		= {15--19},
  title		= {{Detecting malicious inclusions in secure hardware:
		  Challenges and solutions}},
  year		= {2008}
}

@Article{	  wang2009,
  abstract	= {Kernel rootkits have posed serious security threats due to
		  their stealthy manner. To hide their presence and
		  activities, many rootkits hijack control flows by modifying
		  control data or hooks in the kernel space. A critical step
		  towards eliminating rootkits is to protect such hooks from
		  being hijacked. However, it remains a challenge because
		  there exist a large number of widely-scattered kernel hooks
		  and many of them could be dynamically allocated from kernel
		  heap and co-located together with other kernel data. In
		  addition, there is a lack of flexible commodity hardware
		  support, leading to the socalled protection granularity gap
		  – kernel hook protection requires byte-level granularity
		  but commodity hardware only provides pagelevel protection.
		  To address the above challenges, in this paper, we present
		  Hook- Safe, a hypervisor-based lightweight system that can
		  protect thousands of kernel hooks in a guest OS from being
		  hijacked. One key observation behind our approach is that a
		  kernel hook, once initialized, may be frequently
		  “read”-accessed, but rarely “write”- accessed. As
		  such, we can relocate those kernel hooks to a dedicated
		  page-aligned memory space and then regulate accesses to
		  them with hardware-based page-level protection. We have
		  developed a prototype of HookSafe and used it to protect
		  more than 5, 900 kernel hooks in a Linux guest. Our
		  experiments with nine real-world rootkits show that
		  HookSafe can effectively defeat their attempts to hijack
		  kernel hooks. We also show that HookSafe achieves such a
		  large-scale protection with a small overhead (e.g., around
		  6{\%} slowdown in performance benchmarks). Categories and
		  Subject Descriptors D.},
  author	= {Wang, Zhi and Jiang, Xuxian and Cui, Weidong and Ning,
		  Peng},
  doi		= {10.1145/1653662.1653728},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Wang et al. - Countering kernel rootkits with lightweight
		  hook protection.pdf:pdf},
  isbn		= {9781605588940},
  issn		= {15437221},
  journal	= {Proceedings of the 16th ACM conference on Computer and
		  communications security - CCS '09},
  keywords	= {malware protection,rootkits,virtual machines},
  pages		= {545},
  title		= {{Countering kernel rootkits with lightweight hook
		  protection}},
  url		= {http://portal.acm.org/citation.cfm?doid=1653662.1653728},
  year		= {2009}
}

@Article{	  wang2010,
  abstract	= {Virtualization is being widely adopted in
		  today{\&}amp;{\#}x02019;s computing systems. Its unique
		  security advantages in isolating and introspecting
		  commodity OSes as virtual machines (VMs) have enabled a
		  wide spectrum of applications. However, a common,
		  fundamental assumption is the presence of a trustworthy
		  hypervisor. Unfortunately, the large code base of commodity
		  hypervisors and recent successful hypervisor attacks (e.g.,
		  VM escape) seriously question the validity of this
		  assumption. In this paper, we present HyperSafe, a
		  lightweight approach that endows existing Type-I bare-metal
		  hypervisors with a unique self-protection capability to
		  provide lifetime control flow integrity. Specifically, we
		  propose two key techniques. The first one, non-bypassable
		  memory lockdown, reliably protects the
		  hypervisor{\&}amp;{\#}x02019;s code and static data from
		  being compromised even in the presence of exploitable
		  memory corruption bugs (e.g., buffer overflows), therefore
		  successfully providing hypervisor code integrity. The
		  second one, restricted pointer indexing, introduces one
		  layer of indirection to convert the control data into
		  pointer indexes. These pointer indexes are restricted such
		  that the corresponding call/return targets strictly follow
		  the hypervisor control flow graph, hence expanding
		  protection to control-flow integrity. We have built a
		  prototype and used it to protect two open-source Type-I
		  hypervisors: BitVisor and Xen. The experimental results
		  with synthetic hypervisor exploits and benchmarking
		  programs show HyperSafe can reliably enable the hypervisor
		  self-protection and provide the integrity guarantee with a
		  small performance overhead.},
  author	= {Wang, Zhi and Jiang, Xuxian},
  doi		= {10.1109/SP.2010.30},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Wang, Jiang - HyperSafe A lightweight approach to provide
		  lifetime hypervisor control-flow integrity.pdf:pdf},
  isbn		= {9780769540351},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {380--395},
  title		= {{HyperSafe: A lightweight approach to provide lifetime
		  hypervisor control-flow integrity}},
  year		= {2010}
}

@Article{	  wang2012,
  abstract	= {Hosted hypervisors (e.g., KVM) are being widely deployed.
		  One key reason is that they can effectively take advantage
		  of the mature features and broad user bases of commodity
		  operating systems. However, they are not immune to
		  exploitable software bugs},
  author	= {Wang, Zhi and Wu, Chiachih and Grace, Michael and Jiang,
		  Xuxian},
  doi		= {10.1145/2168836.2168850},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Wang et al. - Isolating commodity hosted hypervisors with
		  HyperLock.pdf:pdf},
  isbn		= {9781450312233},
  journal	= {Proceedings of the 7th ACM european conference on Computer
		  Systems - EuroSys '12},
  keywords	= {KVM,hypervisor,isolation,virtualization},
  pages		= {127},
  title		= {{Isolating commodity hosted hypervisors with HyperLock}},
  url		= {http://dl.acm.org/citation.cfm?id=2168836.2168850},
  year		= {2012}
}

@Article{	  wartell2012,
  author	= {Wartell, Richard and Mohan, Vishwath and Hamlen, Kevin W
		  and Lin, Zhiqiang and Rd, W Campbell},
  doi		= {10.1145/2382196.2382216},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Wartell et al. - Binary Stirring Self-randomizing
		  Instruction Addresses of Legacy x86 Binary Code.pdf:pdf},
  isbn		= {1450316514},
  issn		= {15437221},
  journal	= {Proceedings of the 2012 ACM conference on Computer and
		  communications security},
  keywords	= {obfuscation,randomization,return-oriented
		  programming,software},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {157--168},
  title		= {{Binary stirring: Self-randomizing instruction addresses
		  of legacy x86 binary code}},
  url		= {http://dl.acm.org/citation.cfm?id=2382216},
  year		= {2012}
}

@InProceedings{	  wassermann2004,
  annote	= {Crap.
		  
		  Perform static analysis on a Java application to turn SQL
		  queries into automata.
		  
		  But they only thing they really detect is if you can have a
		  tautology, but even that can be easily evaded.
		  
		  Plus, they didn{\&}{\#}039;t even implement the damn thing.},
  author	= {Wassermann, Gary and Su, Zhendong},
  booktitle	= {Proceedings of the FSE Workshop on Specification and
		  Verification of Component-Based Systems},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Wassermann, Su - An Analysis Framework for Security in Web
		  Applications.pdf:pdf},
  title		= {{An Analysis Framework for Security in Web Applications}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.2255{\&}amp;rep=rep1{\&}amp;type=pdf{\#}page=82}
		  ,
  year		= {2004}
}

@TechReport{	  wojtczuk2011,
  abstract	= {We (iscuss three software attacks that might allow for
		  escaing from a -(-rotecte( (river (omain in a
		  virtualization sstem. We then focus on one of those
		  attacks+ an( (emonstrate ractical and reliable code
		  e!ec"tion e! loit against a en syste. ,inall+ we (iscuss
		  how new har(ware from Intel offers a otential for rotection
		  against our attacks in the form of Interrut Remaing -for
		  client sstems available onl on the ver latest .an( /ri(ge
		  rocessors0. /ut we also (iscuss how this rotection coul( be
		  circumvente( on a 1en sstem un(er certain
		  circumstances...},
  author	= {Wojtczuk, Rafal and Rutkowska, Joanna},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Wojtczuk, Rutkowska - Following the White Rabbit Software
		  attacks against Intel ( R ) VT-d technology.pdf:pdf},
  pages		= {1--27},
  title		= {{Following the White Rabbit : Software attacks against
		  Intel ( R ) VT-d technology}},
  year		= {2011}
}

@InProceedings{	  wolf2004,
  abstract	= {: This work presents a study of current and future bus
		  systems with respect to their security against various
		  malicious attacks. After a brief description of the most
		  well-known and established vehicular communication systems,
		  we present feasible attacks and potential exposures for
		  these automotive networks. We also provide an approach for
		  secured automotive communication based on modern
		  cryptographic mechanisms that provide secrecy, manipulation
		  prevention and authentication to solve most of the
		  vehicular bus security issues.},
  author	= {Wolf, Marko and Weimerskirch, Andr{\'{e}} and Paar,
		  Christof},
  booktitle	= {Proceedings of the Workshop on Embedded Security in Cars},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2004 -
		  Wolf, Weimerskirch, Paar - Security in Automotive Bus
		  Systems.pdf:pdf},
  keywords	= {attacks,authentication,automotive communication
		  security,bluetooth,can,encryption,flexray,lin,most,systems,vehicular
		  bus},
  pages		= {1--13},
  title		= {{Security in Automotive Bus Systems}},
  url		= {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.92.728{\&}amp;rep=rep1{\&}amp;type=pdf}
		  ,
  year		= {2004}
}

@Article{	  wolf2007,
  abstract	= {For new automotive applications and services, information
		  technology (IT) has gained central importance. IT-related
		  costs in car manufacturing are already high and they will
		  increase dramatically in the future. Yet whereas safety and
		  reliability have become a relatively well-established
		  field, the protection of vehicular IT systems against
		  systematic manipulation or intrusion has only recently
		  started to emerge. Nevertheless, IT security is already the
		  base of some vehicular applications such as immobilizers or
		  digital tachographs. To securely enable future automotive
		  applications and business models, IT security will be one
		  of the central technologies for the next generation of
		  vehicles. After a state-of-the-art overview of IT security
		  in vehicles, we give a short intro- duction into
		  cryptographic terminology and functionality. This
		  contributionwill then identify the need for automotive IT
		  security while presenting typical attacks, resulting
		  security objectives, and characteristic constraints within
		  the automotive area. We will introduce core security
		  technologies and relevant securitymechanisms followed by a
		  detailed description of critical vehicular ap- plications,
		  business models, and components relying on IT security.We
		  conclude our contributionwith a detailed statement about
		  challenges and opportunities for the automotive IT
		  community for embedding IT security in vehicles.},
  author	= {Wolf, Marko and Weimerskirch, Andr{\'{e}} and Wollinger,
		  Thomas},
  doi		= {10.1155/2007/74706},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Wolf, Weimerskirch, Wollinger - State of the art Embedding
		  security in vehicles.pdf:pdf},
  issn		= {16873955},
  journal	= {Eurasip Journal on Embedded Systems},
  title		= {{State of the art: Embedding security in vehicles}},
  volume	= {2007},
  year		= {2007}
}

@InProceedings{	  wolf2012,
  author	= {Wolf, Marko and Gendrullis, Timo},
  booktitle	= {Proceedings of the International Conference on Information
		  Security and Cryptology (ICISC)},
  doi		= {10.1007/978-3-642-31912-9{\_}20},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Wolf, Gendrullis - Design, Implementation, and evaluation
		  of a vehicular hardware security module.pdf:pdf},
  isbn		= {9783642319112},
  issn		= {03029743},
  keywords	= {automotive,hardware security module,in-vehicle,on-board},
  pages		= {302--318},
  title		= {{Design, Implementation, and evaluation of a vehicular
		  hardware security module}},
  volume	= {7259 LNCS},
  year		= {2012}
}

@Article{	  wright2011,
  author	= {Wright, Alex},
  doi		= {10.1145/2018396.2018403},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Wright - Hacking cars.pdf:pdf},
  issn		= {00010782},
  journal	= {Communications of the ACM},
  number	= {11},
  pages		= {18},
  title		= {{Hacking cars}},
  volume	= {54},
  year		= {2011}
}

@InProceedings{	  xie2006,
  annote	= {Great paper about detecting XSS and SQL injection
		  vulnerabilities in PHP applications.
		  
		  They compute summaries for every basic block (about what
		  must be sanitized/is sanitized) and they create the same
		  summaries for every function.
		  
		  They then use these summaries to detect taint flow from
		  user input to sinks.
		  
		  They have zero false positives, which I don{\&}{\#}039;t
		  really believe.
		  
		  },
  author	= {Xie, Yichen and Aiken, A.},
  booktitle	= {Proceedings of the 15th conference on USENIX Security
		  Symposium},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Xie, Aiken - Static detection of security vulnerabilities
		  in scripting languages.pdf:pdf},
  pages		= {13--13},
  title		= {{Static detection of security vulnerabilities in scripting
		  languages}},
  url		= {http://www.usenix.org/events/sec06/tech/full{\_}papers/xie/xie{\_}html/}
		  ,
  year		= {2006}
}

@Article{	  xu2012,
  abstract	= {The increasing popularity of Google’s mobile platform
		  Android makes it the prime target of the latest surge in
		  mobile malware. Most research on enhancing the platform’s
		  security and privacy controls requires extensive
		  modification to the operating system, which has significant
		  usability issues and hinders efforts for widespread
		  adoption. We develop a novel solution called Aurasium that
		  bypasses the need to modify the Android OS while providing
		  much of the security and privacy that users de- sire. We
		  automatically repackage arbitrary applications to attach
		  user-level sandboxing and policy enforcement code, which
		  closely watches the application’s behavior for security
		  and privacy violations such as attempts to retrieve a
		  user’s sensitive information, send SMS covertly to
		  premium numbers, or access malicious IP addresses. Aurasium
		  can also detect and prevent cases of privilege escalation
		  attacks. Experiments show that we can apply this solution
		  to a large sample of benign and malicious applications with
		  a near 100 percent success rate, with- out significant
		  performance and space overhead. Aura- sium has been tested
		  on three versions of the Android OS, and is freely
		  available.},
  author	= {Xu, Rubin and Sa{\"{\i}}di, Hassen and Anderson, Ross and
		  Saıdi, Hassen},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 - Xu
		  et al. - Aurasium Practical Policy Enforcement for Android
		  Applications.pdf:pdf},
  isbn		= {978-931971-95-9},
  journal	= {Proceedings of the 21st USENIX conference {\ldots}},
  pages		= {27},
  title		= {{Aurasium: Practical Policy Enforcement for Android
		  Applications}},
  url		= {https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final60.pdf$\backslash$nhttp://dl.acm.org/citation.cfm?id=2362793.2362820}
		  ,
  year		= {2012}
}

@Article{	  xu2012,
  abstract	= {The increasing popularity of Google’s mobile platform
		  Android makes it the prime target of the latest surge in
		  mobile malware. Most research on enhancing the platform’s
		  security and privacy controls requires extensive
		  modification to the operating system, which has significant
		  usability issues and hinders efforts for widespread
		  adoption. We develop a novel solution called Aurasium that
		  bypasses the need to modify the Android OS while providing
		  much of the security and privacy that users de- sire. We
		  automatically repackage arbitrary applications to attach
		  user-level sandboxing and policy enforcement code, which
		  closely watches the application’s behavior for security
		  and privacy violations such as attempts to retrieve a
		  user’s sensitive information, send SMS covertly to
		  premium numbers, or access malicious IP addresses. Aurasium
		  can also detect and prevent cases of privilege escalation
		  attacks. Experiments show that we can apply this solution
		  to a large sample of benign and malicious applications with
		  a near 100 percent success rate, with- out significant
		  performance and space overhead. Aura- sium has been tested
		  on three versions of the Android OS, and is freely
		  available.},
  author	= {Xu, Rubin and Sa{\"{\i}}di, Hassen and Anderson, Ross and
		  Saıdi, Hassen},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 - Xu
		  et al. - Aurasium Practical Policy Enforcement for Android
		  Applications.pdf:pdf},
  isbn		= {978-931971-95-9},
  journal	= {Proceedings of the 21st USENIX conference {\ldots}},
  mendeley-groups={6 - Application/Attack surface reduction},
  pages		= {27},
  title		= {{Aurasium: Practical Policy Enforcement for Android
		  Applications}},
  url		= {https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final60.pdf$\backslash$nhttp://dl.acm.org/citation.cfm?id=2362793.2362820}
		  ,
  year		= {2012}
}

@InProceedings{	  yang2008,
  abstract	= {Hypervisors are increasingly utilized in modern computer
		  systems, ranging from PCs to web servers and data centers.
		  Aside from server applications, hypervisors are also
		  becoming a popular target for implementing many security
		  systems, since they provide a small and easy-to-secure
		  trusted computing base. This paper presents a novel way of
		  using hypervisors to protect application data privacy even
		  when the underlying operating system is not trustable. Each
		  page in virtual address space is rendered to user
		  applications according to the security context the
		  application is running in. The hypervisor encrypts and
		  decrypts each memory page requested depending on the
		  application's access permission to the page. The main
		  result of this system is the complete removal of the
		  operating system from the trust base for user applications'
		  data privacy. To reduce the runtime overhead of the system,
		  two optimization techniques are employed. We use page-frame
		  replication to reduce the number ofcryptographic operations
		  by keeping decrypted versions of a page frame. We also
		  employ lazy synchronization to minimize overhead due to an
		  update to one of the replicated page frame. Our system is
		  implemented and evaluated by modifying the Xen hypervisor,
		  showing that it increases the application execution time
		  only by 3{\%} for CPU and memory-intensive workloads.},
  author	= {Yang, Jisoo and Shin, Kang G.},
  booktitle	= {Proceedings of the ACM SIGPLAN/SIGOPS international
		  conference on Virtual execution environments (VEE)},
  doi		= {10.1145/1346256.1346267},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2008 -
		  Yang, Shin - Using hypervisor to provide data secrecy for
		  user applications on a per-page basis.pdf:pdf},
  isbn		= {978-1-59593-796-4},
  keywords	= {application protection,data privacy,hypervisor,vir-},
  pages		= {71--80},
  title		= {{Using hypervisor to provide data secrecy for user
		  applications on a per-page basis}},
  url		= {http://portal.acm.org.library.capella.edu/citation.cfm?id=1346256.1346267{\&}coll=portal{\&}dl=ACM{\&}CFID=824734{\&}CFTOKEN=52522302$\backslash$nhttp://portal.acm.org.library.capella.edu/ft{\_}gateway.cfm?id=1346267{\&}type=pdf{\&}coll=portal{\&}dl=ACM{\&}CFID=824734{\&}CFTOKEN=52522302}
		  ,
  year		= {2008}
}

@Article{	  yee,
  author	= {Yee, Ka-ping},
  file		= {::},
  title		= {{User Interaction Design for Secure Systems}}
}

@Article{	  yee2009,
  abstract	= {This paper describes the design, implementation and
		  evaluation of Native Client, a sandbox for untrusted x86
		  native code. Native Client aims to give browser-based
		  applications the computational performance of native
		  applications without compromising safety. Native Client
		  uses software fault isolation and a secure runtime to
		  direct system interaction and side effects through
		  interfaces managed by Native Client. Native Client provides
		  operating system portability for binary code while
		  supporting performance-oriented features generally absent
		  from Web application programming environments, such as
		  thread support, instruction set extensions such as SSE, and
		  use of compiler intrinsics and hand-coded assembler. We
		  combine these properties in an open architecture that
		  encourages community review and 3rd-party tools.},
  author	= {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen,
		  J. Bradley and Muth, Robert and Ormandy, Tavis and Okasaka,
		  Shiki and Narula, Neha and Fullagar, Nicholas},
  doi		= {10.1109/SP.2009.25},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 - Yee
		  et al. - Native client A sandbox for portable, untrusted
		  x86 native code.pdf:pdf},
  isbn		= {9780769536330},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {79--93},
  title		= {{Native client: A sandbox for portable, untrusted x86
		  native code}},
  year		= {2009}
}

@Article{	  yee2009,
  abstract	= {This paper describes the design, implementation and
		  evaluation of Native Client, a sandbox for untrusted x86
		  native code. Native Client aims to give browser-based
		  applications the computational performance of native
		  applications without compromising safety. Native Client
		  uses software fault isolation and a secure runtime to
		  direct system interaction and side effects through
		  interfaces managed by Native Client. Native Client provides
		  operating system portability for binary code while
		  supporting performance-oriented features generally absent
		  from Web application programming environments, such as
		  thread support, instruction set extensions such as SSE, and
		  use of compiler intrinsics and hand-coded assembler. We
		  combine these properties in an open architecture that
		  encourages community review and 3rd-party tools.},
  author	= {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen,
		  J. Bradley and Muth, Robert and Ormandy, Tavis and Okasaka,
		  Shiki and Narula, Neha and Fullagar, Nicholas},
  doi		= {10.1109/SP.2009.25},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 - Yee
		  et al. - Native client A sandbox for portable, untrusted
		  x86 native code.pdf:pdf},
  isbn		= {9780769536330},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  mendeley-groups={6 - Application/Attack surface reduction},
  pages		= {79--93},
  title		= {{Native client: A sandbox for portable, untrusted x86
		  native code}},
  year		= {2009}
}

@Article{	  yee2009a,
  abstract	= {This paper describes the design, implementation and
		  evaluation of Native Client, a sandbox for untrusted x86
		  native code. Native Client aims to give browser-based
		  applications the computational performance of native
		  applications without compromising safety. Native Client
		  uses software fault isolation and a secure runtime to
		  direct system interaction and side effects through
		  interfaces managed by Native Client. Native Client provides
		  operating system portability for binary code while
		  supporting performance-oriented features generally absent
		  from Web application programming environments, such as
		  thread support, instruction set extensions such as SSE, and
		  use of compiler intrinsics and hand-coded assembler. We
		  combine these properties in an open architecture that
		  encourages community review and 3rd-party tools.},
  author	= {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen,
		  J. Bradley and Muth, Robert and Ormandy, Tavis and Okasaka,
		  Shiki and Narula, Neha and Fullagar, Nicholas},
  doi		= {10.1109/SP.2009.25},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/05207638.pdf:pdf}
		  ,
  isbn		= {9780769536330},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {79--93},
  title		= {{Native client: A sandbox for portable, untrusted x86
		  native code}},
  year		= {2009}
}

@Article{	  yin2010,
  abstract	= {In order to obtain and maintain control, kernel malware
		  usually makes$\backslash$npersistent control flow
		  modifications (1 e, installing hooks) To
		  avoid$\backslash$ndetection, malware developers have
		  started to target function pointers$\backslash$nin kernel
		  data structures, especially those dynamically allocated
		  from$\backslash$nheaps and memory pools Function pointer
		  modification is stealthy and the$\backslash$nattack surface
		  is large, thus, this type of attacks is appealing
		  to$\backslash$nmalware developers In this paper, we first
		  conduct a systematic study of$\backslash$nthis problem, and
		  show that the attack surface is vast, with over
		  18,$\backslash$n000 function pointers (most of them
		  long-lived) existing within the$\backslash$nWindows kernel
		  Moreover, to demonstrate this threat is realistic
		  for$\backslash$nclosed-source operating systems, we
		  implement two new attacks for$\backslash$nWindows by
		  exploiting two function pointers individually Then,
		  we$\backslash$npropose a new proactive hook detection
		  technique, and develop a$\backslash$nprototype, called Hook
		  Scout Our approach is binary-centric, and
		  thus$\backslash$ncan generate hook detection policy without
		  access to the OS kernel$\backslash$nsource code Our
		  approach is also context-sensitive, and thus can
		  deal$\backslash$nwith polymorphic data structures We
		  evaluated Hook Scout with a set of$\backslash$nrootkits
		  which use advanced hooking techniques and show that it
		  detects$\backslash$nall of the stealth techniques utilized
		  (including our new attacks)$\backslash$nAdditionally, we
		  show that our approach is easily deployable, has
		  wide$\backslash$ncoverage and minimal performance overhead},
  author	= {Yin, Heng and Poosankam, Pongsin and Hanna, Steve and
		  Song, Dawn},
  doi		= {10.1007/978-3-642-14215-4{\_}1},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 - Yin
		  et al. - HookScout Proactive binary-centric hook
		  detection.pdf:pdf},
  isbn		= {3642142141},
  issn		= {03029743},
  journal	= {Lecture Notes in Computer Science (including subseries
		  Lecture Notes in Artificial Intelligence and Lecture Notes
		  in Bioinformatics)},
  pages		= {1--20},
  title		= {{HookScout: Proactive binary-centric hook detection}},
  volume	= {6201 LNCS},
  year		= {2010}
}

@Article{	  younan2012,
  abstract	= {The lack of memory safety in C/C++ often leads to
		  vulnerabilities. Code injection attacks exploit these
		  vulnerabilities to gain control over the execution flow of
		  applications. These attacks have played a key role in many
		  major security incidents. Consequently, a huge body of
		  research on countermeasures exists. We provide a
		  comprehensive and structured survey of vulnerabilities and
		  countermeasures that operate at runtime. These
		  countermeasures make different trade-offs in terms of
		  performance, effectivity, compatibility, etc., making it
		  hard to evaluate and compare countermeasures in a given
		  context. We define a classification and evaluation
		  framework on the basis of which countermeasures can be
		  assessed.},
  author	= {Younan, Yves and Joosen, Wouter and Piessens, Frank},
  doi		= {10.1145/2187671.2187679},
  file		= {:Users/schandramouli/Library/Application Support/Mendeley
		  Desktop/Downloaded/Younan, Joosen, Piessens - 2012 -
		  Runtime countermeasures for code injection attacks against
		  C and C programs.pdf:pdf},
  issn		= {03600300},
  journal	= {ACM Comput. Surv.},
  mendeley-groups={6 - Application/Modeling and Monitoring execution/Dynamic
		  analysis},
  number	= {3},
  pages		= {1--28},
  title		= {{Runtime countermeasures for code injection attacks
		  against C and C++ programs}},
  volume	= {44},
  year		= {2012}
}

@InProceedings{	  yu2011,
  address	= {New York, New York, USA},
  author	= {Yu, Fang and Alkhalaf, Muath and Bultan, Tevfik},
  booktitle	= {Proceeding of the 33rd international conference on
		  Software engineering - ICSE '11},
  doi		= {10.1145/1985793.1985828},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 - Yu,
		  Alkhalaf, Bultan - Patching vulnerabilities with
		  sanitization synthesis.pdf:pdf},
  isbn		= {9781450304450},
  keywords	= {automata,sanitization synthesis,string analysis},
  pages		= {251},
  publisher	= {ACM Press},
  title		= {{Patching vulnerabilities with sanitization synthesis}},
  url		= {http://portal.acm.org/citation.cfm?doid=1985793.1985828},
  year		= {2011}
}

@Article{	  yuan2006,
  abstract	= {Security concerns are becoming increasingly critical in
		  networked systems. Firewalls provide important defense for
		  network security. However, misconfigurations in firewalls
		  are very common and significantly weaken the desired
		  security. This paper introduces FIREMAN, a static analysis
		  toolkit for firewall modeling and analysis. By treating
		  firewall configurations as specialized programs, FIREMAN
		  applies static analysis techniques to check
		  misconfigurations, such as policy violations,
		  inconsistencies, and inefficiencies, in individual
		  firewalls as well as among distributed firewalls. FIREMAN
		  performs symbolic model checking of the firewall
		  configurations for all possible IP packets and along all
		  possible data paths. It is both sound and complete because
		  of the finite state nature of firewall configurations.
		  FIREMAN is implemented by modeling firewall rules using
		  binary decision diagrams (BDDs), which have been used
		  successfully in hardware verification and model checking.
		  We have experimented with FIREMAN and used it to uncover
		  several real misconfigurations in enterprise networks, some
		  of which have been subsequently confirmed and corrected by
		  the administrators of these networks.},
  author	= {Yuan, Lihua and Chen, Hao and Mai, Jianning and Chuah,
		  Chen Nee and Su, Zhendong and Mohapatra, Prasant},
  doi		= {10.1109/SP.2006.16},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2006 -
		  Yuan et al. - FIREMAN A toolkit for firewall modeling and
		  analysis.pdf:pdf},
  isbn		= {0769525741},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {199--213},
  title		= {{FIREMAN: A toolkit for firewall modeling and analysis}},
  volume	= {2006},
  year		= {2006}
}

@Article{	  zaddach2013,
  abstract	= {Embedded devices have become the usual presence in the
		  network of (m)any household(s), SOHO, enterprise or criti-
		  cal infrastructure. The preached Internet of Things
		  promises to gazillion- uple their number and heterogeneity
		  in the next few years. However, embedded devices are
		  becoming lately the usual suspects in security breaches and
		  security advisories and thus become the Achilles’ heel of
		  one’s overall infrastructure se- curity. An important
		  aspect is that embedded devices run on what’s commonly
		  known as firmwares. To understand how to secure embedded
		  devices, one needs to understand their firmware and how it
		  works. This workshop aims at presenting a quick-start at
		  how to inspect firmwares and a hands-on presentation with
		  exercises on real firmwares from a security analysis
		  standpoint. General},
  author	= {Zaddach, Jonas and Costin, Andrei},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Zaddach, Costin - Embedded Devices Security and Firmware
		  Reverse Engineering.pdf:pdf},
  journal	= {Black Hat USA},
  keywords	= {backdoors,bi-,embedded
		  devices,exploitation,firmware,firmware analysis,firmware
		  unpacking,nary analysis,reverse engineering,security,static
		  analysis,vulnerabilities},
  pages		= {9},
  title		= {{Embedded Devices Security and Firmware Reverse
		  Engineering}},
  url		= {https://media.blackhat.com/us-13/US-13-Zaddach-Workshop-on-Embedded-Devices-Security-and-Firmware-Reverse-Engineering-WP.pdf}
		  ,
  year		= {2013}
}

@Article{	  zaddach2013a,
  author	= {Zaddach, Jonas and Kurmus, Anil and Balzarotti, Davide and
		  Blass, Erik-Oliver and Francillon, Aur{\'{e}}lien and
		  Goodspeed, Travis and Gupta, Moitrayee and Koltsidas,
		  Ioannis},
  doi		= {10.1145/2523649.2523661},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Zaddach et al. - Implementation and implications of a
		  stealth hard-drive backdoor.pdf:pdf},
  isbn		= {9781450320153},
  journal	= {Proceedings of the 29th Annual Computer Security
		  Applications Conference on - ACSAC '13},
  pages		= {279--288},
  title		= {{Implementation and implications of a stealth hard-drive
		  backdoor}},
  url		= {http://dl.acm.org/citation.cfm?doid=2523649.2523661},
  year		= {2013}
}

@Article{	  zaddach2014,
  author	= {Zaddach, Jonas and Bruno, Luca and Francillon,
		  Aur{\'{e}}lien and Balzarotti, Davide},
  doi		= {10.14722/ndss.2014.23229},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Zaddach et al. - Avatar A Framework to Support Dynamic
		  Security Analysis of Embedded Systems' Firmwares.pdf:pdf},
  isbn		= {1-891562-35-5},
  journal	= {Proceedings of the 2014 Network and Distributed System
		  Security Symposium},
  number	= {February},
  pages		= {23--26},
  title		= {{Avatar: A Framework to Support Dynamic Security Analysis
		  of Embedded Systems' Firmwares}},
  url		= {http://dx.doi.org/10.14722/ndss.2014.23229},
  year		= {2014}
}

@InProceedings{	  zhang2007,
  author	= {Zhang, Charles C. and Winslett, Marianne and Gunter, Carl
		  A.},
  booktitle	= {Proceedings of the IEEE Symposium on Security and
		  Privacy},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Zhang, Winslett, Gunter - On the Safety and Efficiency of
		  Firewall Policy Deployment.pdf:pdf},
  isbn		= {0769528481},
  keywords	= {deployment,firewall policy,safety},
  title		= {{On the Safety and Efficiency of Firewall Policy
		  Deployment}},
  year		= {2007}
}

@InProceedings{	  zhang2010,
  annote	= {Very interesting paper on using static analysis and
		  information flow to detect side-channel leaks in GWT
		  applications.
		  
		  They run static analysis to figure out where sensitive
		  ({\&}quot;tainted{\&}quot;) data crosses the network
		  boundry or causes network traffic.
		  
		  Then they use this information to black-box test the
		  application to determine the actual information leaks.
		  
		  The big problem is that they test this approach on six
		  applications, three of which THEY WROTE. They did this to
		  model real-world side-channel vulnerabilities, but
		  it{\&}{\#}039;s crazy to think that the static analysis can
		  scale to real applications. Esp. considering that the other
		  three apps were TOYS.
		  
		  Ugh, overall I really like the idea and spirit of the
		  paper, but the evaluation needs serious work.},
  author	= {Zhang, Kehuan and Li, Zhou and Wang, Rui and Wang,
		  XiaoFeng and Chen, Shuo},
  booktitle	= {Proceedings of the 17th ACM conference on Computer and
		  communications security},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2010 -
		  Zhang et al. - Sidebuster Automated Detection and
		  Quantification of Side-Channel Leaks in Web Application
		  Development.pdf:pdf},
  pages		= {595--606},
  publisher	= {ACM},
  title		= {{Sidebuster: Automated Detection and Quantification of
		  Side-Channel Leaks in Web Application Development}},
  url		= {http://portal.acm.org/citation.cfm?id=1866374},
  year		= {2010}
}

@Article{	  zhang2011,
  abstract	= {Multi-tenant cloud, which usually leases resources in the
		  form of virtual machines, has been commercially available
		  for years. Un- fortunately, with the adoption of commodity
		  virtualized infrastruc- tures, software stacks in
		  typicalmulti-tenant clouds are non-trivially large and
		  complex, and thus are prone to compromise or abuse from
		  adversaries including the cloud operators, which may lead
		  to leak- age of security-sensitive data. In this paper, we
		  propose a transparent, backward-compatible ap- proach that
		  protects the privacy and integrity of customers’ virtual
		  machines on commodity virtualized infrastructures, even
		  facing a total compromise of the virtual machine monitor
		  (VMM) and the management VM. The key of our approach is the
		  separation of the resourcemanagement fromsecurity
		  protection in the virtualization layer. A tiny security
		  monitor is introduced underneath the com- modity VMM using
		  nested virtualization and provides protection to the hosted
		  VMs. As a result, our approach allows virtualization
		  software (e.g., VMM, management VM and tools) to handle
		  com- plex tasks ofmanaging leased VMs for the cloud,
		  without breaking security of users’ data inside the VMs.
		  We have implemented a prototype by leveraging commercially-
		  available hardware support for virtualization. The
		  prototype sys- tem, called CloudVisor, comprises only 5.5K
		  LOCs and supports theXenVMMwithmultipleLinux andWindows as
		  the guestOSes. Performance evaluation shows thatCloudVisor
		  incursmoderate slow- down for I/O intensive applications
		  and very small slowdown for other applications.
		  Categories},
  author	= {Zhang, Fengzhe and Chen, Jin and Chen, Haibo and Zang,
		  Binyu},
  doi		= {10.1145/2043556.2043576},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2011 -
		  Zhang et al. - CloudVisor Retrofitting Protection of
		  Virtual Machines in Multi-tenant Cloud with Nested
		  Virtualization.pdf:pdf},
  isbn		= {9781450309776},
  journal	= {SOSP '11: Proceedings of the Twenty-Third ACM Symposium on
		  Operating Systems Principles},
  keywords	= {advantage and that copies,all or part of,for profit or
		  commercial,is granted without fee,not made or
		  distributed,or hard copies of,permission to make
		  digital,personal or classroom use,provided that copies
		  are,this work for},
  mendeley-groups={4 - Hypervisor},
  pages		= {203--216},
  title		= {{Cloudvisor: retrofitting protection of virtual machines
		  in multi-tenant cloud with nested virtualization}},
  url		= {http://dl.acm.org/citation.cfm?id=2043576},
  year		= {2011}
}

@Article{	  zhang2013,
  abstract	= {Control Flow Integrity (CFI) provides a strong protection
		  against modern control-flow hijacking attacks. How- ever,
		  performance and compatibility issues limit its adoption. We
		  propose a new practical and realistic protection method
		  called CCFIR (Compact Control Flow Integrity and Random-
		  ization), which addresses the main barriers to CFI
		  adoption. CCFIR collects all legal targets of indirect
		  control-transfer in- structions, puts them into a dedicated
		  “Springboard section” in a random order, and then
		  limits indirect transfers to flow only to them. Using the
		  Springboard section for targets, CCFIR can validate a
		  target more simply and faster than traditional CFI, and
		  provide support for on-site target-randomization as well as
		  better compatibility. Based on these approaches, CCFIR can
		  stop control-flow hijacking attacks including ROP and
		  return- into-libc. Results show that ROP gadgets are all
		  eliminated.We observe that with the wide deployment of
		  ASLR, Windows/x86 PE executables contain enough information
		  in relocation tables which CCFIR can use to find all legal
		  instructions and jump targets reliably, without source code
		  or symbol information. We evaluate our prototype
		  implementation on common web browsers and the SPEC CPU2000
		  suite: CCFIR protects large applications such as GCC and
		  Firefox completely automati- cally, and has low performance
		  overhead of about 3.6{\%}/8.6{\%} (average/max) using
		  SPECint2000. Experiments on real-world exploits also show
		  that CCFIR-hardened versions of IE6, Firefox 3.6 and other
		  applications are protected effectively.},
  author	= {Zhang, Chao and Wei, Tao and Chen, Zhaofeng and Duan, Lei
		  and Szekeres, L{\'{a}}szl{\'{o}} and McCamant, Stephen and
		  Song, Dawn and Zou, Wei},
  doi		= {10.1109/SP.2013.44},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Zhang et al. - Practical control flow integrity and
		  randomization for binary executables.pdf:pdf},
  isbn		= {9780769549774},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  pages		= {559--573},
  title		= {{Practical control flow integrity and randomization for
		  binary executables}},
  year		= {2013}
}

@Article{	  zhang2013,
  abstract	= {Control-Flow Integrity (CFI) has been recognized as an
		  important low-level security property. Its enforcement can
		  defeat most injected and existing code attacks, including
		  those based on Return-Oriented Programming (ROP). Previous
		  implementations of CFI have required compiler support or
		  the presence of relocation or debug information in the
		  binary. In contrast, we present a technique for applying
		  CFI to stripped binaries on ×86/Linux. Ours is the first
		  work to apply CFI to complex shared libraries such as
		  glibc. Through experimental evaluation, we demonstrate that
		  our CFI implementation is effective against control-flow
		  hijack attacks, and eliminates the vast majority of ROP
		  gadgets. To achieve this result, we have developed robust
		  techniques for disassembly, static analysis, and
		  transformation of large binaries. Our techniques have been
		  tested on over 300MB of binaries (executables and shared
		  libraries).},
  author	= {Zhang, M. and Sekar, R.},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/Unknown -
		  Zhang, Sekar, Brook - Control Flow Integrity for COTS
		  Binaries ∗.pdf:pdf},
  isbn		= {9781931971034},
  journal	= {Proceeding SEC'13 Proceedings of the 22nd USENIX
		  conference on Security},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {337--352},
  title		= {{Contol Flow Integrity for COTS Binaries}},
  year		= {2013}
}

@Article{	  zhang2013a,
  abstract	= {Control Flow Integrity (CFI) provides a strong protection
		  against modern control-flow hijacking attacks. How- ever,
		  performance and compatibility issues limit its adoption. We
		  propose a new practical and realistic protection method
		  called CCFIR (Compact Control Flow Integrity and Random-
		  ization), which addresses the main barriers to CFI
		  adoption. CCFIR collects all legal targets of indirect
		  control-transfer in- structions, puts them into a dedicated
		  “Springboard section” in a random order, and then
		  limits indirect transfers to flow only to them. Using the
		  Springboard section for targets, CCFIR can validate a
		  target more simply and faster than traditional CFI, and
		  provide support for on-site target-randomization as well as
		  better compatibility. Based on these approaches, CCFIR can
		  stop control-flow hijacking attacks including ROP and
		  return- into-libc. Results show that ROP gadgets are all
		  eliminated.We observe that with the wide deployment of
		  ASLR, Windows/x86 PE executables contain enough information
		  in relocation tables which CCFIR can use to find all legal
		  instructions and jump targets reliably, without source code
		  or symbol information. We evaluate our prototype
		  implementation on common web browsers and the SPEC CPU2000
		  suite: CCFIR protects large applications such as GCC and
		  Firefox completely automati- cally, and has low performance
		  overhead of about 3.6{\%}/8.6{\%} (average/max) using
		  SPECint2000. Experiments on real-world exploits also show
		  that CCFIR-hardened versions of IE6, Firefox 3.6 and other
		  applications are protected effectively.},
  author	= {Zhang, Chao and Wei, Tao and Chen, Zhaofeng and Duan, Lei
		  and Szekeres, L{\'{a}}szl{\'{o}} and McCamant, Stephen and
		  Song, Dawn and Zou, Wei},
  doi		= {10.1109/SP.2013.44},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2013 -
		  Zhang et al. - Practical Control Flow Integrity {\&}
		  Randomization for Binary Executables.pdf:pdf},
  isbn		= {9780769549774},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  mendeley-groups={6 - Application/Prevent control-flow hijacking},
  pages		= {559--573},
  title		= {{Practical control flow integrity and randomization for
		  binary executables}},
  year		= {2013}
}

@InProceedings{	  zhang2014,
  author	= {Zhang, Fengwei and Wang, Haining and Leach, Kevin and
		  Stavrou, Angelos},
  booktitle	= {Proceedings of the European Symposium on Research in
		  Computer Security (ESORICS)},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Zhang et al. - A Framework to Secure Peripherals at
		  Runtime.pdf:pdf},
  keywords	= {firmware,i,integrity,o configurations,smm},
  pages		= {1--20},
  title		= {{A Framework to Secure Peripherals at Runtime}},
  year		= {2014}
}

@Article{	  zhang2014,
  author	= {Zhang, Jie and Yuan, Feng and Xu, Qiang},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Zhang, Yuan, Xu - DeTrust Defeating hardware trust
		  verification with stealthy implicitly-triggered hardware
		  Trojans.pdf:pdf},
  isbn		= {9781450329576},
  journal	= {Proceedings of the ACM conference on Computer and
		  Communications Security (CCS)},
  keywords	= {backdoors,hardware security,hardware trojan,hardware
		  trojan design,implicit trigger},
  pages		= {153--166},
  title		= {{DeTrust: Defeating hardware trust verification with
		  stealthy implicitly-triggered hardware Trojans}},
  url		= {http://dl.acm.org/citation.cfm?id=2660289},
  year		= {2014}
}

@Article{	  zhao2002,
  abstract	= { The author describes current and future wireless
		  applications that are likely to become our companions in
		  future journeys. This article shows how the concept of
		  personal vehicles has changed in the last decades. Our
		  vehicles will become not only a safe and comfortable means
		  of transportation but also a digital platform for
		  entertainment and access to a vast quantity of information
		  while traveling.},
  author	= {Zhao, Yilin},
  doi		= {10.1109/5254.988442},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2002 -
		  Zhao - Telematics Safe and fun driving.pdf:pdf},
  issn		= {10947167},
  journal	= {IEEE Intelligent Systems and Their Applications},
  number	= {1},
  pages		= {10--14},
  title		= {{Telematics: Safe and fun driving}},
  volume	= {17},
  year		= {2002}
}

@Article{	  zhao2011,
  abstract	= {We have designed and implemented ARMor, a system that uses
		  software fault isolation (SFI) to sandbox application code
		  running on small embedded processors. Sandboxing can be
		  used to protect components such as the RTOS and critical
		  control loops from other, less-trusted components. ARMor
		  guarantees memory safety and control flow integrity; it
		  works by rewriting a binary to put a check in front of
		  every potentially dangerous operation. We formally and
		  automatically verify that an ARMored application respects
		  the SFI safety properties using the HOL theorem prover.
		  Thus, ARMor provides strong isolation guarantees and has an
		  exceptionally small trusted computing base-there is no
		  trusted compiler, binary rewriter, verifier, or operating
		  system. Copyright {\textcopyright} 2011 ACM.},
  author	= {Zhao, L.a and Li, G.b and Sutter, B.D.c and Regehr, J.a},
  doi		= {10.1145/2038642.2038687},
  file		= {:C$\backslash$:/Users/ysafaeis/Desktop/Sandboxing/p289-zhao.pdf:pdf}
		  ,
  isbn		= {978-1-4503-0712-3},
  journal	= {Embedded Systems Week 2011, ESWEEK 2011 - Proceedings of
		  the 9th ACM International Conference on Embedded Software,
		  EMSOFT'11},
  keywords	= {arm executables,automated theorem proving,program
		  logic,software fault isolation},
  pages		= {289--298},
  title		= {{ARMor: Fully verified software fault isolation}},
  url		= {http://www.scopus.com/inward/record.url?eid=2-s2.0-80455129085{\&}partnerID=40{\&}md5=17f69d5df7670ea6d41ad8a1c55fab3c}
		  ,
  year		= {2011}
}

@Article{	  zhou2007,
  author	= {Zhou, ZhenLiu and Xu, RongSheng},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2007 -
		  Zhou, Xu - {\{}BIOS{\}} Security Analysis and a Kind of
		  Trusted {\{}BIOS{\}}.pdf:pdf},
  isbn		= {9783540770473},
  issn		= {03029743},
  keywords	= {bios,tpm,trust measurement,trusted computing,uefi},
  pages		= {427--437},
  title		= {{{\{}BIOS{\}} Security Analysis and a Kind of Trusted
		  {\{}BIOS{\}}}},
  year		= {2007}
}

@Article{	  zhou2009,
  author	= {Zhou, Zhenliu and Fan, Jiapeng and Zhang, Nan and Xu,
		  Rongsheng},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2009 -
		  Zhou et al. - Advance and Development of Computer Firmware
		  Security Research.pdf:pdf},
  isbn		= {9789525726022},
  journal	= {Proceedings of the 2009 International Symposium on
		  Information Processing (ISIP)},
  number	= {1},
  title		= {{Advance and Development of Computer Firmware Security
		  Research}},
  volume	= {2},
  year		= {2009}
}

@Article{	  zhou2012,
  abstract	= {A trusted path is a protected channel that assures the
		  secrecy and authenticity of data transfers between a user's
		  input/output (I/O) device and a program trusted by that
		  user. We argue that, despite its incontestable necessity,
		  current commodity systems do not support trusted path with
		  any significant assurance. This paper presents a hyper
		  visor-based design that enables a trusted path to bypass an
		  untrusted operating-system, applications, and I/O devices,
		  with a minimal Trusted Computing Base (TCB). We also
		  suggest concrete I/O architectural changes that will
		  simplify future trusted-path system design. Our system
		  enables users to verify the states and configurations of
		  one or more trusted-paths using a simple, secret less,
		  hand-held device. We implement a simple user-oriented
		  trusted path as a case study.},
  annote	= {Humm, don't think this really pertains to the bus},
  author	= {Zhou, Zongwei and Gligor, Virgil D. and Newsome, James and
		  McCune, Jonathan M.},
  doi		= {10.1109/SP.2012.42},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2012 -
		  Zhou et al. - Building verifiable trusted path on commodity
		  x86 computers.pdf:pdf},
  isbn		= {9780769546810},
  issn		= {10816011},
  journal	= {Proceedings - IEEE Symposium on Security and Privacy},
  keywords	= {Device Input/Output,Hypervisor,Isolation,Trusted
		  Path,Trustworthy Computing},
  pages		= {616--630},
  title		= {{Building verifiable trusted path on commodity x86
		  computers}},
  year		= {2012}
}

@Article{	  zhou2012,
  abstract	= {In this paper, we present a systematic study for the de-
		  tection of malicious applications (or apps) on popular An-
		  droid Markets. To this end, we first propose a permission-
		  based behavioral footprinting scheme to detect new sam-
		  ples of known Android malware families. Then we apply a
		  heuristics-based filtering scheme to identify certain
		  inher- ent behaviors of unknown malicious families. We
		  imple- mented both schemes in a system called DroidRanger.
		  The experiments with 204, 040 apps collected from five
		  different Android Markets in May-June 2011 reveal 211
		  malicious ones: 32 from the official Android Market
		  (0.02{\%} infec- tion rate) and 179 from alternative
		  marketplaces (infection rates ranging from 0.20{\%} to
		  0.47{\%}). Among those mali- cious apps, our system also
		  uncovered two zero-day mal- ware (in 40 apps): one from the
		  official Android Market and the other from alternative
		  marketplaces. The results show that current marketplaces
		  are functional and rela- tively healthy. However, there is
		  also a clear need for a rigorous policing process,
		  especially for non-regulated al- ternative marketplaces.},
  author	= {Zhou, Yajin and Wang, Zhi and Zhou, Wu and Jiang, Xuxian},
  doi		= {http://www.internetsociety.org/hey-you-get-my-market-detecting-malicious-apps-official-and-alternative-android-markets}
		  ,
  file		= {::},
  journal	= {Proceedings of the 19th Annual Network and Distributed
		  System Security Symposium},
  number	= {2},
  pages		= {5--8},
  title		= {{Hey, You, Get Off of My Market: Detecting Malicious Apps
		  in Official and Alternative Android Markets}},
  year		= {2012}
}

@Article{	  zhou2014,
  author	= {Zhou, Yuchen and Evans, David},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2014 -
		  Zhou, Evans - SSOScan Automated Testing of Web Applications
		  for Single Sign-On Vulnerabilities.pdf:pdf},
  isbn		= {978-1-931971-15-7},
  journal	= {23rd USENIX Security Symposium (USENIX Security 14)},
  mendeley-groups={6 - Application/Logic and implementation flaws},
  pages		= {495--510},
  title		= {{SSOScan: Automated Testing of Web Applications for Single
		  Sign-On Vulnerabilities}},
  url		= {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/zhou}
		  ,
  year		= {2014}
}

@Article{	  zurko2005,
  abstract	= {User-centered security has been identified as a grand
		  challenge in information security and assurance. It is on
		  the brink of becoming an established subdomain of both
		  security and human/computer interface (HCI) research, and
		  an influence on the product development lifecycle. Both
		  security and HCI rely on the reality of interactions with
		  users to prove the utility and validity of their work. As
		  practitioners and researchers in those areas, we still face
		  major issues when applying even the most foundational tools
		  used in either of these fields across both of them. This
		  essay discusses the systemic roadblocks at the social,
		  technical, and pragmatic levels that user-centered security
		  must overcome to make substantial breakthroughs. Expert
		  evaluation and user testing are producing effective usable
		  security today. Principles such as safe staging,
		  enumerating usability failure risks, integrated security,
		  transparent security and reliance on trustworthy
		  authorities can also form the basis of improved systems},
  author	= {Zurko, Mary Ellen},
  doi		= {10.1109/CSAC.2005.60},
  file		= {:Users/adamd/Dropbox/Documents/Mendeley Desktop/2005 -
		  Zurko - User-centered security Stepping up to the grand
		  challenge.pdf:pdf},
  isbn		= {0769524613},
  issn		= {10639527},
  journal	= {Proceedings - Annual Computer Security Applications
		  Conference, ACSAC},
  pages		= {187--200},
  title		= {{User-centered security: Stepping up to the grand
		  challenge}},
  volume	= {2005},
  year		= {2005}
}
